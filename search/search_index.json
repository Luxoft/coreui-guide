{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to QML Core UI Guide You must be the change You wish to see in the world -- Gandhi (now a bumper sticker) Preface When you are part of a team that works on Qt Automotive Suite (short - Qt Auto), as Qt's vertical extension into the automotive market, you always wonder how new customers will approach Qt Auto, and how they will adapt it to their needs to create a truly stunning user experience for their automotive customers. From our research projects and production projects with various customers, we have gained valuable insights into this interesting market. Each project has its own unique constellation of management, design, development, and partnerships. This guide attempts to lay out the ground for a discussion about creating user interfaces which scale using technologies included in Qt and the Qt Automotive Suite developed by Luxoft with Partners , using an architecture we named the QML Core UI architecture. Naturally, customers shall be motivated to deviate from this Core UI Guide where necessary. This guide helps customers to get a base for fundamental discussions, internally and externally and hopefully the support required to come to a conclusion that helps them to achieve their own goals. / jryannel Why A fundamental aspect of creating an architecture is to define a vocabulary and vision of that architecture. Most of the work in this guide is funded by Luxoft, an engineering services company. You may wonder why a service company is willing to publish essential knowledge in open source under fairly permissive licenses. This is because, when we conduct customer projects in the UI domain, we have noticed certain recurring patterns. Our philosophy is not based on watching customers stumble over the same problems. Instead, we would like to be part of the solution, and prevent these problems from recurring in the first place. In this guide, you will see many mentions of \"automotive\". This starts with the name \"Qt Automotive Suite\". Automotive has various specifics aspects. The same applies to embedded hardware and software in the Industrial sector. They have one interesting thing in common: they speak about Human Machine Interface (HMI) or about Man-Machine Interface (MMI), whereas HighTech speaks about User Interfaces (UI). User Experience (UX) is still known in Automotive, but for a long time, it mostly was in terms of interior of the car and all about using buttons, switches, and pedals arranged around the steering wheel. In the course of convergence and digitalization, Automotive started to invest in making interfaces for users and less for machines and in seeing this as essential part of UX. We firmly believe that the Industrial sector and Embedded in general will follow this trend soon to and benefit from this guide. The Team This guide was initially designed and worked out as part of the Qt Auto effort at Luxoft. Being part of a team means the author is not the only contributor. Others contributed by ideas, converstations or even contributions. I would like to thank the Qt Auto team at Luxoft to allow me to write this guide as part of my daily work License Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free > Documentation License (FDL) version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. The code samples in this document are provided under BSD 3-Clause \"New\" or \"Revised\" License as published by the SPDX Workgroup a Linux Foundation Project","title":"Home"},{"location":"#welcome-to-qml-core-ui-guide","text":"You must be the change You wish to see in the world -- Gandhi (now a bumper sticker)","title":"Welcome to QML Core UI Guide"},{"location":"#preface","text":"When you are part of a team that works on Qt Automotive Suite (short - Qt Auto), as Qt's vertical extension into the automotive market, you always wonder how new customers will approach Qt Auto, and how they will adapt it to their needs to create a truly stunning user experience for their automotive customers. From our research projects and production projects with various customers, we have gained valuable insights into this interesting market. Each project has its own unique constellation of management, design, development, and partnerships. This guide attempts to lay out the ground for a discussion about creating user interfaces which scale using technologies included in Qt and the Qt Automotive Suite developed by Luxoft with Partners , using an architecture we named the QML Core UI architecture. Naturally, customers shall be motivated to deviate from this Core UI Guide where necessary. This guide helps customers to get a base for fundamental discussions, internally and externally and hopefully the support required to come to a conclusion that helps them to achieve their own goals. / jryannel","title":"Preface"},{"location":"#why","text":"A fundamental aspect of creating an architecture is to define a vocabulary and vision of that architecture. Most of the work in this guide is funded by Luxoft, an engineering services company. You may wonder why a service company is willing to publish essential knowledge in open source under fairly permissive licenses. This is because, when we conduct customer projects in the UI domain, we have noticed certain recurring patterns. Our philosophy is not based on watching customers stumble over the same problems. Instead, we would like to be part of the solution, and prevent these problems from recurring in the first place. In this guide, you will see many mentions of \"automotive\". This starts with the name \"Qt Automotive Suite\". Automotive has various specifics aspects. The same applies to embedded hardware and software in the Industrial sector. They have one interesting thing in common: they speak about Human Machine Interface (HMI) or about Man-Machine Interface (MMI), whereas HighTech speaks about User Interfaces (UI). User Experience (UX) is still known in Automotive, but for a long time, it mostly was in terms of interior of the car and all about using buttons, switches, and pedals arranged around the steering wheel. In the course of convergence and digitalization, Automotive started to invest in making interfaces for users and less for machines and in seeing this as essential part of UX. We firmly believe that the Industrial sector and Embedded in general will follow this trend soon to and benefit from this guide.","title":"Why"},{"location":"#the-team","text":"This guide was initially designed and worked out as part of the Qt Auto effort at Luxoft. Being part of a team means the author is not the only contributor. Others contributed by ideas, converstations or even contributions. I would like to thank the Qt Auto team at Luxoft to allow me to write this guide as part of my daily work","title":"The Team"},{"location":"#license","text":"Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free > Documentation License (FDL) version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. The code samples in this document are provided under BSD 3-Clause \"New\" or \"Revised\" License as published by the SPDX Workgroup a Linux Foundation Project","title":"License"},{"location":"admin/build/","text":"Qt Automotive Setup To create the first project you first need to have QtAuto installed. The easiest way is to use an existing Qt installation and install the remaining QtAuto modules. A more advanced option is to compile Qt5 and then install the QtAuto modules. An own Qt build is required if you are using Linux and want to use the multi-process mode, as it requires a qt build with Wayland support. The coreui-admin tool will support you in both scenarios. Note This chapter requires that you successfully installed the coreui-admin script. Please see the installation chapter for guidance. Existing Qt Please install Qt5 using the Qt online installer first. Now you should create a folder to host the QtAuto components and initialize the folder. 1 2 3 4 source mkdir qauto cd qauto coreui-admin init The init command will create a coreui.yml project document. You can either edit the document yourself or add config values. To edit the configuration just type 1 coreui-admin config --edit This will start your default editor and open the coreui document. Now we will tell coreui where the existing qt installation is, by setting the path to the qmake executable. For example on MACOS this should look like this: 1 coreui-admin config qmake ~/Qt/<version>/clang_64/bin/qmake From now on coreui-admin will use the existing Qt installation as the base. Note In case you need to build your own Qt leave the qmake configuration empty and use the coreui-admin qt command to build your custom Qt5 from the source. See the section Setup using custom Qt . Now we clone the QtAuto modules and build them. First, we can check the auto target using:: 1 coreui-admin targets auto This will print the currently listed repositories available under the auto-target. A target is an ordered list or repositories. The ordering defines the build order. This information is stored in the coreui.yml targets section. 1 2 ______name______|______________________repos______________________ auto | appman, qtivi, neptune3-ui Note If no target is given target all is automatically invoked. The list may vary based on your coreui.yml configuration. The next step would be to clone and build all auto repositories. 1 2 coreui-admin clone auto coreui-admin build auto The clones repositories are available in the source/<repo-name> and build/<repo-name> locations. After building the repositories will be automatically installed into install/<repo-name> . Note Be aware some repositories will automatically installed as Qt modules into the Qt directory and can not be found in the install location. If you later want to update your installation, you can simply run an update. 1 2 coreui-admin update auto coreui-admin build auto To clean the build you can run 1 coreui-admin clean auto Custom Qt If you want to use the multi-process setup on Linux or just want to use a custom Qt the script will support you in building Qt for your platform. The first step is to check if your OS can build Qt and the QtAuto components. For this run the OS command. 1 coreui-admin os --check Info The OS command is currently only supported on Ubuntu. The check command will either be positive or negative. In the case the result is negative please run the os init command. 1 coreui-admin os --init This command will either print the required steps to initialize your OS or ask you to install several packages onto your system. For this step administration privileges are required. After the OS configuration has been validated Qt can now be downloaded and build. 1 2 3 coreui-admin qt --clone coreui-admin qt --config coreui-admin qt --build The last step can take up to an hour, depending on your machine configuration. To set the number of make jobs (how many CPU cores make can use), you can edit the jobs config value. For example, for a great performance on a Core i7 Quad-Core Intel CPU, you can set the jobs to 6. You would still have two processors left to continue working. 1 coreui-admin config jobs 6 To check your configuration you can list the configuration values. 1 coreui-admin config Will output something like this 1 2 3 4 5 build | build install | install jobs | 6 qmake | ~/Qt/5.10.0/clang_64/bin/qmake source | source To unset a configuration value you can use the config --unset option. 1 coreui-admin config --unset qmake For more information on the coreui-admin script use the --help flag. Also each command has an own --help section.","title":"Building"},{"location":"admin/build/#qt-automotive-setup","text":"To create the first project you first need to have QtAuto installed. The easiest way is to use an existing Qt installation and install the remaining QtAuto modules. A more advanced option is to compile Qt5 and then install the QtAuto modules. An own Qt build is required if you are using Linux and want to use the multi-process mode, as it requires a qt build with Wayland support. The coreui-admin tool will support you in both scenarios. Note This chapter requires that you successfully installed the coreui-admin script. Please see the installation chapter for guidance.","title":"Qt Automotive Setup"},{"location":"admin/build/#existing-qt","text":"Please install Qt5 using the Qt online installer first. Now you should create a folder to host the QtAuto components and initialize the folder. 1 2 3 4 source mkdir qauto cd qauto coreui-admin init The init command will create a coreui.yml project document. You can either edit the document yourself or add config values. To edit the configuration just type 1 coreui-admin config --edit This will start your default editor and open the coreui document. Now we will tell coreui where the existing qt installation is, by setting the path to the qmake executable. For example on MACOS this should look like this: 1 coreui-admin config qmake ~/Qt/<version>/clang_64/bin/qmake From now on coreui-admin will use the existing Qt installation as the base. Note In case you need to build your own Qt leave the qmake configuration empty and use the coreui-admin qt command to build your custom Qt5 from the source. See the section Setup using custom Qt . Now we clone the QtAuto modules and build them. First, we can check the auto target using:: 1 coreui-admin targets auto This will print the currently listed repositories available under the auto-target. A target is an ordered list or repositories. The ordering defines the build order. This information is stored in the coreui.yml targets section. 1 2 ______name______|______________________repos______________________ auto | appman, qtivi, neptune3-ui Note If no target is given target all is automatically invoked. The list may vary based on your coreui.yml configuration. The next step would be to clone and build all auto repositories. 1 2 coreui-admin clone auto coreui-admin build auto The clones repositories are available in the source/<repo-name> and build/<repo-name> locations. After building the repositories will be automatically installed into install/<repo-name> . Note Be aware some repositories will automatically installed as Qt modules into the Qt directory and can not be found in the install location. If you later want to update your installation, you can simply run an update. 1 2 coreui-admin update auto coreui-admin build auto To clean the build you can run 1 coreui-admin clean auto","title":"Existing Qt"},{"location":"admin/build/#custom-qt","text":"If you want to use the multi-process setup on Linux or just want to use a custom Qt the script will support you in building Qt for your platform. The first step is to check if your OS can build Qt and the QtAuto components. For this run the OS command. 1 coreui-admin os --check Info The OS command is currently only supported on Ubuntu. The check command will either be positive or negative. In the case the result is negative please run the os init command. 1 coreui-admin os --init This command will either print the required steps to initialize your OS or ask you to install several packages onto your system. For this step administration privileges are required. After the OS configuration has been validated Qt can now be downloaded and build. 1 2 3 coreui-admin qt --clone coreui-admin qt --config coreui-admin qt --build The last step can take up to an hour, depending on your machine configuration. To set the number of make jobs (how many CPU cores make can use), you can edit the jobs config value. For example, for a great performance on a Core i7 Quad-Core Intel CPU, you can set the jobs to 6. You would still have two processors left to continue working. 1 coreui-admin config jobs 6 To check your configuration you can list the configuration values. 1 coreui-admin config Will output something like this 1 2 3 4 5 build | build install | install jobs | 6 qmake | ~/Qt/5.10.0/clang_64/bin/qmake source | source To unset a configuration value you can use the config --unset option. 1 coreui-admin config --unset qmake For more information on the coreui-admin script use the --help flag. Also each command has an own --help section.","title":"Custom Qt"},{"location":"admin/concepts/","text":"Concepts As a project solution, the coreui-admin guides you through the initial setup of QtAuto and the creation of an initial user interface based on QtAuto project. The script tries to be flexible and uses several generic concepts, which are described below. Configuration File The admin relies on a per-project configuration file ( coreui.yml ). It stores information about the build process and involved repositories. Additional you can place environment variables and small named scripts into the configuration document. Environment Variables Environment variables are passed on to the build or run commands and will be read from the shell environment but also can be placed into the coreui.yml config file in the env section. For user-contributed environment variables it is also possible to add environment variables into a .env file. Here the order a environment file will be read: coreui.yml in the env section .env file shell environment variable later entries will overwrite earlier entries. Repositories and Targets QtAuto supports the registration of repositories by name with the git URL, branch and used build-system. A repository listed can be made available in the target section. A target allows the bundling of one or more repositories as a sequence of build unit. The order repositories are build is the order they are defined in the target. Standardized Builds Registered repositories can have different build systems when registered with coreui. For this, coreui-admin supports currently three build systems ( configure , qmake , CMake ). Configure is used for the building of Qt itself and other projects may use qmake or CMake based projects. Scripts A script is a shell command line registered with the coreui configuration file. The environment variables are passed on to the script. Project Generators QtAuto allows you to generate a full project scaffold. The scaffolds are based on smart templates and follow a defined architecture. Aspect Generators Besides generating full project the coreui script allows also to extend the generated project using distinct components. This allows the extension of the generated project. The generator is also able to patch existing files in certain limits.","title":"Concepts"},{"location":"admin/concepts/#concepts","text":"As a project solution, the coreui-admin guides you through the initial setup of QtAuto and the creation of an initial user interface based on QtAuto project. The script tries to be flexible and uses several generic concepts, which are described below.","title":"Concepts"},{"location":"admin/concepts/#configuration-file","text":"The admin relies on a per-project configuration file ( coreui.yml ). It stores information about the build process and involved repositories. Additional you can place environment variables and small named scripts into the configuration document.","title":"Configuration File"},{"location":"admin/concepts/#environment-variables","text":"Environment variables are passed on to the build or run commands and will be read from the shell environment but also can be placed into the coreui.yml config file in the env section. For user-contributed environment variables it is also possible to add environment variables into a .env file. Here the order a environment file will be read: coreui.yml in the env section .env file shell environment variable later entries will overwrite earlier entries.","title":"Environment Variables"},{"location":"admin/concepts/#repositories-and-targets","text":"QtAuto supports the registration of repositories by name with the git URL, branch and used build-system. A repository listed can be made available in the target section. A target allows the bundling of one or more repositories as a sequence of build unit. The order repositories are build is the order they are defined in the target.","title":"Repositories and Targets"},{"location":"admin/concepts/#standardized-builds","text":"Registered repositories can have different build systems when registered with coreui. For this, coreui-admin supports currently three build systems ( configure , qmake , CMake ). Configure is used for the building of Qt itself and other projects may use qmake or CMake based projects.","title":"Standardized Builds"},{"location":"admin/concepts/#scripts","text":"A script is a shell command line registered with the coreui configuration file. The environment variables are passed on to the script.","title":"Scripts"},{"location":"admin/concepts/#project-generators","text":"QtAuto allows you to generate a full project scaffold. The scaffolds are based on smart templates and follow a defined architecture.","title":"Project Generators"},{"location":"admin/concepts/#aspect-generators","text":"Besides generating full project the coreui script allows also to extend the generated project using distinct components. This allows the extension of the generated project. The generator is also able to patch existing files in certain limits.","title":"Aspect Generators"},{"location":"admin/dev/","text":"Developing and Contributing To develop on a listed repository from your config document you need to clone the repository in an independent development folder and build it locally. This separation helps to have always a reference build available based on the upstream source code and a developer build based on your current modified version. The coreui-admin script helps you here using the dev command. The dev command allows you to clone and configure a repository inside a dev folder. If your project has support for Qt code-review coreui-admin will install the code-review commit templates and add Gerrit as a remote repository. To mark a repository for code-review add a code-review property in the repository section of your config document with the name of the review path. 1 2 3 4 5 6 neptune3-ui : url : git://code.qt.io/qt-apps/neptune3-ui.git branch : '5.13' build : qmake os : [ linux , macos ] codereview : \"qt-apps/neptune3-ui\" You use the dev command like this: 1 coreui-admin dev neptune3-ui This will create a dev/source/neptune3-ui and dev/build/neptune3-ui and after a successful build a dev/install/neptune3-ui . These folders are independent of your upstream tracking folders. In this workflow, you would edit the code in the dev/source/neptune3-ui folder to contribute to the Neptune3 UI. You can build and then upstream your changes. To check the upstream you would simply update the repo using coreui-admin update and build your upstream version of the repo. Note If you like to see what a command is doing, you can simply use the --dry-run option. The command will output a small message on how to configure Qt Creator to build and run your project.","title":"Developing"},{"location":"admin/dev/#developing-and-contributing","text":"To develop on a listed repository from your config document you need to clone the repository in an independent development folder and build it locally. This separation helps to have always a reference build available based on the upstream source code and a developer build based on your current modified version. The coreui-admin script helps you here using the dev command. The dev command allows you to clone and configure a repository inside a dev folder. If your project has support for Qt code-review coreui-admin will install the code-review commit templates and add Gerrit as a remote repository. To mark a repository for code-review add a code-review property in the repository section of your config document with the name of the review path. 1 2 3 4 5 6 neptune3-ui : url : git://code.qt.io/qt-apps/neptune3-ui.git branch : '5.13' build : qmake os : [ linux , macos ] codereview : \"qt-apps/neptune3-ui\" You use the dev command like this: 1 coreui-admin dev neptune3-ui This will create a dev/source/neptune3-ui and dev/build/neptune3-ui and after a successful build a dev/install/neptune3-ui . These folders are independent of your upstream tracking folders. In this workflow, you would edit the code in the dev/source/neptune3-ui folder to contribute to the Neptune3 UI. You can build and then upstream your changes. To check the upstream you would simply update the repo using coreui-admin update and build your upstream version of the repo. Note If you like to see what a command is doing, you can simply use the --dry-run option. The command will output a small message on how to configure Qt Creator to build and run your project.","title":"Developing and Contributing"},{"location":"admin/intro/","text":"Core UI Admin CLI The coreui-admin command line script allows you to control your QtAuto installation or to crearte a new CoreUI project. QtAuto is a set of components on top of Qt5 which allows you to create a typical user interface for the automotive market. To better support the market needs the script propagates an opinionated architecture called the CoreUI Architecture. The script is capable of building the underlying platform as also to generate CoreUI projects and core components of these projects. You can read more about the CoreUI architecture in the CoreUI section of the guide. The script supports your work-flow in several ways: Cloning, building the coreui repositories and Qt5 as also your custom projects Creating and running coreui based projects based on templates for single or multi-process architecture Adding core components based on the CoreUI architecture to a CoreUI project Running scripts to support your custom work-flow Managing your custom environment variable setup You can read more about the individual features in the concepts section of the admin guide. A separate chapter demonstrates the creation of a CoreUI architecture instance using a simple mental model.","title":"Introduction"},{"location":"admin/intro/#core-ui-admin-cli","text":"The coreui-admin command line script allows you to control your QtAuto installation or to crearte a new CoreUI project. QtAuto is a set of components on top of Qt5 which allows you to create a typical user interface for the automotive market. To better support the market needs the script propagates an opinionated architecture called the CoreUI Architecture. The script is capable of building the underlying platform as also to generate CoreUI projects and core components of these projects. You can read more about the CoreUI architecture in the CoreUI section of the guide. The script supports your work-flow in several ways: Cloning, building the coreui repositories and Qt5 as also your custom projects Creating and running coreui based projects based on templates for single or multi-process architecture Adding core components based on the CoreUI architecture to a CoreUI project Running scripts to support your custom work-flow Managing your custom environment variable setup You can read more about the individual features in the concepts section of the admin guide. A separate chapter demonstrates the creation of a CoreUI architecture instance using a simple mental model.","title":"Core UI Admin CLI"},{"location":"admin/projects/","text":"Project Creation Note This chapter expects you have already successfully setup the coreui-admin script (see script setup) and build the QtAuto components (see QtAuto setup). You can create a new project using the new command. 1 coreui-admin new myproject This will by default create a new project in the myproject folder using the qtauto-process template using Qt application manager. To change the template you can provide a --template option, but currently only the appman template is supported. To launch your newly created project you can use 1 coreui-admin start It will launch the appman from your given Qt SDK with the correct setup. Note To see all options please use coreui-admin new --help QtAuto Process UI To create a new multi-process project you can use the new command with the --template appman option. 1 coreui-admin new multi-ui --template appman This will create a new user interface project which has support for the Qt ApplicationManager built-in. System UI The System UI which acts as the desktop-like user interface in which other applications can be shown and contains a status bar to present system-wide information, it also manages any other overlays which do not directly belong to the applications. All other information is part of the individual applications. The SystemUI is started by launching the \"SystemUI.qml\" document in the sui folder or the Main.qml document in the root folder of your project. Note The SystemUI is launched by default when working with the QtCreator project. The SystemUI was also registered as the start script by the new project generator and can be launched using the start option of coreui-admin : coreui-admin start . Application UI An application is contained inside a apps folder and has its own Application.qml document. It is registered with the SystemUI and added to the launcher menu of the SystemUI. The newly created project can be launched using 1 coreui-admin start The start script invokes the appman executable form your QAuto installation and reads the generated am-config.yaml document in the project which provides all startup information to the application manager. Note The Qt Application manager requires a Wayland window manager to run in multi-process mode, which is often only available on Linux and the target HW. To allow the development of other hosts (e.g. Mac/Windows) the application manager has a single-process model that is automatically invoked on these environments. Please consult the Qt Application Manager documented for more information.","title":"Project Creation"},{"location":"admin/projects/#project-creation","text":"Note This chapter expects you have already successfully setup the coreui-admin script (see script setup) and build the QtAuto components (see QtAuto setup). You can create a new project using the new command. 1 coreui-admin new myproject This will by default create a new project in the myproject folder using the qtauto-process template using Qt application manager. To change the template you can provide a --template option, but currently only the appman template is supported. To launch your newly created project you can use 1 coreui-admin start It will launch the appman from your given Qt SDK with the correct setup. Note To see all options please use coreui-admin new --help","title":"Project Creation"},{"location":"admin/projects/#qtauto-process-ui","text":"To create a new multi-process project you can use the new command with the --template appman option. 1 coreui-admin new multi-ui --template appman This will create a new user interface project which has support for the Qt ApplicationManager built-in.","title":"QtAuto Process UI"},{"location":"admin/projects/#system-ui","text":"The System UI which acts as the desktop-like user interface in which other applications can be shown and contains a status bar to present system-wide information, it also manages any other overlays which do not directly belong to the applications. All other information is part of the individual applications. The SystemUI is started by launching the \"SystemUI.qml\" document in the sui folder or the Main.qml document in the root folder of your project. Note The SystemUI is launched by default when working with the QtCreator project. The SystemUI was also registered as the start script by the new project generator and can be launched using the start option of coreui-admin : coreui-admin start .","title":"System UI"},{"location":"admin/projects/#application-ui","text":"An application is contained inside a apps folder and has its own Application.qml document. It is registered with the SystemUI and added to the launcher menu of the SystemUI. The newly created project can be launched using 1 coreui-admin start The start script invokes the appman executable form your QAuto installation and reads the generated am-config.yaml document in the project which provides all startup information to the application manager. Note The Qt Application manager requires a Wayland window manager to run in multi-process mode, which is often only available on Linux and the target HW. To allow the development of other hosts (e.g. Mac/Windows) the application manager has a single-process model that is automatically invoked on these environments. Please consult the Qt Application Manager documented for more information.","title":"Application UI"},{"location":"admin/reference/","text":"Reference Command Line Usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Usage: coreui-admin [OPTIONS] COMMAND [ARGS]... coreui adminstration tool Options: -v, --verbose Enables verbose mode. --dry-run / --no-dry-run operations are not executed, only printed --log-level [info|debug|warning|error] sets the log level --help Show this message and exit. Commands: app creates a new application build Builds one or more repos clean cleans the build, install and optional the source folder clone clones the coreui repositories into this workspace config configures coreui env display.env variables generate Creates a new aspect init creates an empty coreui workspace new creates a new coreui project os prepares the OS to build coreui pull updates the coreui repositories qt support for building qt repos manages the listed repos run runs a script from the config script section by name start starts a project targets manages the buildable targets Initialisation 1 2 3 4 5 6 Usage: coreui-admin init [OPTIONS] Initialized the workspace by writing the `coreui.yml` setup document Options: --help Show this message and exit. Configuration 1 2 3 4 5 6 Usage: coreui-admin config [OPTIONS] [NAME] [VALUE] Options: --unset TEXT --edit / --no-edit --help Show this message and exit. The configuration document coreui.yml contains a section called config to configure coreui-admin general behavior. The supported values are currently: source , install , build path (defaults to \"source\", \"install\", \"build\") jobs : make jobs (defaults to 2) qmake : qmake path (defaults to empty) You can set the option using the config command. For example to set the jobs option to 6 use 1 coreui-admin config jobs 6 In case you want to edit the whole coreui.yml document you can just type 1 coreui-admin config --edit This will open your default editor and display the configuration document. Targets The configuration document has a section of targets , which is a list of repositories. The repositories order is important for the order of build. 1 2 3 4 targets : auto : - appman - dlt-daemon Repositories The coreui.yml document has an own section for repos listed. The repos are listed with a name, url, branch and the build-type. The name is the name the project will be checkout and being identified using other commands. The url should be a standard git url. The branch is the branch being checkout out. The build-type can be qmake or cmake - othe build types are currently not supported. In the coreui.yml document a repos section looks like this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 config : jobs : 2 qmake : /Users/jryannel/Qt/5.10.0/clang_64/bin/qmake env : QT_SCALE_FACTOR : '0.75' repos : appman : branch : '5.10' build : qmake os : [ linux , macos ] url : git://code.qt.io/qt/qtapplicationmanager.git dlt-daemon : branch : master build : cmake os : [ linux ] url : git://github.com/GENIVI/dlt-daemon.git scripts : {} targets : auto : - appman - dlt-daemon You can use the coreui-admin repos command to manage the repositories. See coreui-admin repos --help for more information. A repository can have also a scripts dictionary attached. This dictionary is automatically attached to the scripts section of the coreui-admin config document. Environment Variables All commands wil inherit the system environment variables. There are several ways to add additional environment variables. Either project wide enviroment variables can be set in the coreui.yml document in the env section or using a local .env file next to the coreui.yml . In the coreui.yml document you need to fill in the env section using a key value pair format. 1 2 env : QT_SCALE_FACTOR : \"0.75\" The .env file is a YAML formatted document with key value pairs. The order of lookup is first user local using .env file second coreui.yml env section last system environment variables You can use the coreui-admin env command to list the different environment variables. See more information using coreui-admin env --help","title":"Reference"},{"location":"admin/reference/#reference","text":"","title":"Reference"},{"location":"admin/reference/#command-line-usage","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Usage: coreui-admin [OPTIONS] COMMAND [ARGS]... coreui adminstration tool Options: -v, --verbose Enables verbose mode. --dry-run / --no-dry-run operations are not executed, only printed --log-level [info|debug|warning|error] sets the log level --help Show this message and exit. Commands: app creates a new application build Builds one or more repos clean cleans the build, install and optional the source folder clone clones the coreui repositories into this workspace config configures coreui env display.env variables generate Creates a new aspect init creates an empty coreui workspace new creates a new coreui project os prepares the OS to build coreui pull updates the coreui repositories qt support for building qt repos manages the listed repos run runs a script from the config script section by name start starts a project targets manages the buildable targets","title":"Command Line Usage"},{"location":"admin/reference/#initialisation","text":"1 2 3 4 5 6 Usage: coreui-admin init [OPTIONS] Initialized the workspace by writing the `coreui.yml` setup document Options: --help Show this message and exit.","title":"Initialisation"},{"location":"admin/reference/#configuration","text":"1 2 3 4 5 6 Usage: coreui-admin config [OPTIONS] [NAME] [VALUE] Options: --unset TEXT --edit / --no-edit --help Show this message and exit. The configuration document coreui.yml contains a section called config to configure coreui-admin general behavior. The supported values are currently: source , install , build path (defaults to \"source\", \"install\", \"build\") jobs : make jobs (defaults to 2) qmake : qmake path (defaults to empty) You can set the option using the config command. For example to set the jobs option to 6 use 1 coreui-admin config jobs 6 In case you want to edit the whole coreui.yml document you can just type 1 coreui-admin config --edit This will open your default editor and display the configuration document.","title":"Configuration"},{"location":"admin/reference/#targets","text":"The configuration document has a section of targets , which is a list of repositories. The repositories order is important for the order of build. 1 2 3 4 targets : auto : - appman - dlt-daemon","title":"Targets"},{"location":"admin/reference/#repositories","text":"The coreui.yml document has an own section for repos listed. The repos are listed with a name, url, branch and the build-type. The name is the name the project will be checkout and being identified using other commands. The url should be a standard git url. The branch is the branch being checkout out. The build-type can be qmake or cmake - othe build types are currently not supported. In the coreui.yml document a repos section looks like this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 config : jobs : 2 qmake : /Users/jryannel/Qt/5.10.0/clang_64/bin/qmake env : QT_SCALE_FACTOR : '0.75' repos : appman : branch : '5.10' build : qmake os : [ linux , macos ] url : git://code.qt.io/qt/qtapplicationmanager.git dlt-daemon : branch : master build : cmake os : [ linux ] url : git://github.com/GENIVI/dlt-daemon.git scripts : {} targets : auto : - appman - dlt-daemon You can use the coreui-admin repos command to manage the repositories. See coreui-admin repos --help for more information. A repository can have also a scripts dictionary attached. This dictionary is automatically attached to the scripts section of the coreui-admin config document.","title":"Repositories"},{"location":"admin/reference/#environment-variables","text":"All commands wil inherit the system environment variables. There are several ways to add additional environment variables. Either project wide enviroment variables can be set in the coreui.yml document in the env section or using a local .env file next to the coreui.yml . In the coreui.yml document you need to fill in the env section using a key value pair format. 1 2 env : QT_SCALE_FACTOR : \"0.75\" The .env file is a YAML formatted document with key value pairs. The order of lookup is first user local using .env file second coreui.yml env section last system environment variables You can use the coreui-admin env command to list the different environment variables. See more information using coreui-admin env --help","title":"Environment Variables"},{"location":"admin/start/","text":"Quick Start Installation To use the admin we first need to install it as part of our environment. 1 2 3 git clone https://github.com/Luxoft/qml-coreui.git cd qml-coreui pip install . Setting up QtAuto Stack The simplest start is to use an existing Qt SDK (e.g. 5.13 incl. Qt Remote Objects TP) and build of QtAuto components. This is a great start to the creation of a new user interface for systems. Create a project directory 1 mkdir coreui && cd coreui Write the config file coreui.yml 1 coreui-admin init Configure qmake to use existing Qt5 SDK 1 coreui-admin config qmake <path/to/qmake> Clone QtAuto source repositories 1 coreui-admin clone auto Build all QtAuto repositories 1 coreui-admin build auto Note: Please make sure that all coreui components are successfully configured. Now we can start the QtAuto reference user interface called Neptune3 UI. 1 coreui-admin start The script was automatically registered while building the QtAuto repositories. Setting up a new CoreUI project Now we can create the single-process UI 1 2 coreui-admin new myproject cd myproject We first let the admin know where the existing Qt SDK is located. For this, we point it to the qmake executable for the SDK. 1 coreui-admin config qmake <path/to/qmake> We can launch the UI using the start script, which was registered by the project generator. 1 coreui-admin start To develop with the newly created UI you can open QtCreator and open the myproject/myproject.qmlproject project.","title":"Quick Start"},{"location":"admin/start/#quick-start","text":"","title":"Quick Start"},{"location":"admin/start/#installation","text":"To use the admin we first need to install it as part of our environment. 1 2 3 git clone https://github.com/Luxoft/qml-coreui.git cd qml-coreui pip install .","title":"Installation"},{"location":"admin/start/#setting-up-qtauto-stack","text":"The simplest start is to use an existing Qt SDK (e.g. 5.13 incl. Qt Remote Objects TP) and build of QtAuto components. This is a great start to the creation of a new user interface for systems. Create a project directory 1 mkdir coreui && cd coreui Write the config file coreui.yml 1 coreui-admin init Configure qmake to use existing Qt5 SDK 1 coreui-admin config qmake <path/to/qmake> Clone QtAuto source repositories 1 coreui-admin clone auto Build all QtAuto repositories 1 coreui-admin build auto Note: Please make sure that all coreui components are successfully configured. Now we can start the QtAuto reference user interface called Neptune3 UI. 1 coreui-admin start The script was automatically registered while building the QtAuto repositories.","title":"Setting up QtAuto Stack"},{"location":"admin/start/#setting-up-a-new-coreui-project","text":"Now we can create the single-process UI 1 2 coreui-admin new myproject cd myproject We first let the admin know where the existing Qt SDK is located. For this, we point it to the qmake executable for the SDK. 1 coreui-admin config qmake <path/to/qmake> We can launch the UI using the start script, which was registered by the project generator. 1 coreui-admin start To develop with the newly created UI you can open QtCreator and open the myproject/myproject.qmlproject project.","title":"Setting up a new CoreUI project"},{"location":"extensions/overview/","text":"QML CoreUI Extensions Info This material is work in progress and will change! A set of common extensions used for the CoreUI Architecture CoreUI SDK The CoreUI SDK is based on top of the Qt Automotive SDK. At its heart it is a collection of extensions and a comprehensive guide to build user interfaces for embedded systems. The SDK is accompanied by the admin tool to generate project based on the CoreUI principles. CoreUI extends Qt Automotive by providing a clean architecture to establish mutli process user interface for embedded systems. CoreUI Guide CoreUI Extensions CoreUI Admin CoreUI Demo Building the extension The extension are Qt static libraries and plugins. The plugins are build into the $BUILD_DIR/imports folder and the static libraries into the $BUILD_DIR/libs folder. 1 2 mkdir build && cd build qmake .. / coreui - extensions . pro && make && make install After installation the plugins are installed into the $QTDIR/qml folder. Extensions CoreUI Extension Provides the common sets of base classes to build the typical CoreUI UI types (e.g. Store, Panel, Control, View) JSON Extension Provide extensions to manage JSON document from QML. SQL Extension Provides extensions to manage SQLITE databases from QML Trace Extension Provides extensions to trace the UI from QML Shell Extensions Provides extensions to use an interactive shell in you UI","title":"QML CoreUI Extensions"},{"location":"extensions/overview/#qml-coreui-extensions","text":"Info This material is work in progress and will change! A set of common extensions used for the CoreUI Architecture","title":"QML CoreUI Extensions"},{"location":"extensions/overview/#coreui-sdk","text":"The CoreUI SDK is based on top of the Qt Automotive SDK. At its heart it is a collection of extensions and a comprehensive guide to build user interfaces for embedded systems. The SDK is accompanied by the admin tool to generate project based on the CoreUI principles. CoreUI extends Qt Automotive by providing a clean architecture to establish mutli process user interface for embedded systems. CoreUI Guide CoreUI Extensions CoreUI Admin CoreUI Demo","title":"CoreUI SDK"},{"location":"extensions/overview/#building-the-extension","text":"The extension are Qt static libraries and plugins. The plugins are build into the $BUILD_DIR/imports folder and the static libraries into the $BUILD_DIR/libs folder. 1 2 mkdir build && cd build qmake .. / coreui - extensions . pro && make && make install After installation the plugins are installed into the $QTDIR/qml folder.","title":"Building the extension"},{"location":"extensions/overview/#extensions","text":"","title":"Extensions"},{"location":"extensions/overview/#coreui-extension","text":"Provides the common sets of base classes to build the typical CoreUI UI types (e.g. Store, Panel, Control, View)","title":"CoreUI Extension"},{"location":"extensions/overview/#json-extension","text":"Provide extensions to manage JSON document from QML.","title":"JSON Extension"},{"location":"extensions/overview/#sql-extension","text":"Provides extensions to manage SQLITE databases from QML","title":"SQL Extension"},{"location":"extensions/overview/#trace-extension","text":"Provides extensions to trace the UI from QML","title":"Trace Extension"},{"location":"extensions/overview/#shell-extensions","text":"Provides extensions to use an interactive shell in you UI","title":"Shell Extensions"},{"location":"guide/cookbook/","text":"CookBook Info This material is work in progress and will change! CoreUI defines a set of component kinds, these are controls, panels, views, stores as also applications on the UI side but also services on the native side. To make it easier coreui-admin allows you to generate these kinds for educational purpose and demonstration purpose. Create UI Components Create an Application To create an application you need to define the application package as also the application name. For example to create an empty About application using the package org.example.about use the app command. 1 coreui - admin app org . example . about About The output will be 1 2 3 4 5 6 using workspace `~/ work / luxoft / tryout / myproject ` WRITE : ui / apps / org . example . about / info . yaml WRITE : ui / apps / org . example . about / AppShell . qml WRITE : ui / apps / org . example . about / stores / RootStore . qml WRITE : ui / apps / org . example . about / views / WelcomeView . qml WRITE : ui / apps / org . example . about / panels / WelcomePanel . qml This will create the about app inside the ui/apps/org.example.about using the initial CoreUI architecture. Have a look and see the code. Adding a View A view is a visual type and uses a store to access business logic. The top level store is called RootStore . 1 coreui - admin gen view org . example . about About The output will be 1 2 generate aspect view in project apps WRITE : ui / apps / org . example . about / views / AboutView . qml This will create a view named AboutView inside the application views folder. Adding a store To add a child store to the RootStore you need to provide the applicationpackage as also the store name. 1 coreui - admin gen store org . example . about Status The output should be 1 2 3 4 using workspace `~/ work / luxoft / tryout / myproject ` generate aspect store in project apps WRITE : ui / apps / org . example . about / stores / StatusStore . qml PATCH / Users / jryannel / work / luxoft / tryout / myproject / ui / apps / org . example . about / stores / RootStore . qml with property StatusStore statusStore : StatusStore { } The last PATCH line indicates the RootStore was patched with a reference with the newly created StatusStore . Note Adding a Panel , Control , Helper Adding components of these kinds works very similar to the points above. Adding native components Adding an plugin To add a QtQuick plugin you need to run the gen plugin generator. For example to add a heater plugin we can just write 1 coreui - admin gen plugin heater This will produce 1 2 3 4 5 6 using workspace `~/ work / luxoft / tryout / myproject ` generate aspect plugin in project apps WRITE : native / plugins / heater / heater . pro WRITE : native / plugins / heater / plugin . h WRITE : native / plugins / heater / plugin . cpp PATCH / Users / jryannel / work / luxoft / tryout / myproject / native / plugins / plugins . pro with SUBDIRS += heater This will create a scaffold plugin named heater in the native/plugins directory and register the project with the plugins project file. Adding a service To add a QtIVI service to the native project use the gen service generator. 1 coreui - admin gen service service . heater This would create a heater service with the package service.heater . The QtIVI service will support a simulation backend, a default backend and a QtRemoteObjects backend. To suport shared business logic the logic shouldbe placed into the service plugin whch can be used by the service backends. The command above will output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 using workspace `~/ work / luxoft / tryout / myproject ` generate aspect service in project apps write initial service .. WRITE : native / services / interfaces / service_heater . qface WRITE : native / services / service_heater / service_heater . pro PATCH / Users / jryannel / work / luxoft / tryout / myproject / native / services / services . pro with SUBDIRS += service_heater PATCH / Users / jryannel / work / luxoft / tryout / myproject / native / services / services . pro with OTHER_FILES += interfaces / service_heater . qface write frontend library ... WRITE : native / services / service_heater / frontend / frontend . pro write qml - plugin ... WRITE : native / services / service_heater / plugin / plugin . pro WRITE : native / services / service_heater / plugin / plugin . h WRITE : native / services / service_heater / plugin / plugin . cpp WRITE : native / services / service_heater / plugin / qmldir write custom backend ivi - plugin .. WRITE : native / services / service_heater / backend / backend . pro WRITE : native / services / service_heater / backend / plugin . h WRITE : native / services / service_heater / backend / plugin . cpp WRITE : native / services / service_heater / backend / heater . json write simulation backend ivi - plugin ... WRITE : native / services / service_heater / backend_simu / backend_simu . pro WRITE : native / services / service_heater / backend_simu / plugin_resource . qrc WRITE : native / services / service_heater / backend_simu / simulation . qml write qtro backend ivi - plugin ... WRITE : native / services / service_heater / backend_qtro / backend_qtro . pro write qtro server executable ... WRITE : native / services / service_heater / server_qtro / server_qtro . pro WRITE : native / services / service_heater / server_qtro / main . cpp WRITE : native / services / service_heater / server_qtro / server . cpp WRITE : native / services / service_heater / server_qtro / server . h Please read the QtIVI documentation to get more insights about the structure. Conclusion coreui-admin allows you to easily scaffold many kind of UI or native components. This code generation capabilities target mostly the educational purpose to make it esier to document the process. Just play around with the code geenration part. And you will encounter issues :-)","title":"CookBook"},{"location":"guide/cookbook/#cookbook","text":"Info This material is work in progress and will change! CoreUI defines a set of component kinds, these are controls, panels, views, stores as also applications on the UI side but also services on the native side. To make it easier coreui-admin allows you to generate these kinds for educational purpose and demonstration purpose.","title":"CookBook"},{"location":"guide/cookbook/#create-ui-components","text":"","title":"Create UI Components"},{"location":"guide/cookbook/#create-an-application","text":"To create an application you need to define the application package as also the application name. For example to create an empty About application using the package org.example.about use the app command. 1 coreui - admin app org . example . about About The output will be 1 2 3 4 5 6 using workspace `~/ work / luxoft / tryout / myproject ` WRITE : ui / apps / org . example . about / info . yaml WRITE : ui / apps / org . example . about / AppShell . qml WRITE : ui / apps / org . example . about / stores / RootStore . qml WRITE : ui / apps / org . example . about / views / WelcomeView . qml WRITE : ui / apps / org . example . about / panels / WelcomePanel . qml This will create the about app inside the ui/apps/org.example.about using the initial CoreUI architecture. Have a look and see the code.","title":"Create an Application"},{"location":"guide/cookbook/#adding-a-view","text":"A view is a visual type and uses a store to access business logic. The top level store is called RootStore . 1 coreui - admin gen view org . example . about About The output will be 1 2 generate aspect view in project apps WRITE : ui / apps / org . example . about / views / AboutView . qml This will create a view named AboutView inside the application views folder.","title":"Adding a View"},{"location":"guide/cookbook/#adding-a-store","text":"To add a child store to the RootStore you need to provide the applicationpackage as also the store name. 1 coreui - admin gen store org . example . about Status The output should be 1 2 3 4 using workspace `~/ work / luxoft / tryout / myproject ` generate aspect store in project apps WRITE : ui / apps / org . example . about / stores / StatusStore . qml PATCH / Users / jryannel / work / luxoft / tryout / myproject / ui / apps / org . example . about / stores / RootStore . qml with property StatusStore statusStore : StatusStore { } The last PATCH line indicates the RootStore was patched with a reference with the newly created StatusStore . Note Adding a Panel , Control , Helper Adding components of these kinds works very similar to the points above.","title":"Adding a store"},{"location":"guide/cookbook/#adding-native-components","text":"","title":"Adding native components"},{"location":"guide/cookbook/#adding-an-plugin","text":"To add a QtQuick plugin you need to run the gen plugin generator. For example to add a heater plugin we can just write 1 coreui - admin gen plugin heater This will produce 1 2 3 4 5 6 using workspace `~/ work / luxoft / tryout / myproject ` generate aspect plugin in project apps WRITE : native / plugins / heater / heater . pro WRITE : native / plugins / heater / plugin . h WRITE : native / plugins / heater / plugin . cpp PATCH / Users / jryannel / work / luxoft / tryout / myproject / native / plugins / plugins . pro with SUBDIRS += heater This will create a scaffold plugin named heater in the native/plugins directory and register the project with the plugins project file.","title":"Adding an plugin"},{"location":"guide/cookbook/#adding-a-service","text":"To add a QtIVI service to the native project use the gen service generator. 1 coreui - admin gen service service . heater This would create a heater service with the package service.heater . The QtIVI service will support a simulation backend, a default backend and a QtRemoteObjects backend. To suport shared business logic the logic shouldbe placed into the service plugin whch can be used by the service backends. The command above will output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 using workspace `~/ work / luxoft / tryout / myproject ` generate aspect service in project apps write initial service .. WRITE : native / services / interfaces / service_heater . qface WRITE : native / services / service_heater / service_heater . pro PATCH / Users / jryannel / work / luxoft / tryout / myproject / native / services / services . pro with SUBDIRS += service_heater PATCH / Users / jryannel / work / luxoft / tryout / myproject / native / services / services . pro with OTHER_FILES += interfaces / service_heater . qface write frontend library ... WRITE : native / services / service_heater / frontend / frontend . pro write qml - plugin ... WRITE : native / services / service_heater / plugin / plugin . pro WRITE : native / services / service_heater / plugin / plugin . h WRITE : native / services / service_heater / plugin / plugin . cpp WRITE : native / services / service_heater / plugin / qmldir write custom backend ivi - plugin .. WRITE : native / services / service_heater / backend / backend . pro WRITE : native / services / service_heater / backend / plugin . h WRITE : native / services / service_heater / backend / plugin . cpp WRITE : native / services / service_heater / backend / heater . json write simulation backend ivi - plugin ... WRITE : native / services / service_heater / backend_simu / backend_simu . pro WRITE : native / services / service_heater / backend_simu / plugin_resource . qrc WRITE : native / services / service_heater / backend_simu / simulation . qml write qtro backend ivi - plugin ... WRITE : native / services / service_heater / backend_qtro / backend_qtro . pro write qtro server executable ... WRITE : native / services / service_heater / server_qtro / server_qtro . pro WRITE : native / services / service_heater / server_qtro / main . cpp WRITE : native / services / service_heater / server_qtro / server . cpp WRITE : native / services / service_heater / server_qtro / server . h Please read the QtIVI documentation to get more insights about the structure.","title":"Adding a service"},{"location":"guide/cookbook/#conclusion","text":"coreui-admin allows you to easily scaffold many kind of UI or native components. This code generation capabilities target mostly the educational purpose to make it esier to document the process. Just play around with the code geenration part. And you will encounter issues :-)","title":"Conclusion"},{"location":"guide/examples/","text":"Examples Info This material is work in progress and will change! Neptune UI V3 NeptuneUI is the reference UI for QtAuto as also for large scale Qt project. It is developed inside the QtAuto team to act as a demo but also as a reference architecture application. The largest example of the CoreUI architecture is the NeptuneUI , which is part of thew QtAuto project. It was tried for a long time to document NeptuneUI which was difficult as the software was moving. So the CoreUI architecture guide was creted as an idea how an architecture could be and the NeptuneUI ws then refctored to follow this CoreUI guide. Other Examples ... to be continued","title":"Examples"},{"location":"guide/examples/#examples","text":"Info This material is work in progress and will change!","title":"Examples"},{"location":"guide/examples/#neptune-ui-v3","text":"NeptuneUI is the reference UI for QtAuto as also for large scale Qt project. It is developed inside the QtAuto team to act as a demo but also as a reference architecture application. The largest example of the CoreUI architecture is the NeptuneUI , which is part of thew QtAuto project. It was tried for a long time to document NeptuneUI which was difficult as the software was moving. So the CoreUI architecture guide was creted as an idea how an architecture could be and the NeptuneUI ws then refctored to follow this CoreUI guide.","title":"Neptune UI V3"},{"location":"guide/examples/#other-examples","text":"... to be continued","title":"Other Examples"},{"location":"guide/install/","text":"Install Info This material is work in progress and will change! CoreUI is not really something to be installed. It is more an approach to write large scaled user interfaces using Qt and Qt Auto. Still there is a helper library and tools to help you getting started and which is used throughout the guide. The tool is called coreui-admin which can be used to create new sample projects or add aspects to these projects. This tool purpose is to make the guide more compact. Instead of describing in detail how to setup a project, it is possible now just to create a project using coreui-admin new myproject . The coreui-admin tool is a Python 3 script which can be easily installed using the standard python tooling. Requirements The script requires a Python (3.5> ) installation with the PIP package manager installed. Installation You install the tool directly from this repository using the python package manager 1 2 3 git clone https : // github . com / Luxoft / qml - coreui . git cd qml - coreui pip install . Note On Ubuntu you might need to add $HOME/.local/bin to you $PATH Info If you intent to work om the script you can install an editable installation which only installs links to the original source. 1 pip install - e . --upgrade To update the installation you need to update the repository. 1 2 cd coreui - admin git pull Now the coreui-admin is updated to the latest from the remote repository. Uninstall To de install the script you can to use the pip tool 1 pip uninstall coreui - admin Using virtualenv In case you do not want to pollute your local python installation you can use python virtualenv 1 2 3 pip install virtualenv virtualenv - p python3 venv source venv / bin / activate Now install coreui-admin and to exit this python virtual environment call deactivate . First use After the installation the coreui-admin command is at your disposal. 1 coreui - admin --help","title":"Install"},{"location":"guide/install/#install","text":"Info This material is work in progress and will change! CoreUI is not really something to be installed. It is more an approach to write large scaled user interfaces using Qt and Qt Auto. Still there is a helper library and tools to help you getting started and which is used throughout the guide. The tool is called coreui-admin which can be used to create new sample projects or add aspects to these projects. This tool purpose is to make the guide more compact. Instead of describing in detail how to setup a project, it is possible now just to create a project using coreui-admin new myproject . The coreui-admin tool is a Python 3 script which can be easily installed using the standard python tooling.","title":"Install"},{"location":"guide/install/#requirements","text":"The script requires a Python (3.5> ) installation with the PIP package manager installed.","title":"Requirements"},{"location":"guide/install/#installation","text":"You install the tool directly from this repository using the python package manager 1 2 3 git clone https : // github . com / Luxoft / qml - coreui . git cd qml - coreui pip install . Note On Ubuntu you might need to add $HOME/.local/bin to you $PATH Info If you intent to work om the script you can install an editable installation which only installs links to the original source. 1 pip install - e . --upgrade To update the installation you need to update the repository. 1 2 cd coreui - admin git pull Now the coreui-admin is updated to the latest from the remote repository.","title":"Installation"},{"location":"guide/install/#uninstall","text":"To de install the script you can to use the pip tool 1 pip uninstall coreui - admin","title":"Uninstall"},{"location":"guide/install/#using-virtualenv","text":"In case you do not want to pollute your local python installation you can use python virtualenv 1 2 3 pip install virtualenv virtualenv - p python3 venv source venv / bin / activate Now install coreui-admin and to exit this python virtual environment call deactivate .","title":"Using virtualenv"},{"location":"guide/install/#first-use","text":"After the installation the coreui-admin command is at your disposal. 1 coreui - admin --help","title":"First use"},{"location":"guide/overview/","text":"What is QML Core UI No matter what the problem is, it's always a people problem. Jerry Weinberg Abstract CoreUI was created out of the need for a more structured way of creating User Interfaces (UIs) not only for applications but also for large systems. Our current process worked fine if only a few people work on a user interface. But, as the user interface starts to get bigger and the number of people working on the UI layer increases, then the existing process was no longer well defined. It just doesn't scale. Ideally, CoreUI provides a pattern to scale UI development linearly without scrutinizing the implementation of UI features. Motivation When observing Developers working on larger UIs, it is interesting to see the correlation between the development productivity and the UI complexity. Particularly, the development productivity drops as the UI complexity increases. For example, developers need to start the whole UI to navigate into a detailed view to fine-tune some UI logic or even animation. Often, this is because the UI can't be broken down into smaller, manageable chunks. In practical terms, it's about isolating a smaller portion of the UI and being able to work and validate this smaller portion. Breaking down the UI often happens on larger layers. But for UI development where the UI experience is an important factor, it's necessary to fine-tune small aspects of the UI to achieve the desired look and behavior. You have to aim for a fast (< 1s) round trip time to make the conversation seamless between Design and Development. To be able to achive this you need to be able to decompose (break down) the UI into smaller parts and being able to run these parts standalone. This will allow you to focus solely on the user experience of that particular part and allow a faster cycle of edit-build-validate. You can easily avoid this situation with Qt and QML. While QML offers a great component model, it lacks a coherent approach to componentize the UI and to implement these UI components. Looking at the current development approach it is clear that the UI's physical structure and the component types are created by following a UI specification or INformation Architecture and not from a technical perspective. For a developer, it's not clear when and how exactly to split a component into smaller parts, where to place them and to ensure a component is truly reusable as well as usable outside of its context. CoreUI is an attempt to create an architecture and process to streamline this component creation task, similar to a component factory. What is CoreUI? CoreUI is set of patterns and components to support a common user interface structure. It encourages both developers and designers to create a great user experience by focusing on the UI creation process. The CoreUI architecture is the result of the creation and re-creation of user interface projects for various markets, especially the automotive one. After several re-creations of user interface projects for vertical markets, some patterns emerged. The CoreUI architecture as presented here is the distillation of these patterns. CoreUI is an embedded development framework using Qt5 and the QML/JS language. Programming embedded software user interfaces can often be unnecessarily complicated. CoreUI makes the programming of these user interfaces easier, by making assumptions about what every developer needs to get started to create stunning user interfaces. It allows you to develop user interfaces by writing less code but accomplishing more. CoreUI aims to bring back the fun and creativity to user interface development so that developers and designers can focus on the user experience again. CoreUI is based on the opinions of others. These opinions make assumptions about what is the best way to create user interfaces. CoreUI is meant to be used that way and discourages other ways. If you master CoreUI you'll probably experience a spike in productivity. If you keep up with your old habits and try to retrofit CoreUI with your old ways of working you may not reap CoreUI's full benefits. What CoreUI is not? CoreUI is partly a concrete framework but it's not an exact path; more as a guideline. Often during a project, not all of the requirements are foreseeable and it's necessary to deviate from the path suggested. CoreUI isn't an implementation of a user interface. It's also not designed for a single application, but covers a multi-application setup. CoreUI is not final :-) CoreUI stack CoreuI is founded on top of Qt5 and Qt Automotive Suite. Qt5 is the leading cross-platform native UI toolkit with an unprecedented focus on the user experience. It offers the developer all the necessary APIs to develop a truly native cross-platform application. Qt Automotive Suite extends Qt5, bringing multi-process application capabilities and a service framework to the table. By this, Qt Automotive Suite is extending Qt into the space of creating multi-process user interfaces for mid and high-end embedded systems. Even if Qt Automotive Suite targets primarily the automotive market, it's not limited to this market. CoreUI defines patterns and rules for the UI layer of a multi-process UI for embedded systems based on Qt Automotive Suite. A reference implementation of CoreUI is the Neptune3 UI which is delivered together with Qt Automotive Suite.","title":"Overview"},{"location":"guide/overview/#what-is-qml-core-ui","text":"No matter what the problem is, it's always a people problem. Jerry Weinberg Abstract CoreUI was created out of the need for a more structured way of creating User Interfaces (UIs) not only for applications but also for large systems. Our current process worked fine if only a few people work on a user interface. But, as the user interface starts to get bigger and the number of people working on the UI layer increases, then the existing process was no longer well defined. It just doesn't scale. Ideally, CoreUI provides a pattern to scale UI development linearly without scrutinizing the implementation of UI features.","title":"What is QML Core UI"},{"location":"guide/overview/#motivation","text":"When observing Developers working on larger UIs, it is interesting to see the correlation between the development productivity and the UI complexity. Particularly, the development productivity drops as the UI complexity increases. For example, developers need to start the whole UI to navigate into a detailed view to fine-tune some UI logic or even animation. Often, this is because the UI can't be broken down into smaller, manageable chunks. In practical terms, it's about isolating a smaller portion of the UI and being able to work and validate this smaller portion. Breaking down the UI often happens on larger layers. But for UI development where the UI experience is an important factor, it's necessary to fine-tune small aspects of the UI to achieve the desired look and behavior. You have to aim for a fast (< 1s) round trip time to make the conversation seamless between Design and Development. To be able to achive this you need to be able to decompose (break down) the UI into smaller parts and being able to run these parts standalone. This will allow you to focus solely on the user experience of that particular part and allow a faster cycle of edit-build-validate. You can easily avoid this situation with Qt and QML. While QML offers a great component model, it lacks a coherent approach to componentize the UI and to implement these UI components. Looking at the current development approach it is clear that the UI's physical structure and the component types are created by following a UI specification or INformation Architecture and not from a technical perspective. For a developer, it's not clear when and how exactly to split a component into smaller parts, where to place them and to ensure a component is truly reusable as well as usable outside of its context. CoreUI is an attempt to create an architecture and process to streamline this component creation task, similar to a component factory.","title":"Motivation"},{"location":"guide/overview/#what-is-coreui","text":"CoreUI is set of patterns and components to support a common user interface structure. It encourages both developers and designers to create a great user experience by focusing on the UI creation process. The CoreUI architecture is the result of the creation and re-creation of user interface projects for various markets, especially the automotive one. After several re-creations of user interface projects for vertical markets, some patterns emerged. The CoreUI architecture as presented here is the distillation of these patterns. CoreUI is an embedded development framework using Qt5 and the QML/JS language. Programming embedded software user interfaces can often be unnecessarily complicated. CoreUI makes the programming of these user interfaces easier, by making assumptions about what every developer needs to get started to create stunning user interfaces. It allows you to develop user interfaces by writing less code but accomplishing more. CoreUI aims to bring back the fun and creativity to user interface development so that developers and designers can focus on the user experience again. CoreUI is based on the opinions of others. These opinions make assumptions about what is the best way to create user interfaces. CoreUI is meant to be used that way and discourages other ways. If you master CoreUI you'll probably experience a spike in productivity. If you keep up with your old habits and try to retrofit CoreUI with your old ways of working you may not reap CoreUI's full benefits.","title":"What is CoreUI?"},{"location":"guide/overview/#what-coreui-is-not","text":"CoreUI is partly a concrete framework but it's not an exact path; more as a guideline. Often during a project, not all of the requirements are foreseeable and it's necessary to deviate from the path suggested. CoreUI isn't an implementation of a user interface. It's also not designed for a single application, but covers a multi-application setup. CoreUI is not final :-)","title":"What CoreUI is not?"},{"location":"guide/overview/#coreui-stack","text":"CoreuI is founded on top of Qt5 and Qt Automotive Suite. Qt5 is the leading cross-platform native UI toolkit with an unprecedented focus on the user experience. It offers the developer all the necessary APIs to develop a truly native cross-platform application. Qt Automotive Suite extends Qt5, bringing multi-process application capabilities and a service framework to the table. By this, Qt Automotive Suite is extending Qt into the space of creating multi-process user interfaces for mid and high-end embedded systems. Even if Qt Automotive Suite targets primarily the automotive market, it's not limited to this market. CoreUI defines patterns and rules for the UI layer of a multi-process UI for embedded systems based on Qt Automotive Suite. A reference implementation of CoreUI is the Neptune3 UI which is delivered together with Qt Automotive Suite.","title":"CoreUI stack"},{"location":"guide/start/","text":"Getting Started All models are wrong, some of them are useful - George Box Warning The project and the architecture created by coreui-admin is only meant to be used for educational purpose. The coreui-admin tool, neither the code created by the tool is production ready. Still it is believed the code is a good starting point for creating your own production project. Prerequisite Before you can use the CoreUI architecture we need to build the QtAuto components which are not part of standard Qt5. If you have already installed a version of Qt5 and QtAuto you can skip this step. Info Be aware the QtAuto and Qt SDK have their own license restrictions. So please make sure you inform yourself before using them. We create a qtauto folder to download and build the QtAuto components. Todo this we mark the folder as a coreui folder using init. 1 2 mkdir - p tryout / qtauto && cd tryout / qtauto coreui - admin init This create a coreui.yml configuration document into this folder. To be able to build using Qt5 qmake we need to configure coreui to tell the location of the qmake binary 1 coreui - admin config qmake ~/ Qt / 5 . 13 . 0 / clang_64 / bin / qmake We can look which componens will be cloned based on which targets. 1 coreui - admin targets Will produce the following table 1 2 3 4 using workspace `~/ work / luxoft / tryout / qtauto ` ______name______ | ______________________repos______________________ auto | ivi , appman , neptune3 - ui tools | qmllive , gammaray To know more about a repo just type coreui-admin repos . The targets and repos are listed in the coreui.yml document. Feel free to edit them if required. Now we will clone the target repos using 1 coreui - admin clone auto This will clone all repos listed under the target auto into the repos/source folder. It is also possible to just clone a repo by providing the repo name. To build the source components enter the build command 1 coreui - admin build auto The build command also installs the components automatically into your provided Qt directory. If you want to first see the commands issued you can use the --dry-run option coreui-admin --dry-run build auto Note To increse the number of CPUs used you can re-configure the jobs variable 1 coreui - admin config jobs 6 Now the build will use 6 cores. If you later would like to rebuild the components but want to skip the configure parts you can append --no-config --no-pause to the build command. See --help for all the options. Create a CoreUI Project To get started with the CoreUI Architecture we will create a new project and look at the source code. 1 2 mkdir tryout && cd tryout coreui - admin new myproject This will create a new project and print instructions how to get started 1 2 3 4 5 6 7 > CONSOLE : cd myproject > CONSOLE : create . env . yml setting QTDIR : \"path/to/your/Qt/bin\" > CONSOLE : run ` coreui-admin start ` to start ui > QTCREATOR : open myproject . qmlproject and register custom executable : > QTCREATOR : Executable : \"%{Qt:QT_INSTALL_BINS}/appman\" ; Arguments : \"-r -c am-config.yaml\" > QTCREATOR : WorkingDirectory : \"%{CurrentProject:Path}\" > QTCREATOR : Register Run Environment : \"QT_QUICK_CONTROLS_CONF=./qtquickcontrols2.conf\" The instructions are two fold. The first part for using the coreui-admin to run your project and the second part for using Qt Creator to run your project. Using coreui-admin to run your ui project The instruction tells us to change the directory, make some remaining configuration and run the project 1 2 3 4 5 > CONSOLE : cd myproject > CONSOLE : create . env . yml setting QTDIR : \"path/to/your/Qt/bin\" > CONSOLE : run ` coreui - admin start ` to start ui cd myproject Create a .env.yml document which will contain your local environment variables. 1 QTDIR : ~/ Qt / 5 . 13 . 0 / clang_64 / bin Please change this, if they are wrong. Now you can start the new project using 1 coreui - admin start Note If you want to print the commands issued and not run the commands themself you can use the dry-run option at any time. 1 coreui - admin --dry-run start Using Qt Creator to run your ui project To build and run the new project using Qt Creator you need to follow the following steps 1 2 3 4 > QTCREATOR : open myproject . qmlproject and register custom executable : > QTCREATOR : Executable : \"%{Qt:QT_INSTALL_BINS}/appman\" ; Arguments : \"-r -c am-config.yaml\" > QTCREATOR : WorkingDirectory : \"%{CurrentProject:Path}\" > QTCREATOR : Register Run Environment : \"QT_QUICK_CONTROLS_CONF=./qtquickcontrols2.conf\" Change directory to ./ui and open the myproject-ui.qmlproject with Qt Creator and in the run mode change the executable to %{Qt:QT_INSTALL_BINS}/appman with the arguments -r -c am-config.yaml . This will use appman as runtime and re-creted the app database on each start as also read the configuration from the am-config.yaml . To ensure the QtQuick Controls 2 style is loaded correctly register QT_QUICK_CONTROLS_CONF environment variable with Qt Creator in the run environment to QT_QUICK_CONTROLS_CONF=./qtquickcontrols2.conf . This will lookup the configuration document from the local directory. Info CoreUI make a different between a frontend project (the UI project using QML/JS) and the backend project (the native project using C++).","title":"Getting Started"},{"location":"guide/start/#getting-started","text":"All models are wrong, some of them are useful - George Box Warning The project and the architecture created by coreui-admin is only meant to be used for educational purpose. The coreui-admin tool, neither the code created by the tool is production ready. Still it is believed the code is a good starting point for creating your own production project.","title":"Getting Started"},{"location":"guide/start/#prerequisite","text":"Before you can use the CoreUI architecture we need to build the QtAuto components which are not part of standard Qt5. If you have already installed a version of Qt5 and QtAuto you can skip this step. Info Be aware the QtAuto and Qt SDK have their own license restrictions. So please make sure you inform yourself before using them. We create a qtauto folder to download and build the QtAuto components. Todo this we mark the folder as a coreui folder using init. 1 2 mkdir - p tryout / qtauto && cd tryout / qtauto coreui - admin init This create a coreui.yml configuration document into this folder. To be able to build using Qt5 qmake we need to configure coreui to tell the location of the qmake binary 1 coreui - admin config qmake ~/ Qt / 5 . 13 . 0 / clang_64 / bin / qmake We can look which componens will be cloned based on which targets. 1 coreui - admin targets Will produce the following table 1 2 3 4 using workspace `~/ work / luxoft / tryout / qtauto ` ______name______ | ______________________repos______________________ auto | ivi , appman , neptune3 - ui tools | qmllive , gammaray To know more about a repo just type coreui-admin repos . The targets and repos are listed in the coreui.yml document. Feel free to edit them if required. Now we will clone the target repos using 1 coreui - admin clone auto This will clone all repos listed under the target auto into the repos/source folder. It is also possible to just clone a repo by providing the repo name. To build the source components enter the build command 1 coreui - admin build auto The build command also installs the components automatically into your provided Qt directory. If you want to first see the commands issued you can use the --dry-run option coreui-admin --dry-run build auto Note To increse the number of CPUs used you can re-configure the jobs variable 1 coreui - admin config jobs 6 Now the build will use 6 cores. If you later would like to rebuild the components but want to skip the configure parts you can append --no-config --no-pause to the build command. See --help for all the options.","title":"Prerequisite"},{"location":"guide/start/#create-a-coreui-project","text":"To get started with the CoreUI Architecture we will create a new project and look at the source code. 1 2 mkdir tryout && cd tryout coreui - admin new myproject This will create a new project and print instructions how to get started 1 2 3 4 5 6 7 > CONSOLE : cd myproject > CONSOLE : create . env . yml setting QTDIR : \"path/to/your/Qt/bin\" > CONSOLE : run ` coreui-admin start ` to start ui > QTCREATOR : open myproject . qmlproject and register custom executable : > QTCREATOR : Executable : \"%{Qt:QT_INSTALL_BINS}/appman\" ; Arguments : \"-r -c am-config.yaml\" > QTCREATOR : WorkingDirectory : \"%{CurrentProject:Path}\" > QTCREATOR : Register Run Environment : \"QT_QUICK_CONTROLS_CONF=./qtquickcontrols2.conf\" The instructions are two fold. The first part for using the coreui-admin to run your project and the second part for using Qt Creator to run your project.","title":"Create a CoreUI Project"},{"location":"guide/start/#using-coreui-admin-to-run-your-ui-project","text":"The instruction tells us to change the directory, make some remaining configuration and run the project 1 2 3 4 5 > CONSOLE : cd myproject > CONSOLE : create . env . yml setting QTDIR : \"path/to/your/Qt/bin\" > CONSOLE : run ` coreui - admin start ` to start ui cd myproject Create a .env.yml document which will contain your local environment variables. 1 QTDIR : ~/ Qt / 5 . 13 . 0 / clang_64 / bin Please change this, if they are wrong. Now you can start the new project using 1 coreui - admin start Note If you want to print the commands issued and not run the commands themself you can use the dry-run option at any time. 1 coreui - admin --dry-run start","title":"Using coreui-admin to run your ui project"},{"location":"guide/start/#using-qt-creator-to-run-your-ui-project","text":"To build and run the new project using Qt Creator you need to follow the following steps 1 2 3 4 > QTCREATOR : open myproject . qmlproject and register custom executable : > QTCREATOR : Executable : \"%{Qt:QT_INSTALL_BINS}/appman\" ; Arguments : \"-r -c am-config.yaml\" > QTCREATOR : WorkingDirectory : \"%{CurrentProject:Path}\" > QTCREATOR : Register Run Environment : \"QT_QUICK_CONTROLS_CONF=./qtquickcontrols2.conf\" Change directory to ./ui and open the myproject-ui.qmlproject with Qt Creator and in the run mode change the executable to %{Qt:QT_INSTALL_BINS}/appman with the arguments -r -c am-config.yaml . This will use appman as runtime and re-creted the app database on each start as also read the configuration from the am-config.yaml . To ensure the QtQuick Controls 2 style is loaded correctly register QT_QUICK_CONTROLS_CONF environment variable with Qt Creator in the run environment to QT_QUICK_CONTROLS_CONF=./qtquickcontrols2.conf . This will lookup the configuration document from the local directory. Info CoreUI make a different between a frontend project (the UI project using QML/JS) and the backend project (the native project using C++).","title":"Using Qt Creator to run your ui project"},{"location":"topics/blocks/","text":"Building Blocks \"If you think good architecture is expensive, try bad architecture.\" -- Brian Foote and Joseph Yoder Abstract Building blocks are loosely coupled concepts which when arranged in the right order they form the foundation of the CoreUI. Through the loose coupling, you can also create a different architecture. This follows the principle that CoreUI is an opinionated stack and as such reflects our best efforts. Don't expect ready-made code solutions, these are concepts. User Interface We consider the user interface as the front-facing interface towards the user, aka front-end. For the underlying system facing interface, we use the term back-end. The front-end is concerned about the visual integrity of the UI and its appeal. A special focus lies upon the dialog with the user interface design team to create a stunning user experience for the users as one. The User Interface requires to communicate with the underlying system services as well as with services outside the system (aka remote services). The user interface is responsible to render every pixel on the screen and to achieve being an emotional user interface using animations and transitions. Typically a user interface is seen as a user interface tree, where the root is the initial UI portion being loaded. It is important that the user interface has control about which portions of the UI are loaded as the UI is the only layer which has the understanding. The user interface is typically developed in QML/JavaScript and Qt/C++. Note Describe the definition of the UI and the different building blocks (e.g. SUI/AppS/UIControls) The user interface is the highest layer inside a system. It offers information and interactions to the user. It is driven by the information architecture specification and the user-interface design specification. The central screens of a user interface are typically centralized inside the system UI. These screens are used to show to the user frequently needed information but also other information and interactions to navigate deeper into the user interface. The user interface itself is often seen as a tree of user interface elements, where on the root level you have the display and the structure follows on the high level of the information architecture. There are often links between unrelated UI nodes which provide shortcuts to the user to show or retrieve certain information. The UI tree on the higher levels is also divided into UI layers to ensure the most important information is shown above other less important information. The user interface is framed by the requirements specification, the user interface specification, the UI testing, and the underlying system. For working on a particular software layer it is always important to understand and embrace the adjacent layers. Here the user interface developers work closely together with the design team that creates the user interface specification. The requirements team provides non-functional and functional requirements which need to be adherent by the UI developers. The testing team needs to have support to allow smooth planning of the user interface layer. And the system provides the foundation where the user interface can be executed (either desktop or embedded) and also provides the underlying services the user interface needs to interface with. UI Runtime A runtime is responsible to initialize the user interface library and load a minimal set of extensions that are required to load the initial UI. From then on, the UI itself will take control of the loading of other UI parts. 1 runtime --import imports Main.qml Often a runtime is made using a configuration document which can be written in JSON or a similar data-interchange format. 1 2 3 4 5 6 { \"imports\" : [ \"imports\" ], \"document\" : \"Main.qml\" } In the Qt/QML case, the default runtime is the qmlscene which is great for simple prototypes but for a more complex project you want to create a custom runtime, especially for loading your custom boot extensions. UI Extensions An extension extends the runtime with new features and capabilities on dynamically on runtime. They are delivered as a module and typically loaded on-demand from the UI code. In the Qt/QML context, the extensions are called QML plug-ins. An extension, in general, can extend the runtime horizontally with new capabilities (for example to render a new type of content) or vertically (for example to communicate with a tuner service). Loading the extensions on demand allows the execution from different code paths using different extensions. Also as the extensions are looked up using the import path you can inject a mock extension into the import path before the real extension for test purposes. Note These extensions can be either written in QML or in Qt/C++ (or mixed). Often a developer first starts to write some extensions in QML for prototyping and later those will be re-written as C++ extensions to use a browser API and achieve the best performance. System UI The UI started first is called the System UI. Think about your user interface and remove all applications, what is left is called the System UI. The System UI is responsible for booting the user interface system efficiently enough so that a minimal usable user interface, is operational by the user, is reached to be shown on the screen. The System UI is also responsible for layout application windows and to provide additional information overlays to the user. Another important point of the system UI is to act as a gateway to control and prioritize access to the display surface for dialogs and notifications. Lastly, it's responsible for displaying the application launcher that acts as a shell to launch applications. Boot the user interface until a minimal usable state is reached Layout application window surfaces Control display access for dialogs and notifications Manage user interface overlays Present a user interface to launch applications System UI Layers The System UI defines the fundamental visual layering structure of the user interface. It creates the main rendering surface and controls other applications and dialog windows. A typical System UI can be divided into several layer containers. The visual topmost layer is the dialog layer which displays notifications. The notifications are system-wide controlled allowing the system UI to decide when and how a notification shall be displayed, as another, more important, the notification may be currently displayed. Just below the dialog layer, lies the overlay layer. This layer provides additional, not primary, information to the user, enhancing the information awareness and providing shortcuts to frequently used functions such as volume, climate information, etc. Below the overlays there are the application surfaces, that is a standard way to extend the system UI using features packed into applications. An application is mostly displayed full-screen but can also have different states, for example when used as a widget to preview and/or interact with certain application information in a condensed way. The launcher finally displays all available applications. A traditional way to display the different applications is using a grid with icons and a small text containing the application name and when this is clicked to launch the respective application full-screen. Another possibility could be to use a flexible grid of application widgets which when each is clicked expands into a full-screen application. The advantage of the first approach is that the application doesn't have to be launched but only meta information is presented (like its icon and name). Below the launcher, there could be an optional background image, e.g. the desktop background. In QML code this would roughly look like this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Display.qml Item { id: root Image { id: background } Container { id: launcherLayer } Container { id: appLayer } Container { id: overlayLayer } Container { id: dialogLayer } } Stage Loading To allow the System UI to be launched in a controlled and efficient manner the typical way is to stage load the SysUI. Stage loading is a practice to dynamically load partially user interfaces using a state machine or a similar controller which is controlled by external information and/or the current state of the machine. For this reason, the UI tree represented by the System UI has to be divided into smaller parts that can be loaded independently. The partitioning is done using a standard component approach and the loading is done using the Loader type which is directed by an SCXML state machine. The state machine state changes are triggered by either external events and conditions and the overall loading state. Note For development purposes, it is also possible to shortcut some loading stages. Application An application is a set of UI screens that represent the same logical context and are rendered into the same window surface. In a multi-process system, an application is started into its own process. An application should share ideally only a small and generic API with the other horizontal components (System UI, other applications) on the same layer and use a vertical communication to interface with the system. The System UI is also seen as a special application which responsibilities are specialized in the sense that it is responsible for the early UI startup, managing application windows and displaying a UI to launch these applications as extensions to the UI. Using an application does not have to be the only way to extend or structure the user interface. A small portion of the application will interact with the system UI and window handling. These parts shall be refactored out into own components. Similar is true for application logic interacting with the underlying services. That user interface portion of the application ideally should not expose services to the UI, it should instead be wrapped into an own module bundling this application logic and empowering this way better testability. Communication There are several interfaces defined where an application can interact with the rest of the user interface. In general, it is prohibited that an application directly communicates with another application. These communications should always be routed either through the system UI or the underlying services. If the interface shall also be used by for example other displays, the information is better routed through a service. If the information is only relevant for the current display it shall be routed through the system UI. In general, we talk about horizontal communication if an application talks to the system UI and vertical communication if an application talks to a service. UI Types The user interface follows a hierarchical tree structure. Each node displays a fragment of the information or is used to structure the user interface. Some nodes inside the UI tree have a special purpose and ensure the tree has clear border lines and certain areas do not get exposed to unnecessary dependencies. Adding a dependency to a UI element makes it harder to test it or to launch it independently from the rest of the UI tree. But this should be our target to test and launch individual UI components independently from each other and thus creating an environment where adding more UI elements not necessarily slows down the process. The most prominent UI type is the component. It encapsulates a portion of the UI tree and uses other components to delegate rendering of the required information. As such it provides a higher level of abstraction ( C1 , C2 , C3 ) to a UI feature. These components form an own hierarchy within the UI tree and are used as the base for further specializing components. In general, we differentiate between UI primitives (e.g. rectangles and images) and controls (e.g. buttons) as individual UI types. To combine several UI types panels or views shall be used. These are specific container-types to layout other containers as child UI types or controls. UI primitives are only used inside controls, as the controls have support for styling the UI. The difference between a panel and a view is that the view interfaces with the stores (the business logic layer of the application) but the panel not. Services Service offers a feature to the user interface or other services. Service is located from the architectural perspective below the user interface in a separate layer. Typically a service runs on a different process belonging to the platform. The service exposes a client API which allows the client to access the service. Service is normally started by the system but often can also be started on demand when first used by the client through its API. Services are bundled into a server. A server can contain one or more services. Each service exposes an API to the clients. Typically a service interfaces with the system or external services. Ideally, a service provides the data in a way that clients can easily consume them efficiently. The generic APIs will increase the work needed on the client side to gather all relevant data for a UI view. Services shall be constructed as micro-services and should not directly depend on other services or services APIs. If there are needs for some dependencies between services it is better to use some form of an ID (e.g. a text identifier) to identify the referenced information on the other service. It is then up to the service implementation to resolve the reference. Jobs A job is a long-running piece of work which may return some results. A job execution length is long enough to disturb the UI from rendering. Typically this computing is done on a service in a different process but this is not always possible or desirable. To run a job on the UI process it needs to run inside a thread pool and the result needs to be reported back. In QtC++ the easiest way of doing this would be the QRunnable in conjunction with the QThreadPool. In QML this would be the WorkerScript to execute a long-running JS script. Single / Multi Process In a single-process architecture, all UI code is executed inside a single process. This makes the initial coding and architecture much simpler. A single process architecture lacks separation of concerns. All UI code can access all other UI code API surface and by this depend on each other. This can easily create dirty code when no experienced developers take part in a project. Also, the security means are nonexistent in a single process UI in comparison to a multi-process one. A multi-process UI separates concerns into separate processes and uses the security system of the OS to isolate these processes. An application developer has no means of playing around with the system UI memory apart from the APIs offered to him. This allows for much better scaling of application development efforts as independent teams can work on independent code spots which are separated by process boundaries. Ideally, one team would work on the system UI process and the interface for applications whereas others would work on the applications themselves. The CoreUI architecture is designed to support a single and multi-process architecture. The main difference between these two setups is the separation of applications into different processes. Debugging Qt debugging is described at https://doc.qt.io/qt-5.10/debug.html and QML debugging is described here: http://doc.qt.io/qt-5/qtquick-debugging.html . This section is more about visual UI debugging techniques. As the UI is composed of larger building blocks which the CoreUI Architecture forces to be of a specific type we can add debugging instruments into these blocks. For example, to visually trace views and panels the base classes can render their outline and by this allow a developer to validate its layout. Testing CoreUI forces the developer to extract all business logic into stores. These stores are pure data elements and thus can be nicely tested. The UI shall be concerned only about the UI logic and not the business logic. Further CoreUI cuts the UI into smaller logical pieces called controls, panels, views where each of them has a defined dependency and such it is fairly easy to create a test harness for each of these UI elements. Testing is an integral part of CoreUI. There are dedicated folders with test runners in QML and C++ to ensure your tests are bundled with the code. Inspection Inspection appears when a running UI is inspected live. As a user, you get live insights from the running execution by using a console interface (for QML/JS) or via a visual interface (e.g. visualize the UI hierarchy, component boundaries, z-ordering), or through event reporting where events are logged more or less visually (e.g. events, signals). But also you want to inspect the communication the UI holds horizontally and vertically with the services. Inspection can be either embedded into the process (e.g. into the runtime) or can be attached to a running process. The first case is great for deployment as the runtime is already enabled with the inspection UI but it might have an impact on the runtime performance. The other option is to launch an independent inspector tool (e.g. GammaRay <https://www.kdab.com/development-resources/qt-tools/gammaray/> ) and attach it to the running executable. This inspector tool comes with a dedicated user interface to help you understand the UI execution flow but also being able to manipulate certain values. Package Manager A package manager allows the user or the system to install a binary package. There are two different package types: application and system packages. The application package is used to install and remove an application. It is designed to be easy to use and to bundle all dependencies into the application package. It relies on a refined version of the platform. The system package is a bundle which also contains dependency information and may even run some initialization scripts. The number of features depends on the package system used. This allows a system builder to build a new version of the system and ensure all dependent packages will be also installed. The application package is designed to be self-contained, for security and stability issues. It is not allowed that an application package modifies the system, by e.g. installing a depending service or a new version of a library. Allowing this could lead to an unstable system. It should be noted that it is possible to wrap an application package into a system package. The system package installer would then run the application package manager to install the bundled application. Normally this does not work in reverse: An application package to bundle a system package.","title":"Building Blocks"},{"location":"topics/blocks/#building-blocks","text":"\"If you think good architecture is expensive, try bad architecture.\" -- Brian Foote and Joseph Yoder Abstract Building blocks are loosely coupled concepts which when arranged in the right order they form the foundation of the CoreUI. Through the loose coupling, you can also create a different architecture. This follows the principle that CoreUI is an opinionated stack and as such reflects our best efforts. Don't expect ready-made code solutions, these are concepts.","title":"Building Blocks"},{"location":"topics/blocks/#user-interface","text":"We consider the user interface as the front-facing interface towards the user, aka front-end. For the underlying system facing interface, we use the term back-end. The front-end is concerned about the visual integrity of the UI and its appeal. A special focus lies upon the dialog with the user interface design team to create a stunning user experience for the users as one. The User Interface requires to communicate with the underlying system services as well as with services outside the system (aka remote services). The user interface is responsible to render every pixel on the screen and to achieve being an emotional user interface using animations and transitions. Typically a user interface is seen as a user interface tree, where the root is the initial UI portion being loaded. It is important that the user interface has control about which portions of the UI are loaded as the UI is the only layer which has the understanding. The user interface is typically developed in QML/JavaScript and Qt/C++. Note Describe the definition of the UI and the different building blocks (e.g. SUI/AppS/UIControls) The user interface is the highest layer inside a system. It offers information and interactions to the user. It is driven by the information architecture specification and the user-interface design specification. The central screens of a user interface are typically centralized inside the system UI. These screens are used to show to the user frequently needed information but also other information and interactions to navigate deeper into the user interface. The user interface itself is often seen as a tree of user interface elements, where on the root level you have the display and the structure follows on the high level of the information architecture. There are often links between unrelated UI nodes which provide shortcuts to the user to show or retrieve certain information. The UI tree on the higher levels is also divided into UI layers to ensure the most important information is shown above other less important information. The user interface is framed by the requirements specification, the user interface specification, the UI testing, and the underlying system. For working on a particular software layer it is always important to understand and embrace the adjacent layers. Here the user interface developers work closely together with the design team that creates the user interface specification. The requirements team provides non-functional and functional requirements which need to be adherent by the UI developers. The testing team needs to have support to allow smooth planning of the user interface layer. And the system provides the foundation where the user interface can be executed (either desktop or embedded) and also provides the underlying services the user interface needs to interface with.","title":"User Interface"},{"location":"topics/blocks/#ui-runtime","text":"A runtime is responsible to initialize the user interface library and load a minimal set of extensions that are required to load the initial UI. From then on, the UI itself will take control of the loading of other UI parts. 1 runtime --import imports Main.qml Often a runtime is made using a configuration document which can be written in JSON or a similar data-interchange format. 1 2 3 4 5 6 { \"imports\" : [ \"imports\" ], \"document\" : \"Main.qml\" } In the Qt/QML case, the default runtime is the qmlscene which is great for simple prototypes but for a more complex project you want to create a custom runtime, especially for loading your custom boot extensions.","title":"UI Runtime"},{"location":"topics/blocks/#ui-extensions","text":"An extension extends the runtime with new features and capabilities on dynamically on runtime. They are delivered as a module and typically loaded on-demand from the UI code. In the Qt/QML context, the extensions are called QML plug-ins. An extension, in general, can extend the runtime horizontally with new capabilities (for example to render a new type of content) or vertically (for example to communicate with a tuner service). Loading the extensions on demand allows the execution from different code paths using different extensions. Also as the extensions are looked up using the import path you can inject a mock extension into the import path before the real extension for test purposes. Note These extensions can be either written in QML or in Qt/C++ (or mixed). Often a developer first starts to write some extensions in QML for prototyping and later those will be re-written as C++ extensions to use a browser API and achieve the best performance.","title":"UI Extensions"},{"location":"topics/blocks/#system-ui","text":"The UI started first is called the System UI. Think about your user interface and remove all applications, what is left is called the System UI. The System UI is responsible for booting the user interface system efficiently enough so that a minimal usable user interface, is operational by the user, is reached to be shown on the screen. The System UI is also responsible for layout application windows and to provide additional information overlays to the user. Another important point of the system UI is to act as a gateway to control and prioritize access to the display surface for dialogs and notifications. Lastly, it's responsible for displaying the application launcher that acts as a shell to launch applications. Boot the user interface until a minimal usable state is reached Layout application window surfaces Control display access for dialogs and notifications Manage user interface overlays Present a user interface to launch applications","title":"System UI"},{"location":"topics/blocks/#system-ui-layers","text":"The System UI defines the fundamental visual layering structure of the user interface. It creates the main rendering surface and controls other applications and dialog windows. A typical System UI can be divided into several layer containers. The visual topmost layer is the dialog layer which displays notifications. The notifications are system-wide controlled allowing the system UI to decide when and how a notification shall be displayed, as another, more important, the notification may be currently displayed. Just below the dialog layer, lies the overlay layer. This layer provides additional, not primary, information to the user, enhancing the information awareness and providing shortcuts to frequently used functions such as volume, climate information, etc. Below the overlays there are the application surfaces, that is a standard way to extend the system UI using features packed into applications. An application is mostly displayed full-screen but can also have different states, for example when used as a widget to preview and/or interact with certain application information in a condensed way. The launcher finally displays all available applications. A traditional way to display the different applications is using a grid with icons and a small text containing the application name and when this is clicked to launch the respective application full-screen. Another possibility could be to use a flexible grid of application widgets which when each is clicked expands into a full-screen application. The advantage of the first approach is that the application doesn't have to be launched but only meta information is presented (like its icon and name). Below the launcher, there could be an optional background image, e.g. the desktop background. In QML code this would roughly look like this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Display.qml Item { id: root Image { id: background } Container { id: launcherLayer } Container { id: appLayer } Container { id: overlayLayer } Container { id: dialogLayer } }","title":"System UI Layers"},{"location":"topics/blocks/#stage-loading","text":"To allow the System UI to be launched in a controlled and efficient manner the typical way is to stage load the SysUI. Stage loading is a practice to dynamically load partially user interfaces using a state machine or a similar controller which is controlled by external information and/or the current state of the machine. For this reason, the UI tree represented by the System UI has to be divided into smaller parts that can be loaded independently. The partitioning is done using a standard component approach and the loading is done using the Loader type which is directed by an SCXML state machine. The state machine state changes are triggered by either external events and conditions and the overall loading state. Note For development purposes, it is also possible to shortcut some loading stages.","title":"Stage Loading"},{"location":"topics/blocks/#application","text":"An application is a set of UI screens that represent the same logical context and are rendered into the same window surface. In a multi-process system, an application is started into its own process. An application should share ideally only a small and generic API with the other horizontal components (System UI, other applications) on the same layer and use a vertical communication to interface with the system. The System UI is also seen as a special application which responsibilities are specialized in the sense that it is responsible for the early UI startup, managing application windows and displaying a UI to launch these applications as extensions to the UI. Using an application does not have to be the only way to extend or structure the user interface. A small portion of the application will interact with the system UI and window handling. These parts shall be refactored out into own components. Similar is true for application logic interacting with the underlying services. That user interface portion of the application ideally should not expose services to the UI, it should instead be wrapped into an own module bundling this application logic and empowering this way better testability.","title":"Application"},{"location":"topics/blocks/#communication","text":"There are several interfaces defined where an application can interact with the rest of the user interface. In general, it is prohibited that an application directly communicates with another application. These communications should always be routed either through the system UI or the underlying services. If the interface shall also be used by for example other displays, the information is better routed through a service. If the information is only relevant for the current display it shall be routed through the system UI. In general, we talk about horizontal communication if an application talks to the system UI and vertical communication if an application talks to a service.","title":"Communication"},{"location":"topics/blocks/#ui-types","text":"The user interface follows a hierarchical tree structure. Each node displays a fragment of the information or is used to structure the user interface. Some nodes inside the UI tree have a special purpose and ensure the tree has clear border lines and certain areas do not get exposed to unnecessary dependencies. Adding a dependency to a UI element makes it harder to test it or to launch it independently from the rest of the UI tree. But this should be our target to test and launch individual UI components independently from each other and thus creating an environment where adding more UI elements not necessarily slows down the process. The most prominent UI type is the component. It encapsulates a portion of the UI tree and uses other components to delegate rendering of the required information. As such it provides a higher level of abstraction ( C1 , C2 , C3 ) to a UI feature. These components form an own hierarchy within the UI tree and are used as the base for further specializing components. In general, we differentiate between UI primitives (e.g. rectangles and images) and controls (e.g. buttons) as individual UI types. To combine several UI types panels or views shall be used. These are specific container-types to layout other containers as child UI types or controls. UI primitives are only used inside controls, as the controls have support for styling the UI. The difference between a panel and a view is that the view interfaces with the stores (the business logic layer of the application) but the panel not.","title":"UI Types"},{"location":"topics/blocks/#services","text":"Service offers a feature to the user interface or other services. Service is located from the architectural perspective below the user interface in a separate layer. Typically a service runs on a different process belonging to the platform. The service exposes a client API which allows the client to access the service. Service is normally started by the system but often can also be started on demand when first used by the client through its API. Services are bundled into a server. A server can contain one or more services. Each service exposes an API to the clients. Typically a service interfaces with the system or external services. Ideally, a service provides the data in a way that clients can easily consume them efficiently. The generic APIs will increase the work needed on the client side to gather all relevant data for a UI view. Services shall be constructed as micro-services and should not directly depend on other services or services APIs. If there are needs for some dependencies between services it is better to use some form of an ID (e.g. a text identifier) to identify the referenced information on the other service. It is then up to the service implementation to resolve the reference.","title":"Services"},{"location":"topics/blocks/#jobs","text":"A job is a long-running piece of work which may return some results. A job execution length is long enough to disturb the UI from rendering. Typically this computing is done on a service in a different process but this is not always possible or desirable. To run a job on the UI process it needs to run inside a thread pool and the result needs to be reported back. In QtC++ the easiest way of doing this would be the QRunnable in conjunction with the QThreadPool. In QML this would be the WorkerScript to execute a long-running JS script.","title":"Jobs"},{"location":"topics/blocks/#single-multi-process","text":"In a single-process architecture, all UI code is executed inside a single process. This makes the initial coding and architecture much simpler. A single process architecture lacks separation of concerns. All UI code can access all other UI code API surface and by this depend on each other. This can easily create dirty code when no experienced developers take part in a project. Also, the security means are nonexistent in a single process UI in comparison to a multi-process one. A multi-process UI separates concerns into separate processes and uses the security system of the OS to isolate these processes. An application developer has no means of playing around with the system UI memory apart from the APIs offered to him. This allows for much better scaling of application development efforts as independent teams can work on independent code spots which are separated by process boundaries. Ideally, one team would work on the system UI process and the interface for applications whereas others would work on the applications themselves. The CoreUI architecture is designed to support a single and multi-process architecture. The main difference between these two setups is the separation of applications into different processes.","title":"Single / Multi Process"},{"location":"topics/blocks/#debugging","text":"Qt debugging is described at https://doc.qt.io/qt-5.10/debug.html and QML debugging is described here: http://doc.qt.io/qt-5/qtquick-debugging.html . This section is more about visual UI debugging techniques. As the UI is composed of larger building blocks which the CoreUI Architecture forces to be of a specific type we can add debugging instruments into these blocks. For example, to visually trace views and panels the base classes can render their outline and by this allow a developer to validate its layout.","title":"Debugging"},{"location":"topics/blocks/#testing","text":"CoreUI forces the developer to extract all business logic into stores. These stores are pure data elements and thus can be nicely tested. The UI shall be concerned only about the UI logic and not the business logic. Further CoreUI cuts the UI into smaller logical pieces called controls, panels, views where each of them has a defined dependency and such it is fairly easy to create a test harness for each of these UI elements. Testing is an integral part of CoreUI. There are dedicated folders with test runners in QML and C++ to ensure your tests are bundled with the code.","title":"Testing"},{"location":"topics/blocks/#inspection","text":"Inspection appears when a running UI is inspected live. As a user, you get live insights from the running execution by using a console interface (for QML/JS) or via a visual interface (e.g. visualize the UI hierarchy, component boundaries, z-ordering), or through event reporting where events are logged more or less visually (e.g. events, signals). But also you want to inspect the communication the UI holds horizontally and vertically with the services. Inspection can be either embedded into the process (e.g. into the runtime) or can be attached to a running process. The first case is great for deployment as the runtime is already enabled with the inspection UI but it might have an impact on the runtime performance. The other option is to launch an independent inspector tool (e.g. GammaRay <https://www.kdab.com/development-resources/qt-tools/gammaray/> ) and attach it to the running executable. This inspector tool comes with a dedicated user interface to help you understand the UI execution flow but also being able to manipulate certain values.","title":"Inspection"},{"location":"topics/blocks/#package-manager","text":"A package manager allows the user or the system to install a binary package. There are two different package types: application and system packages. The application package is used to install and remove an application. It is designed to be easy to use and to bundle all dependencies into the application package. It relies on a refined version of the platform. The system package is a bundle which also contains dependency information and may even run some initialization scripts. The number of features depends on the package system used. This allows a system builder to build a new version of the system and ensure all dependent packages will be also installed. The application package is designed to be self-contained, for security and stability issues. It is not allowed that an application package modifies the system, by e.g. installing a depending service or a new version of a library. Allowing this could lead to an unstable system. It should be noted that it is possible to wrap an application package into a system package. The system package installer would then run the application package manager to install the bundled application. Normally this does not work in reverse: An application package to bundle a system package.","title":"Package Manager"},{"location":"topics/controls/","text":"Common Controls Info This material is work in progress and will change! Common Controls are shared controls between the applications. They form semantic user interfaces. Often they are built out of UI primitives such as rectangles, mouse areas, images, etc. and expose a defined high-level API. These controls are designed after the user interface specification and especially they follow the UI style guide as a central guide that defines the visual appearance. Controls are tightly bound to styles as the style defines the visual appearance of a control. It is often desirable to separate the logic of a control from the visual appearance and ideally make the appearance pluggable. This can be reached by thinking about a control as a template for a real control. This template contains only the common logic of a control and can even be coded in C++ for optimization. The visual appearance would then be added when a concrete control is defined. To know which concrete control needs to be used, the framework contains a logic to use a different control based on the style setting. This acts very much like a factory class where the object creation is separated from the object creation request. The framework takes care about ensuring the correct concrete control is created. This is the pattern used in the QtQuick.Controls V2 ( https://doc.qt.io/qt-5.10/qtquickcontrols2-index.html ) controls library. It forms a common set of controls which is used typically in modern touch-based user interfaces without coupling them to the style. The library comes with a common set of styles to get started and allows a team to define fully its own style. On a high level, this is done by having the template classes implement the control logic and a style adding the geometry and appearance of background and content to the control ( https://doc.qt.io/qt-5.10/qtquickcontrols2-customize.html ). It is also possible to create completely new controls but often this is not required and a new control can often be formed by either styling or aggregating two or more controls to a new control. Note As long as a control behaves like an existing control template (e.g. a button is clicked) the visual appearance can be adjusted. Typical Controls These are the controls currently supported by QtQuick Controls 2. This should be used as a short overview of the available controls and to form a vocabulary with the design team. Control - Control is the base type of user interface controls. Buttons Controls AbstractButton - Abstract base type providing functionality common to buttons Button - Push-button that can be clicked to perform a command or to answer a question CheckBox - Check button that can be toggled on or off DelayButton - Check button that triggers when held down long enough RadioButton - Exclusive radio button that can be toggled on or off RoundButton - A push-button control with rounded corners that can be clicked by the user Switch - Button that can be toggled on or off ToolButton - Button with a look suitable for a ToolBar Container Controls ApplicationWindow - Styled top-level window with support for a header and footer Container - Abstract base type providing functionality common to containers Frame - Visual frame for a logical group of controls GroupBox - Visual frame and title for a logical group of controls Page - Styled page control with support for a header and footer Pane - Provides a background matching with the application style and theme ScrollView - Scrollable view StackView - Provides a stack-based navigation model SwipeView - Enables the user to navigate pages by swiping sideways TabBar - Allows the user to switch between different views or subtasks ToolBar - Container for context-sensitive controls Delegate Controls ItemDelegate - Presents a checkable control that can be pressed and clicked by the user. CheckDelegate - Item delegate with a check indicator that can be toggled on or off RadioDelegate - Exclusive item delegate with a radio indicator that can be toggled on or off SwipeDelegate - Swipeable item delegate SwitchDelegate - Item delegate with a switch indicator that can be toggled on or off Indicator Controls BusyIndicator - Indicates background activity, for example, while content is being loaded PageIndicator - Indicates the currently active page ProgressBar - Indicates the progress of an operation ScrollBar - Vertical or horizontal interactive scroll bar ScrollIndicator - Vertical or horizontal non-interactive scroll indicator Input Controls ComboBox - Combined button and popup list for selecting options Dial - Circular dial that is rotated to set a value RangeSlider - Used to select a range of values by sliding two handles along a track Slider - Used to select a value by sliding a handle along a track TextArea - Multi-line text input area TextField - Single-line text input field Tumbler - Spinnable wheel of items that can be selected Menu Controls Menu - Popup that can be used as a context menu or popup menu MenuBar - Provides a window menu bar MenuBarItem - Presents a drop-down menu within a MenuBar MenuItem - Presents an item within a Menu Navigation Controls Drawer - Side panel that can be opened and closed using a swipe gesture StackView - Provides a stack-based navigation model SwipeView - Enables the user to navigate pages by swiping sideways TabBar - Allows the user to switch between different views or subtasks TabButton - Button with a look suitable for a TabBar Popup Controls Dialog - Popup dialog with standard buttons and a title, used for short-term interaction with the user Drawer - Side panel that can be opened and closed using a swipe gesture Menu - Popup that can be used as a context menu or popup menu Popup - a Base type of popup-like user interface controls ToolTip - Provides tooltips for any control Separator Controls MenuSeparator - Separates a group of items in a menu from adjacent items ToolSeparator - Separates a group of items in a toolbar from adjacent items Laying out Controls Laying out controls is the process of positioning controls on a panel and deciding on their growth policy. Either the control shall expand when the parent is resized or not. If an item is not intended to grow positioners can do the work, otherwise layouts are always preferred. To support layout mirroring the LayoutMirroring attached property is available. Positioners Container items that manage the positions of items. Grid - Positions its children in grid formation Row - Positions its children in a row Column - Positions its children in a column Flow - Positions its children side by side, wrapping as necessary Layouts Used to arrange items in a user interface. RowLayout - Identical to GridLayout, but having only one row. ColumnLayout - Identical to GridLayout, but having only one column. GridLayout - Provides a way of dynamically arranging items in a grid. StackLayout - Provides a stack of items where only one item is visible at a time The behavior of the items inside a layout can be influenced using the [Layout ` attached property. Common vs. Application Controls Common controls are shared between all applications and are designed to work in these different contexts. An application control is private to an application. Often an application control is derived from the need of the UI specification for a very special visual appearance. This could be for example a slider to change the radio frequency. This control would be very specific to a radio application and normally not required by other applications. As such it would be defined inside the application and not in a common control library. Besides this difference in physical location, the creation process is the same.","title":"Controls"},{"location":"topics/controls/#common-controls","text":"Info This material is work in progress and will change! Common Controls are shared controls between the applications. They form semantic user interfaces. Often they are built out of UI primitives such as rectangles, mouse areas, images, etc. and expose a defined high-level API. These controls are designed after the user interface specification and especially they follow the UI style guide as a central guide that defines the visual appearance. Controls are tightly bound to styles as the style defines the visual appearance of a control. It is often desirable to separate the logic of a control from the visual appearance and ideally make the appearance pluggable. This can be reached by thinking about a control as a template for a real control. This template contains only the common logic of a control and can even be coded in C++ for optimization. The visual appearance would then be added when a concrete control is defined. To know which concrete control needs to be used, the framework contains a logic to use a different control based on the style setting. This acts very much like a factory class where the object creation is separated from the object creation request. The framework takes care about ensuring the correct concrete control is created. This is the pattern used in the QtQuick.Controls V2 ( https://doc.qt.io/qt-5.10/qtquickcontrols2-index.html ) controls library. It forms a common set of controls which is used typically in modern touch-based user interfaces without coupling them to the style. The library comes with a common set of styles to get started and allows a team to define fully its own style. On a high level, this is done by having the template classes implement the control logic and a style adding the geometry and appearance of background and content to the control ( https://doc.qt.io/qt-5.10/qtquickcontrols2-customize.html ). It is also possible to create completely new controls but often this is not required and a new control can often be formed by either styling or aggregating two or more controls to a new control. Note As long as a control behaves like an existing control template (e.g. a button is clicked) the visual appearance can be adjusted.","title":"Common Controls"},{"location":"topics/controls/#typical-controls","text":"These are the controls currently supported by QtQuick Controls 2. This should be used as a short overview of the available controls and to form a vocabulary with the design team. Control - Control is the base type of user interface controls.","title":"Typical Controls"},{"location":"topics/controls/#buttons-controls","text":"AbstractButton - Abstract base type providing functionality common to buttons Button - Push-button that can be clicked to perform a command or to answer a question CheckBox - Check button that can be toggled on or off DelayButton - Check button that triggers when held down long enough RadioButton - Exclusive radio button that can be toggled on or off RoundButton - A push-button control with rounded corners that can be clicked by the user Switch - Button that can be toggled on or off ToolButton - Button with a look suitable for a ToolBar","title":"Buttons Controls"},{"location":"topics/controls/#container-controls","text":"ApplicationWindow - Styled top-level window with support for a header and footer Container - Abstract base type providing functionality common to containers Frame - Visual frame for a logical group of controls GroupBox - Visual frame and title for a logical group of controls Page - Styled page control with support for a header and footer Pane - Provides a background matching with the application style and theme ScrollView - Scrollable view StackView - Provides a stack-based navigation model SwipeView - Enables the user to navigate pages by swiping sideways TabBar - Allows the user to switch between different views or subtasks ToolBar - Container for context-sensitive controls","title":"Container Controls"},{"location":"topics/controls/#delegate-controls","text":"ItemDelegate - Presents a checkable control that can be pressed and clicked by the user. CheckDelegate - Item delegate with a check indicator that can be toggled on or off RadioDelegate - Exclusive item delegate with a radio indicator that can be toggled on or off SwipeDelegate - Swipeable item delegate SwitchDelegate - Item delegate with a switch indicator that can be toggled on or off","title":"Delegate Controls"},{"location":"topics/controls/#indicator-controls","text":"BusyIndicator - Indicates background activity, for example, while content is being loaded PageIndicator - Indicates the currently active page ProgressBar - Indicates the progress of an operation ScrollBar - Vertical or horizontal interactive scroll bar ScrollIndicator - Vertical or horizontal non-interactive scroll indicator","title":"Indicator Controls"},{"location":"topics/controls/#input-controls","text":"ComboBox - Combined button and popup list for selecting options Dial - Circular dial that is rotated to set a value RangeSlider - Used to select a range of values by sliding two handles along a track Slider - Used to select a value by sliding a handle along a track TextArea - Multi-line text input area TextField - Single-line text input field Tumbler - Spinnable wheel of items that can be selected","title":"Input Controls"},{"location":"topics/controls/#menu-controls","text":"Menu - Popup that can be used as a context menu or popup menu MenuBar - Provides a window menu bar MenuBarItem - Presents a drop-down menu within a MenuBar MenuItem - Presents an item within a Menu","title":"Menu Controls"},{"location":"topics/controls/#navigation-controls","text":"Drawer - Side panel that can be opened and closed using a swipe gesture StackView - Provides a stack-based navigation model SwipeView - Enables the user to navigate pages by swiping sideways TabBar - Allows the user to switch between different views or subtasks TabButton - Button with a look suitable for a TabBar","title":"Navigation Controls"},{"location":"topics/controls/#popup-controls","text":"Dialog - Popup dialog with standard buttons and a title, used for short-term interaction with the user Drawer - Side panel that can be opened and closed using a swipe gesture Menu - Popup that can be used as a context menu or popup menu Popup - a Base type of popup-like user interface controls ToolTip - Provides tooltips for any control","title":"Popup Controls"},{"location":"topics/controls/#separator-controls","text":"MenuSeparator - Separates a group of items in a menu from adjacent items ToolSeparator - Separates a group of items in a toolbar from adjacent items","title":"Separator Controls"},{"location":"topics/controls/#laying-out-controls","text":"Laying out controls is the process of positioning controls on a panel and deciding on their growth policy. Either the control shall expand when the parent is resized or not. If an item is not intended to grow positioners can do the work, otherwise layouts are always preferred. To support layout mirroring the LayoutMirroring attached property is available.","title":"Laying out Controls"},{"location":"topics/controls/#positioners","text":"Container items that manage the positions of items. Grid - Positions its children in grid formation Row - Positions its children in a row Column - Positions its children in a column Flow - Positions its children side by side, wrapping as necessary","title":"Positioners"},{"location":"topics/controls/#layouts","text":"Used to arrange items in a user interface. RowLayout - Identical to GridLayout, but having only one row. ColumnLayout - Identical to GridLayout, but having only one column. GridLayout - Provides a way of dynamically arranging items in a grid. StackLayout - Provides a stack of items where only one item is visible at a time The behavior of the items inside a layout can be influenced using the [Layout ` attached property.","title":"Layouts"},{"location":"topics/controls/#common-vs-application-controls","text":"Common controls are shared between all applications and are designed to work in these different contexts. An application control is private to an application. Often an application control is derived from the need of the UI specification for a very special visual appearance. This could be for example a slider to change the radio frequency. This control would be very specific to a radio application and normally not required by other applications. As such it would be defined inside the application and not in a common control library. Besides this difference in physical location, the creation process is the same.","title":"Common vs. Application Controls"},{"location":"topics/data/","text":"Exposing Data to QML A clever person solves a problem. A wise person avoids it. -- Einstein Info This chapter will show you how to expose the different ways of exposing data to the user interface layer and tries to develop a strategy to streamline the data exposure. We will shortly discuss the pros and cons of each strategy and later define a strategy which can scale. Exposing Data Qt offers you several ways to inject data into the user interface presented by QML. QML comes with native support for JSON data using the JavaScript JSON.parse and JSON.stringify methods. As a transport you can use HTTP via the XMLHTTRequest or for web-sockets using the WebSocket library. Here is a list of references: https://doc.qt.io/qt-5/qtqml-xmlhttprequest-example.html https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON https://doc.qt.io/qt-5/qml-qtwebsockets-websocket.html The other option is to capture the data on the native C++ side expose it to QML using qmlRegisterType and properties, slots and signals. For this the Qt C++ data types need to be transformed to QML supported data types. The process of registering C++ data types and the conversion are discussed in the Qt documentation at several places. Here is a longer list of relevant sections. QtQml Overview - QML and C++ Integration Integrating QML and C++ Exposing Attributes of C++ Types to QML Defining QML Types from C++ Embedding C++ Objects into QML with Context Properties Interacting with QML Objects from C++ Data Type Conversion Between QML and C++ Writing QML Extensions with C++ Creating C++ Plugins for QML Important C++ Classes Provided By The Qt QML Module QtQuick Qt Quick C++ Classes C++ Extension Points Provided By Qt Quick QtQuick.Controls 2 Qt Quick Controls C++ Classes JSON or C++ JSON is a great data format when you interact with HTTP REST endpoints or other cloud based services which are JSON based. When using Qt C++ you would need to rely on QNetworkAccessManager and QJSonDocument to consume such kind of services. There are 3rd party libraries which makes it easier to consume a HTTP REST endpoint on the QML side for example duperagent ( https://github.com/Cutehacks/duperagent ). When trying to expose JSON directly to the QML side using QtC++ it might be better to just expose the QByteArray to QML and let JavaScript to convert it to a JSON data type using JSON.parse . In pure QML you would have to use the XmlHttpRequest and convert the incoming data into JSON. This is pretty low level when coming from the web development and are used to other libraries like axios. From the C++ side you would use the QNetworkAccessManager and request a HTTP endpoint and convert the data into JSON using QJsonDocument . From there you normally convert it further to a QML supported types or other data structures to expose it to QML or using C++ native data types. If your data comes from another native source using a binary protocol you often have to write an adapter layer to convert the data types from standard C++ to Qt C++ and then you can directly expose this data to QML using Qt offered data conversions. Mechanics of Exposure When you have the data as Qt C++ native types, you want to expose it to QML. But how best to approach this? We can see data as a structured tree which starts either with an object or an array. JSON demonstrated very nicely that all data can be reduced to simple data structures or primitive type and object or arrays. Same can be applied to Qt data. But data is not everything we want to expose, we also want to expose behavior in the form of operations on the data as also signals as notifications about changes. Additional Qt provides reactive programming, where an API consumer gets notified when a property has changed and which leads to data binding. It is only possible to bind to properties, not to operations or signals. On signals you can connect using a handler, which is just another form of callback. Operations might trigger property changes through the procedure or writing to a property will also trigger a property change. Besides these structures there is also the item model type in Qt. Which is a protocol to expose data arrays efficient to a view which expects a model. Demo for Discussions To demonstrate the capabilities and possible issues we will develop a small configuration loader for a task list with a timer attached. The idea is you work on a task for x minutes, make a break and then continue to work on anther task. After some work unites you make a longer break. The configuration is stored in a JSON document and looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 { \"color\" : \"#FF0000\" , \"tasks\" : [ { \"text\" : \"task-1\" , \"done\" : false }, { \"text\" : \"task-2\" , \"done\" : false }, { \"text\" : \"task-3\" , \"done\" : true } ], \"timing\" : { \"work\" : 25 , \"short-break\" : 5 , \"long-break\" : 15 } } In the UI we would like to display the configuration and modify it. For example we would like to: change the color to another random color add new tasks to the task list clear out all done tasks mark task to be done update a task text change the individual timing settings As we need to use this information in different places we would like to get informed when any of these data fields change. Task Manager API The data could come from a network service using HTTP or we could read it from a NOSQL DB, or simple from a JSON file. Using a JSON file is the simplest way. We would read the text document and use QJSonDocument to convert it into a QJsonObject and form there into a QVariantMap. From there on we have two options, either expose the whole document as a great QVariantMap or expose individual properties as a QVariant related type. Exposing the whole document: 1 2 3 4 5 6 class TodoManager : public QObject { Q_OBJECT Q_PROPERTY ( QVariantMap document READ document WRITE setDocument NOTIFY documentChanged ) ... } Or exposing the individual properties 1 2 3 4 5 6 class TodoManager : public QObject { Q_OBJECT Q_PROPERTY ( QColor color READ color WRITE setColor NOTIFY colorChanged ) Q_PROPERTY ( QVariantList tasks READ tasks WRITE setTasks NOTIFY tasksChanged ) Q_PROPERTY ( QVariantMap timing READ timing WRITE setTiming NOTIFY timingChanged ) Now we can get and set the data. Almost done. C++ Data Sources If we would have C++ native data structures we would first write an adapter, before we can expose the data to Qt C++. The adapter could look like this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 struct Task { QString text bool done } struct Timing { int work ; int shortBreak ; int longBreak ; } class TodoEngine : public QObject { Q_OBJECT public : TodoEngine ( QObject * parent = nullptr ); QColor color (); void setColor ( QColor color ); QList < Task > tasks (); void appendTask ( Task task ); void clearTasks (); Timing timing (); void setTimming ( Timing t ); signals : void dataChanged (); private : }; This engine is using an C++ internal task implementation which is need to be adapted to be easy consumable for Qt. This engine API is not directly exposed to QML, we need to wrap it another time to ensure we provide a great experience. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class TimingGroupedProperty : public QObject { Q_OBJECT Q_PROPERTY ( int work READ work WRITE setWork NOTIFY workChanged ) Q_PROPERTY ( int shortBreak READ shortBreak WRITE setShortBreak NOTIFY workChanged ) Q_PROPERTY ( int longBreak READ longBreak WRITE setLongBreak NOTIFY longBreakChanged ) ... } class TodoManager : public QObject { Q_OBJECT Q_PROPERTY ( QColor color READ color WRITE setColor notify colorChanged ) Q_PROPERTY ( QVariantList task READ tasks WRITE setTasks notify tasksChanged ) Q_PROPERTY ( TimingGroupedProperty * timing READ timing CONSTANT ) ... } To make the list even better consumable we could introduce a model. 1 2 3 4 5 6 7 8 9 10 11 class TaskModel : public QAbstractItemListModel { ... }; class TodoManager : public QObject { Q_OBJECT Q_PROPERTY ( QColor color READ color WRITE setColor notify colorChanged ) Q_PROPERTY ( TaskModel * tasks READ tasks CONSTANT ) Q_PROPERTY ( TimingGroupedProperty * timing READ timing CONSTANT ) ... } The model could be editable by implementing setData and we would be able to assign values from inside QML. Now we should assume the API is perfect and can be used by the QML frontend developers. Using an API We should now remember about our use cases and see how a frontend developer would use our API. change the color to another random color add new tasks from the task list clear out all done tasks mark task to be done update a task text change the individual timing settings So lets see how the frontend developer would use the API. For this we can assume a simple UI where the TodoManager is instantiated and we implement a button on clicked handler. 1 2 3 4 5 6 7 8 9 10 11 12 13 Pane { TodoManager { id: manager } Button { text: 'Action' onClicked: doIt () } function doIt () { // here comes our code } } change the color to another random color 1 2 3 function doIt () { manager . color = Qt . rgba ( Math . random (), Math . random (), Math . random (), 1 ); } add new tasks to the task list This is currently not supported, we would have to extend the model for an append function. But which parameters would the append function take? If this would be a gadget, we can not create a gadget on the QML side, another option would be to pass in a QVariantMap . 1 2 3 4 5 6 function doIt () { // using a QVariantMap manager . tasks . append ({ text: \"Another Task\" , done: false }) // individual parameters manager . tasks . append ( \"Another Task\" , false ) } clear out all done tasks Also our current model does not support it yet, we have to add a clear function. 1 2 3 4 function doIt () { // using a QVariantMap manager . tasks . clear () } mark an individual task to be done If we would be in a ListView we would have access to an individual model entry 1 2 3 4 5 delegate: ItemDelegate { onClicked: { model . done = true ; } } If not, then we would need to implement an set function, which will take a field map and an index. 1 2 3 function doIt () { manager . tasks . set ( index , { done: true }); } update a task text We can again use our set method 1 2 3 function doIt () { manager . tasks . set ( index , { text: \"hello\" }); } or inside our list view the model assignment 1 2 3 delegate: Item { model . text = \"hello\" ; } change the individual timing settings To change the data we can use the grouped properties to access them. 1 2 3 function doIt () { manager . timing . work = 15 ; // set to 15 mins } Streamlining the API This API requires currently quit some thinking to ensure all data is exposed to the users in the correct way and easy accessible to the frontend. To streamline the API we could make the data read only and expose operations to support the different use case. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class TodoManager : public QObject { Q_OBJECT Q_PROPERTY ( QVariant color READ color notify colorChanged ) Q_PROPERTY ( QVariantModel * tasks READ tasks CONSTANT ) Q_PROPERTY ( QVariantMap * timing READ timing notify timingChanged ) ... public slots : // set random color void setRandomColor (); // add task to task list void addTask ( const QVariantMap & task ); // clear all done tasks void clearDoneTasks (); // update text or done on task void updateTask ( int index , const QVariantMap & fields ); // mark task done void markTaskDone ( int index ); // update a timing value void updateTiming ( QVariantMap fields ); } This API now very generic. Maybe a little bit too generic. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Task { Q_GADGET ... }; class Timing { Q_GADGET ... }; class TodoManager : public QObject { Q_OBJECT Q_PROPERTY ( QColor color READ color NOTIFY colorChanged ) Q_PROPERTY ( TaskModel * tasks READ tasks CONSTANT ) Q_PROPERTY ( Timing timing READ timing NOTIFY timingChanged ) ... public slots : // set random color void setRandomColor (); // add task to task list void addTask ( const QVariantMap & task ); // clear all done tasks void clearDoneTasks (); // update text or done on task void updateTask ( int index , const QVariantMap & fields ); // mark task done void markTaskDone ( int index ); // update a timing value void updateTiming ( QVariantMap fields ); } The difference now is that the structures are concrete types, same as primitive types. When mutating the value, we can not use concrete types as there is no real way to create them from QML side. You could create a factory but the approach is much more complicated. 1 2 3 4 5 function doIt () { var task = manager . createTask () task . done = true ; manager . updateTask ( 1 , task ); } versus the JavaScript way 1 2 3 function doIt () { manager . updateTask ( 1 , { done: true }); } The second one is much more accessible for a JavaScript developer. Also if this means a JS developer could add fields which do not exist in the structure. Often backend developers are sidetracked by the different options Qt offers you to expose data to C++. The risk is high to get lost in the details and try to come up with a highly flexible data access patterns. When doing so developers loose sight on how a front-end developer would have to use then the API inside QML. It is important to make an API as accessible and narrow as possible for the API user by not focusing on access patterns and more on API use cases. By this the API will hide the business logic from QML inside C++ and only expose an API to QML which most of the time can be used in a single line of code and is often self explanatory. Structure and Rules To make API creation more scalable we need to define a clear structure and rules, which we can pass on to developers. We want to separate state from mutations and queries. We define the state of an API as the sum of all properties. Actions are the methods which mutate the state, either directly or indirectly through a remote effect. And a query is a method which returns data. For reference see also: https://martinfowler.com/bliki/CQRS.html https://facebook.github.io/flux/ https://graphql.org/learn/queries/ API State Expose primitive types using read only properties Expose uncountable lists using read only models of either primitive types or structures presented by gadgets Expose countable lists using a QVector or QVariantList Expose structured data through gadgets or QVariantMap API Mutations or Queries Expose mutations using invokable methods Pass in structured data through QVariantMap Pass in primitives using QML base types","title":"Exposing Data to QML"},{"location":"topics/data/#exposing-data-to-qml","text":"A clever person solves a problem. A wise person avoids it. -- Einstein Info This chapter will show you how to expose the different ways of exposing data to the user interface layer and tries to develop a strategy to streamline the data exposure. We will shortly discuss the pros and cons of each strategy and later define a strategy which can scale.","title":"Exposing Data to QML"},{"location":"topics/data/#exposing-data","text":"Qt offers you several ways to inject data into the user interface presented by QML. QML comes with native support for JSON data using the JavaScript JSON.parse and JSON.stringify methods. As a transport you can use HTTP via the XMLHTTRequest or for web-sockets using the WebSocket library. Here is a list of references: https://doc.qt.io/qt-5/qtqml-xmlhttprequest-example.html https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON https://doc.qt.io/qt-5/qml-qtwebsockets-websocket.html The other option is to capture the data on the native C++ side expose it to QML using qmlRegisterType and properties, slots and signals. For this the Qt C++ data types need to be transformed to QML supported data types. The process of registering C++ data types and the conversion are discussed in the Qt documentation at several places. Here is a longer list of relevant sections. QtQml Overview - QML and C++ Integration Integrating QML and C++ Exposing Attributes of C++ Types to QML Defining QML Types from C++ Embedding C++ Objects into QML with Context Properties Interacting with QML Objects from C++ Data Type Conversion Between QML and C++ Writing QML Extensions with C++ Creating C++ Plugins for QML Important C++ Classes Provided By The Qt QML Module QtQuick Qt Quick C++ Classes C++ Extension Points Provided By Qt Quick QtQuick.Controls 2 Qt Quick Controls C++ Classes","title":"Exposing Data"},{"location":"topics/data/#json-or-c","text":"JSON is a great data format when you interact with HTTP REST endpoints or other cloud based services which are JSON based. When using Qt C++ you would need to rely on QNetworkAccessManager and QJSonDocument to consume such kind of services. There are 3rd party libraries which makes it easier to consume a HTTP REST endpoint on the QML side for example duperagent ( https://github.com/Cutehacks/duperagent ). When trying to expose JSON directly to the QML side using QtC++ it might be better to just expose the QByteArray to QML and let JavaScript to convert it to a JSON data type using JSON.parse . In pure QML you would have to use the XmlHttpRequest and convert the incoming data into JSON. This is pretty low level when coming from the web development and are used to other libraries like axios. From the C++ side you would use the QNetworkAccessManager and request a HTTP endpoint and convert the data into JSON using QJsonDocument . From there you normally convert it further to a QML supported types or other data structures to expose it to QML or using C++ native data types. If your data comes from another native source using a binary protocol you often have to write an adapter layer to convert the data types from standard C++ to Qt C++ and then you can directly expose this data to QML using Qt offered data conversions.","title":"JSON or C++"},{"location":"topics/data/#mechanics-of-exposure","text":"When you have the data as Qt C++ native types, you want to expose it to QML. But how best to approach this? We can see data as a structured tree which starts either with an object or an array. JSON demonstrated very nicely that all data can be reduced to simple data structures or primitive type and object or arrays. Same can be applied to Qt data. But data is not everything we want to expose, we also want to expose behavior in the form of operations on the data as also signals as notifications about changes. Additional Qt provides reactive programming, where an API consumer gets notified when a property has changed and which leads to data binding. It is only possible to bind to properties, not to operations or signals. On signals you can connect using a handler, which is just another form of callback. Operations might trigger property changes through the procedure or writing to a property will also trigger a property change. Besides these structures there is also the item model type in Qt. Which is a protocol to expose data arrays efficient to a view which expects a model.","title":"Mechanics of Exposure"},{"location":"topics/data/#demo-for-discussions","text":"To demonstrate the capabilities and possible issues we will develop a small configuration loader for a task list with a timer attached. The idea is you work on a task for x minutes, make a break and then continue to work on anther task. After some work unites you make a longer break. The configuration is stored in a JSON document and looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 { \"color\" : \"#FF0000\" , \"tasks\" : [ { \"text\" : \"task-1\" , \"done\" : false }, { \"text\" : \"task-2\" , \"done\" : false }, { \"text\" : \"task-3\" , \"done\" : true } ], \"timing\" : { \"work\" : 25 , \"short-break\" : 5 , \"long-break\" : 15 } } In the UI we would like to display the configuration and modify it. For example we would like to: change the color to another random color add new tasks to the task list clear out all done tasks mark task to be done update a task text change the individual timing settings As we need to use this information in different places we would like to get informed when any of these data fields change.","title":"Demo for Discussions"},{"location":"topics/data/#task-manager-api","text":"The data could come from a network service using HTTP or we could read it from a NOSQL DB, or simple from a JSON file. Using a JSON file is the simplest way. We would read the text document and use QJSonDocument to convert it into a QJsonObject and form there into a QVariantMap. From there on we have two options, either expose the whole document as a great QVariantMap or expose individual properties as a QVariant related type. Exposing the whole document: 1 2 3 4 5 6 class TodoManager : public QObject { Q_OBJECT Q_PROPERTY ( QVariantMap document READ document WRITE setDocument NOTIFY documentChanged ) ... } Or exposing the individual properties 1 2 3 4 5 6 class TodoManager : public QObject { Q_OBJECT Q_PROPERTY ( QColor color READ color WRITE setColor NOTIFY colorChanged ) Q_PROPERTY ( QVariantList tasks READ tasks WRITE setTasks NOTIFY tasksChanged ) Q_PROPERTY ( QVariantMap timing READ timing WRITE setTiming NOTIFY timingChanged ) Now we can get and set the data. Almost done.","title":"Task Manager API"},{"location":"topics/data/#c-data-sources","text":"If we would have C++ native data structures we would first write an adapter, before we can expose the data to Qt C++. The adapter could look like this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 struct Task { QString text bool done } struct Timing { int work ; int shortBreak ; int longBreak ; } class TodoEngine : public QObject { Q_OBJECT public : TodoEngine ( QObject * parent = nullptr ); QColor color (); void setColor ( QColor color ); QList < Task > tasks (); void appendTask ( Task task ); void clearTasks (); Timing timing (); void setTimming ( Timing t ); signals : void dataChanged (); private : }; This engine is using an C++ internal task implementation which is need to be adapted to be easy consumable for Qt. This engine API is not directly exposed to QML, we need to wrap it another time to ensure we provide a great experience. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class TimingGroupedProperty : public QObject { Q_OBJECT Q_PROPERTY ( int work READ work WRITE setWork NOTIFY workChanged ) Q_PROPERTY ( int shortBreak READ shortBreak WRITE setShortBreak NOTIFY workChanged ) Q_PROPERTY ( int longBreak READ longBreak WRITE setLongBreak NOTIFY longBreakChanged ) ... } class TodoManager : public QObject { Q_OBJECT Q_PROPERTY ( QColor color READ color WRITE setColor notify colorChanged ) Q_PROPERTY ( QVariantList task READ tasks WRITE setTasks notify tasksChanged ) Q_PROPERTY ( TimingGroupedProperty * timing READ timing CONSTANT ) ... } To make the list even better consumable we could introduce a model. 1 2 3 4 5 6 7 8 9 10 11 class TaskModel : public QAbstractItemListModel { ... }; class TodoManager : public QObject { Q_OBJECT Q_PROPERTY ( QColor color READ color WRITE setColor notify colorChanged ) Q_PROPERTY ( TaskModel * tasks READ tasks CONSTANT ) Q_PROPERTY ( TimingGroupedProperty * timing READ timing CONSTANT ) ... } The model could be editable by implementing setData and we would be able to assign values from inside QML. Now we should assume the API is perfect and can be used by the QML frontend developers.","title":"C++ Data Sources"},{"location":"topics/data/#using-an-api","text":"We should now remember about our use cases and see how a frontend developer would use our API. change the color to another random color add new tasks from the task list clear out all done tasks mark task to be done update a task text change the individual timing settings So lets see how the frontend developer would use the API. For this we can assume a simple UI where the TodoManager is instantiated and we implement a button on clicked handler. 1 2 3 4 5 6 7 8 9 10 11 12 13 Pane { TodoManager { id: manager } Button { text: 'Action' onClicked: doIt () } function doIt () { // here comes our code } } change the color to another random color 1 2 3 function doIt () { manager . color = Qt . rgba ( Math . random (), Math . random (), Math . random (), 1 ); } add new tasks to the task list This is currently not supported, we would have to extend the model for an append function. But which parameters would the append function take? If this would be a gadget, we can not create a gadget on the QML side, another option would be to pass in a QVariantMap . 1 2 3 4 5 6 function doIt () { // using a QVariantMap manager . tasks . append ({ text: \"Another Task\" , done: false }) // individual parameters manager . tasks . append ( \"Another Task\" , false ) } clear out all done tasks Also our current model does not support it yet, we have to add a clear function. 1 2 3 4 function doIt () { // using a QVariantMap manager . tasks . clear () } mark an individual task to be done If we would be in a ListView we would have access to an individual model entry 1 2 3 4 5 delegate: ItemDelegate { onClicked: { model . done = true ; } } If not, then we would need to implement an set function, which will take a field map and an index. 1 2 3 function doIt () { manager . tasks . set ( index , { done: true }); } update a task text We can again use our set method 1 2 3 function doIt () { manager . tasks . set ( index , { text: \"hello\" }); } or inside our list view the model assignment 1 2 3 delegate: Item { model . text = \"hello\" ; } change the individual timing settings To change the data we can use the grouped properties to access them. 1 2 3 function doIt () { manager . timing . work = 15 ; // set to 15 mins }","title":"Using an API"},{"location":"topics/data/#streamlining-the-api","text":"This API requires currently quit some thinking to ensure all data is exposed to the users in the correct way and easy accessible to the frontend. To streamline the API we could make the data read only and expose operations to support the different use case. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class TodoManager : public QObject { Q_OBJECT Q_PROPERTY ( QVariant color READ color notify colorChanged ) Q_PROPERTY ( QVariantModel * tasks READ tasks CONSTANT ) Q_PROPERTY ( QVariantMap * timing READ timing notify timingChanged ) ... public slots : // set random color void setRandomColor (); // add task to task list void addTask ( const QVariantMap & task ); // clear all done tasks void clearDoneTasks (); // update text or done on task void updateTask ( int index , const QVariantMap & fields ); // mark task done void markTaskDone ( int index ); // update a timing value void updateTiming ( QVariantMap fields ); } This API now very generic. Maybe a little bit too generic. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Task { Q_GADGET ... }; class Timing { Q_GADGET ... }; class TodoManager : public QObject { Q_OBJECT Q_PROPERTY ( QColor color READ color NOTIFY colorChanged ) Q_PROPERTY ( TaskModel * tasks READ tasks CONSTANT ) Q_PROPERTY ( Timing timing READ timing NOTIFY timingChanged ) ... public slots : // set random color void setRandomColor (); // add task to task list void addTask ( const QVariantMap & task ); // clear all done tasks void clearDoneTasks (); // update text or done on task void updateTask ( int index , const QVariantMap & fields ); // mark task done void markTaskDone ( int index ); // update a timing value void updateTiming ( QVariantMap fields ); } The difference now is that the structures are concrete types, same as primitive types. When mutating the value, we can not use concrete types as there is no real way to create them from QML side. You could create a factory but the approach is much more complicated. 1 2 3 4 5 function doIt () { var task = manager . createTask () task . done = true ; manager . updateTask ( 1 , task ); } versus the JavaScript way 1 2 3 function doIt () { manager . updateTask ( 1 , { done: true }); } The second one is much more accessible for a JavaScript developer. Also if this means a JS developer could add fields which do not exist in the structure. Often backend developers are sidetracked by the different options Qt offers you to expose data to C++. The risk is high to get lost in the details and try to come up with a highly flexible data access patterns. When doing so developers loose sight on how a front-end developer would have to use then the API inside QML. It is important to make an API as accessible and narrow as possible for the API user by not focusing on access patterns and more on API use cases. By this the API will hide the business logic from QML inside C++ and only expose an API to QML which most of the time can be used in a single line of code and is often self explanatory.","title":"Streamlining the API"},{"location":"topics/data/#structure-and-rules","text":"To make API creation more scalable we need to define a clear structure and rules, which we can pass on to developers. We want to separate state from mutations and queries. We define the state of an API as the sum of all properties. Actions are the methods which mutate the state, either directly or indirectly through a remote effect. And a query is a method which returns data. For reference see also: https://martinfowler.com/bliki/CQRS.html https://facebook.github.io/flux/ https://graphql.org/learn/queries/ API State Expose primitive types using read only properties Expose uncountable lists using read only models of either primitive types or structures presented by gadgets Expose countable lists using a QVector or QVariantList Expose structured data through gadgets or QVariantMap API Mutations or Queries Expose mutations using invokable methods Pass in structured data through QVariantMap Pass in primitives using QML base types","title":"Structure and Rules"},{"location":"topics/foundations/","text":"Foundations Abraham Lincoln reportedly said that, given eight hours to chop down a tree, he'd spend six sharpening his axe. -- TidBITS 654, quoted by Derek K. Miller, via Art Evans Abstract CoreUI is founded on some core-principles collected over the years, which all contribute to the overall design decisions. These principles are based on the opinions of many but may not be applicable to everyone. Here are some key principles: TODO: Add Image Follow the Agile Principles - UX depends on flexibility and agility. Keep it that way. Enable Hot-Reloading everywhere - Allow changes to be visible in a fraction of a second. Testability and dependency management is paramount - You can't trust code you cannot test. And trust is the foundation of large systems. Separation of Hardware and Software - As a UI developer you don't want to depend on something you cannot control or isn't even available at an early stage. UX Design is a bi-directional conversation - Design has a great impact on the UX, but also the chosen technology. Finding the balance and pushing forward together makes heroes. Thinking in Components and Building Blocks - Component-based programming leads to a better structure and allows for building larger user interfaces. Component separation is good, process separation is better - Trust is good, having control is better. A process gives you more control. Aspect driven components - Design your component layers around different aspects of your software. Each aspect provides another piece to the puzzle. A detailed description for each principle can be found below. Agile Principles QML Core UI embodies the core values of the Agile Manifesto for software development. TODO: Add Image Agility means in its core to \"walk the path even if you don't know the whole path yet\" . It is about taking the opportunity and relying on motivated teams. Individuals and Interactions over processes and tools: Tools and processes are important, but it's more important to have competent people working together effectively. Working Software over comprehensive documentation : Good documentation is useful in helping people to understand how the software is built and how to use it, but the main point of development is to create software, not documentation. Customer Collaboration over contract negotiation : A contract is important but is no substitute for working closely with customers to discover what they need. Responding to Change over following a plan : A project plan is important, but it mustn't be too rigid to accommodate changes in technology or the environment, stakeholders' priorities, and people's understanding of the problem and its solution. In short, while there is value in the items on the right, they value the items on the left more. [AgilePrinciples] Sources: Wikipedia, Agile Manifesto Live-reloading Live-reloading is the practice of reloading the program as a whole or as part triggered by a change in the underlying source code. TODO: Add Image That change can be triggered by a keystroke, a timer, or based on document persistence. The reloading can be either based on a preserved state or a clean state. A clean state approach is deservable, as it provides always a predictable start point. Enabling live-reloading throughout the CoreUI architecture serves several goals: Productivity : CoreUI enforces a clean abstraction of business-logic and visual-logic, thus making the reloading of business tests part of the daily work-flow. Testability : CoreUI not only supports live-reloading of the whole program but also encourages Developers to live-reload individual pieces of the user interface. As such it encourages the developer to think about components and their dependencies, thus resulting in better testability. UX Creation : Reloading also plays a crucial role in enabling great UX by making the conversation that the developer has with the UI teams more fluent. Testability and Controlled Dependency QML CoreUI separates user interface pieces into different kind of components with clearly-defined dependencies and interfaces. TODO: Add Image CoreUI encourages the developer to create smaller, well-defined, components. The idea is less about re-use but more about splitting the UI into small, manageable, pieces which can be implemented independently. This principle manages dependencies and smaller components, enabling testability with fewer headaches or overhead. Reuse is a result of separation, not the goal. CoreUI comes with a test harness which enables both manual component testing and automated component testing. Manual component testing is especially useful during development, when you want to try out a specific component. All of this can be paired with live-reloading of such tests: either when the test code itself or the underlying component changes. Separation of Hardware from Software Developing embedded software means always working with the target hardware. However, often the target hardware is not available in the early stages of development or even at later stages. TODO: Add Image Additionally, there may also be a shortage of devices and each developer can't have his or her own device to work with. These hardware can be big and difficult to place in an office. Consequently, the ability to develop as much software as possible without depending on the target hardware is highly desirable. Nevertheless, it is still required to go on the hardware as early as possible. This brings up the requirement of being flexible enough to support compatibility between different back-ends using the same front-end software. Ideally, you are able to run the front-end with either a simulation backend or with the real, production backend. Ideally, the simulation of the back-end can also run on the target HW. To foster easier front-end development it should also be possible to run the front-end on a desktop and have it using a back-end running on the target HW. To achieve this, the interface between front-end and back-end must be done via a cross-device communication protocol (typically TCP/IP based). UX Design Conversations Creating a stunning UX is a team effort involving UI designers, UI developers, and other stakeholders. TODO: Add Image The System needs to be able to deliver the processing power and graphics capabilities allowing a stunning user experience at first place, but even if this is given, still there is not a guarantee that a great UX will be created. To achieve a truly beautiful UX it is required that the visionary people who design the product and deliver the information architecture and UI appearance, work closely together with the people programming the UI. Only then a great UX can be achieved. The UI developers know what the system can deliver and which special effects and/or animations will take down the system and will start introducing an unsatisfying user experience to the user. The UI designers have their own vision into their head but often the documentation is lacking behind and also does not tell the whole story. These internal concepts not documented but expressed in design are important for the UI developers as they also need to base their detailed UI appearance on fundamental concepts. If these fundamental concepts diverge because of not being aware of each other, the UI code will always look like someone has patched it to make it work. A true harmony and understanding of UI design of the UI developer can be seen in the UI code produced by the developers. Thinking in Components While the UI developer using QML is forced to think in components as its basic building block, designers often don't think in terms of components. This is probably related to the pixels on a display and the tooling used that is based on pixel manipulation, less vector art, and objects. TODO: Add Image A component is a piece of a reusable user interface from which the information architecture receives a clear set of data and provides a clearly defined interaction to the user. This component can then be re-used in other parts of the user interface by manipulating the incoming properties. For example, a Button receives a text property which can be set when created, and allows the user to click on it as its interaction. This component can be used anywhere a button is used by assigning a different text property and reacting differently to the click interaction. Designing a square rectangle of pixels with a nice gradient, without thinking about how this rectangle eventually becomes a component with appearance, incoming data, and interaction - will result in the designer not being able to use the button everywhere coherently. Consequently, the developer will have to implement each of these buttons, providing the different flavors of buttons by adding more complex code to the initial component. Ideally, the designer comes up with a Style and Component guide which lists all common usable components together with their modifiers and interactions. This list should then be used to construct concrete user interfaces out of these components; custom components should be a rare exception. There is a common set of components that users are used to, which are often provided as standard components by the UI toolkits. Qt, for example, provides the QtQuick Controls 2 library. On a higher level, it is also worth thinking about larger components, such as components that act as a container for other components. In CoreUI, they are called panels. Panels provide a defined layout and interaction possibility for a set of components laid out together, for either a specific or a more general purpose. If a component can be re-used in different contexts it can also be re-used in a test setup. That said, it's important to display a component independently from its UI context to validate its appearance and behavior. Components vs. Processes A component is a reusable piece of user interface, with a known exported programming interface. A process is an execution unit, which allows the CPU to schedule it independently from other processes and manage the memory independently from other processes. TODO: Add Image A process provides security and separation of interfaces. Inside a process, you cannot easily call an API which is available inside another process. You always need to export this API and then make use of that from within the other process via some form of IPC. But processes can be re-used the same as components, but on a different level and with a much stricter control. Typically an application is a deciding factor to create a new process. An application can stem from a 3rd party and might introduce a security risk, so it is better to control its access to the system. In a single process UI where an application is merely a component, these security mechanisms do not exist, so any application can in general access every API. Aspect-driven Components Traditional UI development follows the user interface specifications and starts with the main document and then the folder structure mirrors the feature set of the UI specification. TODO: Add Image Applying this on larger user interfaces provides several drawbacks. The code gets more complex as deeper the folder structure goes. There is no guideline about dependency, which leads to the fact that even components on the edge of the UI tree might have dependencies to central components or worse other edges of the tree. Not controlling dependency is the main factor that the development speed slows down when the UI gets more complex. Aspect driven development tries to focus on the different aspects of a user interface (e.g. views, panels, controls, animations, helpers) and tries to provide clear guidance how such a component shall be constructed and which dependencies it might create. Release Early, Release Often Celebrate releasing your software. Releasing software is a practice which needs to be repeated and automated as much as possible. Always keep your software in a releasable state. TODO: Add Image Releasing usually means you have to interrupt your software development to make a release. By repeating this process over and over and perfecting the workflow, you can minimize the disruption a release creates and ensure your code stays in good health. You want to run a Continuous Integration (CI) workflow with a maximum number of automated tests, which ideally proves the test coverage. Try to release software that acts as feedback to your developers so that they experience releasing as a natural step forward. in the software development process. For example, if you work on the UI, you can release the platform that the UI is based on and ensure all developers use the same platform. See: https://en.wikipedia.org/wiki/Release_early,_release_often","title":"Foundations"},{"location":"topics/foundations/#foundations","text":"Abraham Lincoln reportedly said that, given eight hours to chop down a tree, he'd spend six sharpening his axe. -- TidBITS 654, quoted by Derek K. Miller, via Art Evans Abstract CoreUI is founded on some core-principles collected over the years, which all contribute to the overall design decisions. These principles are based on the opinions of many but may not be applicable to everyone. Here are some key principles: TODO: Add Image Follow the Agile Principles - UX depends on flexibility and agility. Keep it that way. Enable Hot-Reloading everywhere - Allow changes to be visible in a fraction of a second. Testability and dependency management is paramount - You can't trust code you cannot test. And trust is the foundation of large systems. Separation of Hardware and Software - As a UI developer you don't want to depend on something you cannot control or isn't even available at an early stage. UX Design is a bi-directional conversation - Design has a great impact on the UX, but also the chosen technology. Finding the balance and pushing forward together makes heroes. Thinking in Components and Building Blocks - Component-based programming leads to a better structure and allows for building larger user interfaces. Component separation is good, process separation is better - Trust is good, having control is better. A process gives you more control. Aspect driven components - Design your component layers around different aspects of your software. Each aspect provides another piece to the puzzle. A detailed description for each principle can be found below.","title":"Foundations"},{"location":"topics/foundations/#agile-principles","text":"QML Core UI embodies the core values of the Agile Manifesto for software development. TODO: Add Image Agility means in its core to \"walk the path even if you don't know the whole path yet\" . It is about taking the opportunity and relying on motivated teams. Individuals and Interactions over processes and tools: Tools and processes are important, but it's more important to have competent people working together effectively. Working Software over comprehensive documentation : Good documentation is useful in helping people to understand how the software is built and how to use it, but the main point of development is to create software, not documentation. Customer Collaboration over contract negotiation : A contract is important but is no substitute for working closely with customers to discover what they need. Responding to Change over following a plan : A project plan is important, but it mustn't be too rigid to accommodate changes in technology or the environment, stakeholders' priorities, and people's understanding of the problem and its solution. In short, while there is value in the items on the right, they value the items on the left more. [AgilePrinciples] Sources: Wikipedia, Agile Manifesto","title":"Agile Principles"},{"location":"topics/foundations/#live-reloading","text":"Live-reloading is the practice of reloading the program as a whole or as part triggered by a change in the underlying source code. TODO: Add Image That change can be triggered by a keystroke, a timer, or based on document persistence. The reloading can be either based on a preserved state or a clean state. A clean state approach is deservable, as it provides always a predictable start point. Enabling live-reloading throughout the CoreUI architecture serves several goals: Productivity : CoreUI enforces a clean abstraction of business-logic and visual-logic, thus making the reloading of business tests part of the daily work-flow. Testability : CoreUI not only supports live-reloading of the whole program but also encourages Developers to live-reload individual pieces of the user interface. As such it encourages the developer to think about components and their dependencies, thus resulting in better testability. UX Creation : Reloading also plays a crucial role in enabling great UX by making the conversation that the developer has with the UI teams more fluent.","title":"Live-reloading"},{"location":"topics/foundations/#testability-and-controlled-dependency","text":"QML CoreUI separates user interface pieces into different kind of components with clearly-defined dependencies and interfaces. TODO: Add Image CoreUI encourages the developer to create smaller, well-defined, components. The idea is less about re-use but more about splitting the UI into small, manageable, pieces which can be implemented independently. This principle manages dependencies and smaller components, enabling testability with fewer headaches or overhead. Reuse is a result of separation, not the goal. CoreUI comes with a test harness which enables both manual component testing and automated component testing. Manual component testing is especially useful during development, when you want to try out a specific component. All of this can be paired with live-reloading of such tests: either when the test code itself or the underlying component changes.","title":"Testability and Controlled Dependency"},{"location":"topics/foundations/#separation-of-hardware-from-software","text":"Developing embedded software means always working with the target hardware. However, often the target hardware is not available in the early stages of development or even at later stages. TODO: Add Image Additionally, there may also be a shortage of devices and each developer can't have his or her own device to work with. These hardware can be big and difficult to place in an office. Consequently, the ability to develop as much software as possible without depending on the target hardware is highly desirable. Nevertheless, it is still required to go on the hardware as early as possible. This brings up the requirement of being flexible enough to support compatibility between different back-ends using the same front-end software. Ideally, you are able to run the front-end with either a simulation backend or with the real, production backend. Ideally, the simulation of the back-end can also run on the target HW. To foster easier front-end development it should also be possible to run the front-end on a desktop and have it using a back-end running on the target HW. To achieve this, the interface between front-end and back-end must be done via a cross-device communication protocol (typically TCP/IP based).","title":"Separation of Hardware from Software"},{"location":"topics/foundations/#ux-design-conversations","text":"Creating a stunning UX is a team effort involving UI designers, UI developers, and other stakeholders. TODO: Add Image The System needs to be able to deliver the processing power and graphics capabilities allowing a stunning user experience at first place, but even if this is given, still there is not a guarantee that a great UX will be created. To achieve a truly beautiful UX it is required that the visionary people who design the product and deliver the information architecture and UI appearance, work closely together with the people programming the UI. Only then a great UX can be achieved. The UI developers know what the system can deliver and which special effects and/or animations will take down the system and will start introducing an unsatisfying user experience to the user. The UI designers have their own vision into their head but often the documentation is lacking behind and also does not tell the whole story. These internal concepts not documented but expressed in design are important for the UI developers as they also need to base their detailed UI appearance on fundamental concepts. If these fundamental concepts diverge because of not being aware of each other, the UI code will always look like someone has patched it to make it work. A true harmony and understanding of UI design of the UI developer can be seen in the UI code produced by the developers.","title":"UX Design Conversations"},{"location":"topics/foundations/#thinking-in-components","text":"While the UI developer using QML is forced to think in components as its basic building block, designers often don't think in terms of components. This is probably related to the pixels on a display and the tooling used that is based on pixel manipulation, less vector art, and objects. TODO: Add Image A component is a piece of a reusable user interface from which the information architecture receives a clear set of data and provides a clearly defined interaction to the user. This component can then be re-used in other parts of the user interface by manipulating the incoming properties. For example, a Button receives a text property which can be set when created, and allows the user to click on it as its interaction. This component can be used anywhere a button is used by assigning a different text property and reacting differently to the click interaction. Designing a square rectangle of pixels with a nice gradient, without thinking about how this rectangle eventually becomes a component with appearance, incoming data, and interaction - will result in the designer not being able to use the button everywhere coherently. Consequently, the developer will have to implement each of these buttons, providing the different flavors of buttons by adding more complex code to the initial component. Ideally, the designer comes up with a Style and Component guide which lists all common usable components together with their modifiers and interactions. This list should then be used to construct concrete user interfaces out of these components; custom components should be a rare exception. There is a common set of components that users are used to, which are often provided as standard components by the UI toolkits. Qt, for example, provides the QtQuick Controls 2 library. On a higher level, it is also worth thinking about larger components, such as components that act as a container for other components. In CoreUI, they are called panels. Panels provide a defined layout and interaction possibility for a set of components laid out together, for either a specific or a more general purpose. If a component can be re-used in different contexts it can also be re-used in a test setup. That said, it's important to display a component independently from its UI context to validate its appearance and behavior.","title":"Thinking in Components"},{"location":"topics/foundations/#components-vs-processes","text":"A component is a reusable piece of user interface, with a known exported programming interface. A process is an execution unit, which allows the CPU to schedule it independently from other processes and manage the memory independently from other processes. TODO: Add Image A process provides security and separation of interfaces. Inside a process, you cannot easily call an API which is available inside another process. You always need to export this API and then make use of that from within the other process via some form of IPC. But processes can be re-used the same as components, but on a different level and with a much stricter control. Typically an application is a deciding factor to create a new process. An application can stem from a 3rd party and might introduce a security risk, so it is better to control its access to the system. In a single process UI where an application is merely a component, these security mechanisms do not exist, so any application can in general access every API.","title":"Components vs. Processes"},{"location":"topics/foundations/#aspect-driven-components","text":"Traditional UI development follows the user interface specifications and starts with the main document and then the folder structure mirrors the feature set of the UI specification. TODO: Add Image Applying this on larger user interfaces provides several drawbacks. The code gets more complex as deeper the folder structure goes. There is no guideline about dependency, which leads to the fact that even components on the edge of the UI tree might have dependencies to central components or worse other edges of the tree. Not controlling dependency is the main factor that the development speed slows down when the UI gets more complex. Aspect driven development tries to focus on the different aspects of a user interface (e.g. views, panels, controls, animations, helpers) and tries to provide clear guidance how such a component shall be constructed and which dependencies it might create.","title":"Aspect-driven Components"},{"location":"topics/foundations/#release-early-release-often","text":"Celebrate releasing your software. Releasing software is a practice which needs to be repeated and automated as much as possible. Always keep your software in a releasable state. TODO: Add Image Releasing usually means you have to interrupt your software development to make a release. By repeating this process over and over and perfecting the workflow, you can minimize the disruption a release creates and ensure your code stays in good health. You want to run a Continuous Integration (CI) workflow with a maximum number of automated tests, which ideally proves the test coverage. Try to release software that acts as feedback to your developers so that they experience releasing as a natural step forward. in the software development process. For example, if you work on the UI, you can release the platform that the UI is based on and ensure all developers use the same platform. See: https://en.wikipedia.org/wiki/Release_early,_release_often","title":"Release Early, Release Often"},{"location":"topics/fslayout/","text":"Physical Layout Most architectures are accidential, not intensional -- Grady Booch Abstract The structure is the physical file and folder structure which defines the UI layer. It is composed of a sysui, applications, a controls library and styles. The UI is launched using a runtime and can be extended by native and qml extensions. The high-level structure divides the UI in SysUI and Apps as also an imports folder where shared components are located. 1 2 3 4 Main . qml sysui / apps / imports / You would run the UI using your custom runtime something like this: 1 runtime -I imports Main.qml The SysUI is seen as a specialized application. The concept of an application allows the developer to split the code into smaller manageable parts which are loosely coupled and have a high degree of separation (open-close-principle). Thus allowing a developer to extend an application with clean interfaces without harming the system UI. Open Closed Principle The open/closed principle states \"software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification\"; that is, such an entity can allow its behavior to be extended without modifying its source code ( https://en.wikipedia.org/wiki/Open/closed_principle ). System UI Structure The System UI is a specialized application which is the initial UI is started. Depending of the complexity of the SysUI the sysui itself can be structured like an application or in a complex SysUI each aspect of the SysUI (e.g. home, launcher, app container, overlays) can be structured similarly to an application. For a simple and medium complex SysUI the structure might look like this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 sysui / AppShell . qml controls / panels / views / HomeLayerView . qml LauncherLayerView . qml AppContainerLayerView . qml OverlayLayerView . qml DisplayView . qml stores / RootStore . qml HomeStore . qml ApplicationStore . qml OverlayStore . qml helpers / For a complex SysUI the structure might be divided by the different UI aspects and each aspect will be formed as an independent application structure. It is important that an aspect does not directly depend on other aspects. They might depend on incoming properties, and services. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sysui / AppShell . qml home / controls / panels / views / stores / helpers / overlays / controls / panels / views / stores / helpers / launcher / controls / panels / views / stores / helpers / display - Is concerned about UI portions which affect the entire display, such as the main display UI element or virtual keyboard. home - Contains the UI portions for the initial home page to be shown to the user. This screen is often very customizable and centrally to the further exploration of the UI. launcher - Shows the launcher screen, which allows you to launch more applications. Often this is a grid of application icons but it could have any form. Sometimes the designed user interface also does not require a dedicated launcher page. appcontainer - The application container the place where launched applications are shown. It contains also any application decoration or in case the application can have also a widget state the common widget decoration. overlays - Overlays is an own container in which overlays (e.g. system information, climate control, audio control) can be placed, based on the UI design. Note An application can have often several visual states. When the application is minimized and presents only a minimal UI (for example a weather app shows only the current temperature), this application UI is called a widget. A widget is typically arranged into a grid with other widgets and when activated it expands to the full application. Each of these portions of the system UI shall be structured like an independent light-weight application. It may be necessary for the future to move one of these system UI portions out into an own standalone application for performance or startup time reasons, or just for manageability. Application Structure An application is a collection of UI blocks glued together using a container. The service communication is created using a store mechanism. The store is a hierarchical object tree where each object represents a portion of the overall user interface. Todo Add diagram for store and UI relationship 1 2 3 4 5 6 7 8 9 10 11 12 13 14 apps / demo / Application . qml info . yaml stores / RootStore . qml StatusStore . qml views / ContainerView . qml WelcomeView . qml StatusView . qml panels / MasterDetailsPanel . qml controls / CustomButton . qml store - A store encapsulates the business logic and vertical communication view - A view larger UI building block which is allowed to use a store panel - A panel UI container for controls with no direct dependency to a store control - A control is a smaller building block for user interfaces Import Structure The imports folder contains shared modules, which can be used by either the system UI or an application. These imports are mainly QML based imports. Other Qt C++ native imports can be provided by using the Qt QML plugin system. A module is an extension to the runtime. A runtime can load modules from more than one import location located in different folders. By default all imports are loaded which are in the Qt SDK under the qml directory, this is also the default location for custom QtQuick plugins. Note The UI layer should only be composed of QML/JS documents to ensure frontend developers are not exposed to C++ code and can focus on the UX. Module names should be chosen carefully that they do not conflict with the Qt5 module but they should also not be so long as to feel cumbersome for the user to type. There is no need for 1st and 2nd party modules to use the reverse URI scheme for module naming. It has provided more useful to name the modules with two name depth or more to the user. Typical module names could be: controls - for the custom control library controls.style - for the style information inside y9our control utils - for shared helper modules The SysUI has an own import path to ensure privately used modules by the SysUI are not exposed to other applications. 1 2 3 4 5 ui / apps / imports / sysui / imports / Native plugins are part of the platform layer and are nor part of the UI layer. Note Shared modules are part of the official API exposed to the applications. You should ensure all APIs are well designed and thought through as these APIs are difficult to change afterwards.","title":"Filesystem layout"},{"location":"topics/fslayout/#physical-layout","text":"Most architectures are accidential, not intensional -- Grady Booch Abstract The structure is the physical file and folder structure which defines the UI layer. It is composed of a sysui, applications, a controls library and styles. The UI is launched using a runtime and can be extended by native and qml extensions. The high-level structure divides the UI in SysUI and Apps as also an imports folder where shared components are located. 1 2 3 4 Main . qml sysui / apps / imports / You would run the UI using your custom runtime something like this: 1 runtime -I imports Main.qml The SysUI is seen as a specialized application. The concept of an application allows the developer to split the code into smaller manageable parts which are loosely coupled and have a high degree of separation (open-close-principle). Thus allowing a developer to extend an application with clean interfaces without harming the system UI. Open Closed Principle The open/closed principle states \"software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification\"; that is, such an entity can allow its behavior to be extended without modifying its source code ( https://en.wikipedia.org/wiki/Open/closed_principle ).","title":"Physical Layout"},{"location":"topics/fslayout/#system-ui-structure","text":"The System UI is a specialized application which is the initial UI is started. Depending of the complexity of the SysUI the sysui itself can be structured like an application or in a complex SysUI each aspect of the SysUI (e.g. home, launcher, app container, overlays) can be structured similarly to an application. For a simple and medium complex SysUI the structure might look like this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 sysui / AppShell . qml controls / panels / views / HomeLayerView . qml LauncherLayerView . qml AppContainerLayerView . qml OverlayLayerView . qml DisplayView . qml stores / RootStore . qml HomeStore . qml ApplicationStore . qml OverlayStore . qml helpers / For a complex SysUI the structure might be divided by the different UI aspects and each aspect will be formed as an independent application structure. It is important that an aspect does not directly depend on other aspects. They might depend on incoming properties, and services. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sysui / AppShell . qml home / controls / panels / views / stores / helpers / overlays / controls / panels / views / stores / helpers / launcher / controls / panels / views / stores / helpers / display - Is concerned about UI portions which affect the entire display, such as the main display UI element or virtual keyboard. home - Contains the UI portions for the initial home page to be shown to the user. This screen is often very customizable and centrally to the further exploration of the UI. launcher - Shows the launcher screen, which allows you to launch more applications. Often this is a grid of application icons but it could have any form. Sometimes the designed user interface also does not require a dedicated launcher page. appcontainer - The application container the place where launched applications are shown. It contains also any application decoration or in case the application can have also a widget state the common widget decoration. overlays - Overlays is an own container in which overlays (e.g. system information, climate control, audio control) can be placed, based on the UI design. Note An application can have often several visual states. When the application is minimized and presents only a minimal UI (for example a weather app shows only the current temperature), this application UI is called a widget. A widget is typically arranged into a grid with other widgets and when activated it expands to the full application. Each of these portions of the system UI shall be structured like an independent light-weight application. It may be necessary for the future to move one of these system UI portions out into an own standalone application for performance or startup time reasons, or just for manageability.","title":"System UI Structure"},{"location":"topics/fslayout/#application-structure","text":"An application is a collection of UI blocks glued together using a container. The service communication is created using a store mechanism. The store is a hierarchical object tree where each object represents a portion of the overall user interface. Todo Add diagram for store and UI relationship 1 2 3 4 5 6 7 8 9 10 11 12 13 14 apps / demo / Application . qml info . yaml stores / RootStore . qml StatusStore . qml views / ContainerView . qml WelcomeView . qml StatusView . qml panels / MasterDetailsPanel . qml controls / CustomButton . qml store - A store encapsulates the business logic and vertical communication view - A view larger UI building block which is allowed to use a store panel - A panel UI container for controls with no direct dependency to a store control - A control is a smaller building block for user interfaces","title":"Application Structure"},{"location":"topics/fslayout/#import-structure","text":"The imports folder contains shared modules, which can be used by either the system UI or an application. These imports are mainly QML based imports. Other Qt C++ native imports can be provided by using the Qt QML plugin system. A module is an extension to the runtime. A runtime can load modules from more than one import location located in different folders. By default all imports are loaded which are in the Qt SDK under the qml directory, this is also the default location for custom QtQuick plugins. Note The UI layer should only be composed of QML/JS documents to ensure frontend developers are not exposed to C++ code and can focus on the UX. Module names should be chosen carefully that they do not conflict with the Qt5 module but they should also not be so long as to feel cumbersome for the user to type. There is no need for 1st and 2nd party modules to use the reverse URI scheme for module naming. It has provided more useful to name the modules with two name depth or more to the user. Typical module names could be: controls - for the custom control library controls.style - for the style information inside y9our control utils - for shared helper modules The SysUI has an own import path to ensure privately used modules by the SysUI are not exposed to other applications. 1 2 3 4 5 ui / apps / imports / sysui / imports / Native plugins are part of the platform layer and are nor part of the UI layer. Note Shared modules are part of the official API exposed to the applications. You should ensure all APIs are well designed and thought through as these APIs are difficult to change afterwards.","title":"Import Structure"},{"location":"topics/kind/","text":"Kind of Components In QML a component is a small document on the file system. A document is identified by the document name. The component might reference other components and import other modules. A module is a collection of documents referenced by the import qualified name. A module can be referenced as a local module using a relative path or by its full name as it was registered. Note Loading a module is normally very fast. But large modules might lead to a short delay, when the module is loaded the first time. This might happen when the module references a large plug-in which might also require some initialization. Components can be divided into different kind of components. A kind of component realizes a certain aspect of the user interface and is only allowed to have certain imports. The kind shall be well documented and its purpose well understood. In the CoreUI architecture we define by default the following kinds. Control A system or application wide reusable UI type. A control never depends on any service, or panels. A control is normally independent from the application purpose. For example a button, does not know anything about switching on or off lights. Panel A panel is a container for other controls, it is not exposed to any services. A panel might use layouts to arrange the controls. A panel has a application specific purpose. For example a array of buttons to switch on or off lights. This lights panel is specific for lights, also it does not directly interact with the lights. Layout A UI type which sole purpose is to organize other controls which are passed in. The layout can be static or dynamically configurable. View A view is very similar to a panel. It references often panels and wires up the data flow. The data comes from a store, which wraps the data sources (services). A view depends on a store, ideally on an abstract store. Store A store wraps the access to the different services. There is a root store in each application, and the root store can have child stores, to split the logic. If services are required in several stores then they need to be passed in. Service A service provides data and operation as also notifications. A service is always created maximal once per process. Only stores access services directly. Data structures exposed by the service can be passed onto other kinds, but not the service itself. There are local service and out-of-process services. Local services are in memory and might provide some application specific functionality. Out of process services use some type of IPC to communicate between processes and will normally be used asynchronously. These are only the basic kinds we identified. We typical also see kind of popups, assets or helpers. It would also possible to create kind of service, as resource for local services. The goal shall be to write the business logic driven component such as store, helpers or services in C++. As the language is better suited to process data and hold logic. Or for an application which is more 3D centric you might use own #D kinds e.g. materials, textures, shaders. Why all of this? When scaling work on larger projects it is important to be able to contain the dependencies and provide structure to people. QML is a hierarchical UI description language, which makes it very hard to organize the source code. The nature of hierarchical language is that the code is also organized into hierarchies after the user interface. Often we see projects which are organized after the information architecture, which might change over time. For people new to a project and not being familiar with these specifications have a hard time to understand the flow. We need to have some structure to scale and to organize things, which does not directly depend on the user interface structure. Using kind of components are one way of doing this. Physical Structure To avoid creating deeper and deeper structures of components, CoreUI advocated a flat structure. Where each kind gets an own folder. This has several advantages. It is much easier to review the dependencies of components. It is clear a component in the controls folder is only allowed to have a very limited list of imports. Also it is clear you will find all service referencing logic inside the stores folder. Using folders requires now also to think during the component creation what kind I want to create. A control or better a panel? When a kind changes it purpose it might require to move to a different folder. A side effect of folders is also we need to name things much better as there are folders with many components. And naming is one of the hardest aspects in software development. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 app / music / assets play . png pause . png / controls TwoStateButton . qml / panels MusicControlPanel . qml / layout ButtonGroupLayout . qml / views MusicPlayerView . qml / store RootStore . qml PlayListStore . qml PlayControlStore . qml / service AppNavigationService . qml From the structure we can deduct already many things. Okay there are the play pause assets. The TwoStateButton probably is used to display the play/pause state of a play control panel. We can see the TwoStateButton is music app agnostic, there might be other places such a button is useful. Actually when the developer comes back later he might think this is actually a switch and not a button. A music control panel seems to be the place where the next, play/pause and previous play controls are located. But we now more about the panel, we now also the panel will not access any music service. So it is pure UI logic. Which makes it easy to test. The layout seems to be a generic button row layout, this might be a component which could be extracted into a common layout library. The view seems to be using the music control panel to display the music control and pass in the data from the store. When looking for business logic and how the services are consumed we know we have to look into the stores. Without looking into the code we can already deduct quit a lot of knowledge and have a good idea where to change something. Also we have a structure which can scale and be tested. Compare this to a traditional approach 1 2 3 PlayControl.qml MusicPlayer.qml Main.qml The music player access the music service directly and contains the code of a two state button as also inline for a button row. Testing is a nightmare and when the music player feature set grows it is very hard to extract parts of this. Micro Refactoring How to come from a traditional user interface structure driven code into a kind of component driven code? As usual with hierarchical structures start with the edges. Scan your code and identify controls and layouts. Extract them according to your rules and place them into the correct folders. Then identify panels and ensure you push service dependencies up out of the panels. You will see when you do this, you will get a set of properties, signals, functions which are directly related to your services. These are the candidates to place into a store object and being passed in. When the store object is identified and passed in, it should be easy to divide a panel into a view part and a store independent part, your panel. When the store gets larger you can split the store into several sub-stores. Where each store provide an API which can be consumes by an area of the user interface. Do not split your stores simply by service domains. A store is now modeled after the services it contains, it is modeled after the user interface who consumes the store. A store API is frontend driven and does not lean towards the services. Make sure you pass in the services. Normally in only the root store creates the services. These services should initiate fast delay their communication. So avoid triggering any computing in a service constructor, better use a delayed call.","title":"Kind of Components"},{"location":"topics/kind/#kind-of-components","text":"In QML a component is a small document on the file system. A document is identified by the document name. The component might reference other components and import other modules. A module is a collection of documents referenced by the import qualified name. A module can be referenced as a local module using a relative path or by its full name as it was registered. Note Loading a module is normally very fast. But large modules might lead to a short delay, when the module is loaded the first time. This might happen when the module references a large plug-in which might also require some initialization. Components can be divided into different kind of components. A kind of component realizes a certain aspect of the user interface and is only allowed to have certain imports. The kind shall be well documented and its purpose well understood. In the CoreUI architecture we define by default the following kinds. Control A system or application wide reusable UI type. A control never depends on any service, or panels. A control is normally independent from the application purpose. For example a button, does not know anything about switching on or off lights. Panel A panel is a container for other controls, it is not exposed to any services. A panel might use layouts to arrange the controls. A panel has a application specific purpose. For example a array of buttons to switch on or off lights. This lights panel is specific for lights, also it does not directly interact with the lights. Layout A UI type which sole purpose is to organize other controls which are passed in. The layout can be static or dynamically configurable. View A view is very similar to a panel. It references often panels and wires up the data flow. The data comes from a store, which wraps the data sources (services). A view depends on a store, ideally on an abstract store. Store A store wraps the access to the different services. There is a root store in each application, and the root store can have child stores, to split the logic. If services are required in several stores then they need to be passed in. Service A service provides data and operation as also notifications. A service is always created maximal once per process. Only stores access services directly. Data structures exposed by the service can be passed onto other kinds, but not the service itself. There are local service and out-of-process services. Local services are in memory and might provide some application specific functionality. Out of process services use some type of IPC to communicate between processes and will normally be used asynchronously. These are only the basic kinds we identified. We typical also see kind of popups, assets or helpers. It would also possible to create kind of service, as resource for local services. The goal shall be to write the business logic driven component such as store, helpers or services in C++. As the language is better suited to process data and hold logic. Or for an application which is more 3D centric you might use own #D kinds e.g. materials, textures, shaders.","title":"Kind of Components"},{"location":"topics/kind/#why-all-of-this","text":"When scaling work on larger projects it is important to be able to contain the dependencies and provide structure to people. QML is a hierarchical UI description language, which makes it very hard to organize the source code. The nature of hierarchical language is that the code is also organized into hierarchies after the user interface. Often we see projects which are organized after the information architecture, which might change over time. For people new to a project and not being familiar with these specifications have a hard time to understand the flow. We need to have some structure to scale and to organize things, which does not directly depend on the user interface structure. Using kind of components are one way of doing this.","title":"Why all of this?"},{"location":"topics/kind/#physical-structure","text":"To avoid creating deeper and deeper structures of components, CoreUI advocated a flat structure. Where each kind gets an own folder. This has several advantages. It is much easier to review the dependencies of components. It is clear a component in the controls folder is only allowed to have a very limited list of imports. Also it is clear you will find all service referencing logic inside the stores folder. Using folders requires now also to think during the component creation what kind I want to create. A control or better a panel? When a kind changes it purpose it might require to move to a different folder. A side effect of folders is also we need to name things much better as there are folders with many components. And naming is one of the hardest aspects in software development. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 app / music / assets play . png pause . png / controls TwoStateButton . qml / panels MusicControlPanel . qml / layout ButtonGroupLayout . qml / views MusicPlayerView . qml / store RootStore . qml PlayListStore . qml PlayControlStore . qml / service AppNavigationService . qml From the structure we can deduct already many things. Okay there are the play pause assets. The TwoStateButton probably is used to display the play/pause state of a play control panel. We can see the TwoStateButton is music app agnostic, there might be other places such a button is useful. Actually when the developer comes back later he might think this is actually a switch and not a button. A music control panel seems to be the place where the next, play/pause and previous play controls are located. But we now more about the panel, we now also the panel will not access any music service. So it is pure UI logic. Which makes it easy to test. The layout seems to be a generic button row layout, this might be a component which could be extracted into a common layout library. The view seems to be using the music control panel to display the music control and pass in the data from the store. When looking for business logic and how the services are consumed we know we have to look into the stores. Without looking into the code we can already deduct quit a lot of knowledge and have a good idea where to change something. Also we have a structure which can scale and be tested. Compare this to a traditional approach 1 2 3 PlayControl.qml MusicPlayer.qml Main.qml The music player access the music service directly and contains the code of a two state button as also inline for a button row. Testing is a nightmare and when the music player feature set grows it is very hard to extract parts of this.","title":"Physical Structure"},{"location":"topics/kind/#micro-refactoring","text":"How to come from a traditional user interface structure driven code into a kind of component driven code? As usual with hierarchical structures start with the edges. Scan your code and identify controls and layouts. Extract them according to your rules and place them into the correct folders. Then identify panels and ensure you push service dependencies up out of the panels. You will see when you do this, you will get a set of properties, signals, functions which are directly related to your services. These are the candidates to place into a store object and being passed in. When the store object is identified and passed in, it should be easy to divide a panel into a view part and a store independent part, your panel. When the store gets larger you can split the store into several sub-stores. Where each store provide an API which can be consumes by an area of the user interface. Do not split your stores simply by service domains. A store is now modeled after the services it contains, it is modeled after the user interface who consumes the store. A store API is frontend driven and does not lean towards the services. Make sure you pass in the services. Normally in only the root store creates the services. These services should initiate fast delay their communication. So avoid triggering any computing in a service constructor, better use a delayed call.","title":"Micro Refactoring"},{"location":"topics/layouts/","text":"Layout Andr\u00e9 Bensoussan once explained to me the difference between a programmer and a designer: If you make a general statement, a programmer says, ' Yes, but... ', while a designer says, ' Yes, and... ' In the past the UI was a static view on the information to be presented. Today this view is very dynamic and the user expects the view to change its appearance based on the context the display is in. Another aspect of layout is the support for different screen sizes out of one code base. This aspect is important to support for example a low-end device and a mid and high-end device from only one code-base without re-writing the whole UI layer. The dynamic aspect of the layout of the visual elements always requires some fundamental rules defined by the design team the UI shall follow, the so called design language. Often these rules are based on a grid system or on other geometrical constraints. If such a fundamental layout system does not exist it will be impossible for a UI developer to code a UI that follows the UI specification in all different scenarios. The complexity of testing increases when a new device configuration is added to the supported list of devices. The testing requires to test all device configurations with all market variations. There needs to be though a test strategy planned for the UI testing. Resources https://www.designbetter.co/design-systems-handbook/ Layout Aspects The user interface specification is the base for the user interface implementation. To achieve a coherent UI the UI specification is linked to a design style guide identifying the different style elements used in the specification. The information and interaction is derived from an information architecture guide. These documents build the design foundation for the user interface implementation. A document does not have to be a typical document it can also be a set of documents or nowadays often wiki pages. Wiki pages have the advantage that they are less formal and transparent for the users to provide feedback and to interact with the authors of the content. It is important to create an open discussion between design and development teams to enrich the overall content and create the best experience for the users. The layout of a system includes the placing of UI elements but also their behavior on geometry changes. Additionally the layout also includes information about the used font and icons. The layout needs to adapt to the changes of the display size, or display orientation but also to changes based on the user interaction. Design Systems The most commonly used design system is the grid. It allows to divide the display in equally wide columns with common spacing. The content is vertically aligned which pleases the eye. Each major UI element needs to be placed according to the grid system. The grid content is not static it can be resized but it will snap on these grid cells. Geometry User interface elements are defined by the x,y position and their width, height expansion. The x,y position is relative to the parent element. The place in the UI tree is as such another aspect which defines a UI element. The position in the tree also defines the z-order of the element. The z-order defines if an element is rendered above or below another element. Through the property binding of QML it is possible to simply define relations between aspects of an item. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Item { id: root width: 200 height: 200 Item { width: root . width / 2 height: root . height } Item { x: root . width / 2 width: root . width / 2 height: root . height } } Geometry relations can be easily expressed using the x,y,width,height properties and bind them either to static values or to another properties as an expression. Anchoring Anchoring is the process to bind one anchor line of an element to another anchor line of another (parent or sibling) element. The anchor lines can be left, right, top, bottom and the vertical and horizontal center. Anchoring can happen with an offset or so called margin to allow spacing of the elements. Anchoring of UI elements is a very powerful and strong way to express geometrical relationships between UI elements. It is used for major UI elements which should have a clear relationship. Positioning Special positioner elements allow to manipulate the x,y position according given rules. These positioners are called Row, Column, Grid, Flow. Be aware that these positioners only manipulate the x,y position of an element not width and height. Positioning is used when the width, height of elements should not have an influence on the layout. Most often Layout Managers are the preferred solution. Layout Manager A layout manager manages the full geometry of a UI element. There exist currenty three types of layout managers: RowLayout, ColumnLayout and GridLayout. In practice RowLayout and ColumnLayout are just simplified versions of the GridLayout. The GridLayout is really powerful, it supports setting preferred sizes, spacing, fills, spans, max/min sizes and margins. As a bonus the Layout supports also mirroring which can be used in user interfaces that should take care about different writing directions or in cars where the steering wheel is placed on the right or left side according to the country rules. Custom Layout Manager A layout of component is often defined inside a panel. It is also possible to extract the layout part of the panel into an own component. The layout component would then use loaders and component properties to load the components taking part in the layout and to control the layout. Here is an example of a border layout 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import QtQuick 2.10 import QtQuick . Controls 2.3 import QtQuick . Layouts 1.3 Control { id: control property alias topComponent: topLoader . sourceComponent property alias leftComponent: leftLoader . sourceComponent property alias rightComponent: rightLoader . sourceComponent property alias bottomComponent: bottomLoader . sourceComponent property alias centerComponent: centerLoader . sourceComponent background: ColumnLayout { implicitWidth: 640 implicitHeight: 480 spacing: 0 Loader { id: topLoader Layout.fillWidth: true Layout.preferredHeight: item ? item.height: - 1 } RowLayout { Layout.fillWidth: true Layout.fillHeight: true spacing: 0 Loader { id: leftLoader Layout.fillHeight: true Layout.preferredWidth: item ? item.width: - 1 } Loader { id: centerLoader Layout.fillWidth: true Layout.fillHeight: true } Loader { id: rightLoader Layout.fillHeight: true Layout.preferredWidth: item ? item.width: - 1 } } Loader { id: bottomLoader Layout.fillWidth: true Layout.preferredHeight: item ? item.height: - 1 } } } The loader acts as a placeholder for the control to be placed. The layout parameters depend on the existence of the particular control (e.g. Layout.preferredHeight: item?item.height:-1 ). By this you can create also more complex layouts and testing of these layouts can be done indepently from the UI. This custom layout can be used like any other component. 1 2 3 4 5 6 7 8 9 10 import QtQuick 2.10 import QtQuick . Controls 2.3 BorderLayout { topComponent: Button { text: \"TOP\" } bottomComponent: Button { text: \"BOTTOM\" } rightComponent: Button { text: \"RIGHT\" } leftComponent: Button { text: \"LEFT\" } centerComponent: Button { text: \"CENTER\" } } Note A layout can also be implemented in QtC++ in a more performant way. This QML based layout has a small impact on performance as it creates a Loader for each part. In case you notice any delay you might want to look into moving this layout to QtC++.","title":"Layouts"},{"location":"topics/layouts/#layout","text":"Andr\u00e9 Bensoussan once explained to me the difference between a programmer and a designer: If you make a general statement, a programmer says, ' Yes, but... ', while a designer says, ' Yes, and... ' In the past the UI was a static view on the information to be presented. Today this view is very dynamic and the user expects the view to change its appearance based on the context the display is in. Another aspect of layout is the support for different screen sizes out of one code base. This aspect is important to support for example a low-end device and a mid and high-end device from only one code-base without re-writing the whole UI layer. The dynamic aspect of the layout of the visual elements always requires some fundamental rules defined by the design team the UI shall follow, the so called design language. Often these rules are based on a grid system or on other geometrical constraints. If such a fundamental layout system does not exist it will be impossible for a UI developer to code a UI that follows the UI specification in all different scenarios. The complexity of testing increases when a new device configuration is added to the supported list of devices. The testing requires to test all device configurations with all market variations. There needs to be though a test strategy planned for the UI testing. Resources https://www.designbetter.co/design-systems-handbook/","title":"Layout"},{"location":"topics/layouts/#layout-aspects","text":"The user interface specification is the base for the user interface implementation. To achieve a coherent UI the UI specification is linked to a design style guide identifying the different style elements used in the specification. The information and interaction is derived from an information architecture guide. These documents build the design foundation for the user interface implementation. A document does not have to be a typical document it can also be a set of documents or nowadays often wiki pages. Wiki pages have the advantage that they are less formal and transparent for the users to provide feedback and to interact with the authors of the content. It is important to create an open discussion between design and development teams to enrich the overall content and create the best experience for the users. The layout of a system includes the placing of UI elements but also their behavior on geometry changes. Additionally the layout also includes information about the used font and icons. The layout needs to adapt to the changes of the display size, or display orientation but also to changes based on the user interaction.","title":"Layout Aspects"},{"location":"topics/layouts/#design-systems","text":"The most commonly used design system is the grid. It allows to divide the display in equally wide columns with common spacing. The content is vertically aligned which pleases the eye. Each major UI element needs to be placed according to the grid system. The grid content is not static it can be resized but it will snap on these grid cells.","title":"Design Systems"},{"location":"topics/layouts/#geometry","text":"User interface elements are defined by the x,y position and their width, height expansion. The x,y position is relative to the parent element. The place in the UI tree is as such another aspect which defines a UI element. The position in the tree also defines the z-order of the element. The z-order defines if an element is rendered above or below another element. Through the property binding of QML it is possible to simply define relations between aspects of an item. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Item { id: root width: 200 height: 200 Item { width: root . width / 2 height: root . height } Item { x: root . width / 2 width: root . width / 2 height: root . height } } Geometry relations can be easily expressed using the x,y,width,height properties and bind them either to static values or to another properties as an expression.","title":"Geometry"},{"location":"topics/layouts/#anchoring","text":"Anchoring is the process to bind one anchor line of an element to another anchor line of another (parent or sibling) element. The anchor lines can be left, right, top, bottom and the vertical and horizontal center. Anchoring can happen with an offset or so called margin to allow spacing of the elements. Anchoring of UI elements is a very powerful and strong way to express geometrical relationships between UI elements. It is used for major UI elements which should have a clear relationship.","title":"Anchoring"},{"location":"topics/layouts/#positioning","text":"Special positioner elements allow to manipulate the x,y position according given rules. These positioners are called Row, Column, Grid, Flow. Be aware that these positioners only manipulate the x,y position of an element not width and height. Positioning is used when the width, height of elements should not have an influence on the layout. Most often Layout Managers are the preferred solution.","title":"Positioning"},{"location":"topics/layouts/#layout-manager","text":"A layout manager manages the full geometry of a UI element. There exist currenty three types of layout managers: RowLayout, ColumnLayout and GridLayout. In practice RowLayout and ColumnLayout are just simplified versions of the GridLayout. The GridLayout is really powerful, it supports setting preferred sizes, spacing, fills, spans, max/min sizes and margins. As a bonus the Layout supports also mirroring which can be used in user interfaces that should take care about different writing directions or in cars where the steering wheel is placed on the right or left side according to the country rules.","title":"Layout Manager"},{"location":"topics/layouts/#custom-layout-manager","text":"A layout of component is often defined inside a panel. It is also possible to extract the layout part of the panel into an own component. The layout component would then use loaders and component properties to load the components taking part in the layout and to control the layout. Here is an example of a border layout 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import QtQuick 2.10 import QtQuick . Controls 2.3 import QtQuick . Layouts 1.3 Control { id: control property alias topComponent: topLoader . sourceComponent property alias leftComponent: leftLoader . sourceComponent property alias rightComponent: rightLoader . sourceComponent property alias bottomComponent: bottomLoader . sourceComponent property alias centerComponent: centerLoader . sourceComponent background: ColumnLayout { implicitWidth: 640 implicitHeight: 480 spacing: 0 Loader { id: topLoader Layout.fillWidth: true Layout.preferredHeight: item ? item.height: - 1 } RowLayout { Layout.fillWidth: true Layout.fillHeight: true spacing: 0 Loader { id: leftLoader Layout.fillHeight: true Layout.preferredWidth: item ? item.width: - 1 } Loader { id: centerLoader Layout.fillWidth: true Layout.fillHeight: true } Loader { id: rightLoader Layout.fillHeight: true Layout.preferredWidth: item ? item.width: - 1 } } Loader { id: bottomLoader Layout.fillWidth: true Layout.preferredHeight: item ? item.height: - 1 } } } The loader acts as a placeholder for the control to be placed. The layout parameters depend on the existence of the particular control (e.g. Layout.preferredHeight: item?item.height:-1 ). By this you can create also more complex layouts and testing of these layouts can be done indepently from the UI. This custom layout can be used like any other component. 1 2 3 4 5 6 7 8 9 10 import QtQuick 2.10 import QtQuick . Controls 2.3 BorderLayout { topComponent: Button { text: \"TOP\" } bottomComponent: Button { text: \"BOTTOM\" } rightComponent: Button { text: \"RIGHT\" } leftComponent: Button { text: \"LEFT\" } centerComponent: Button { text: \"CENTER\" } } Note A layout can also be implemented in QtC++ in a more performant way. This QML based layout has a small impact on performance as it creates a Loader for each part. In case you notice any delay you might want to look into moving this layout to QtC++.","title":"Custom Layout Manager"},{"location":"topics/principles/","text":"Design Principles The First Rule of Program Optimization: Don't do it. The Second Rule of Program Optimization (for experts only!): Don't do it yet. -- Michael A. Jackson Software design is an important part of the software development cycle. Thinking about how to create structure before start writing code is critical. Good software design comes from capturing the requirements and playing with the question \"What happens when ...?\" \"What happens when ...?\" captures the moving parts. And parts with move together should stay together and the joints should be protected by interfaces. These principles are expressed in bad and good principles. Please bear in mind principles are not laws. But consider them as good practices and improve on them by discussion. Most comes from an article called: From STUPID to SOLID Code STUPID - Bad Principles Singleton Tight Coupling Untestability Premature Optimization Indescriptive Naming Duplication Singleton Pattern The Singleton pattern is probably the most well-known design pattern, but also the most misunderstood one. There is something called a Singleton syndrome. It is when the developer thinks the Singleton pattern is the most appropriate pattern for the current use case. In other words, a Singleton will be used everywhere. That is definitely not cool. Singletons are controversial , and they are often considered anti-patterns . They should be avoided. Actually, the use of a singleton is not the problem, but the symptom of a problem. Here are two reasons why: Programs using global state are very difficult to test Programs that rely on global state hide their dependencies But should they be avoided at all time? You can argue yes, because they can often be replaced by something better. Avoiding global things is important to avoid something called tight coupling. Tight Coupling Tight coupling , also known as strong coupling, it appears together with cohesion . Basically, you should reduce coupling between your modules and increase cohesion inside a module. It boils down to this: If changing one module in a program requires changing another module, then coupling exists. For instance, you instantiate objects in your constructor\u2019s class instead of passing instances as arguments. That is bad because it doesn\u2019t allow further changes such as replacing the instance by an instance of a sub-class, a mock or whatever. Tightly coupled modules are difficult to reuse, and also hard to test. Untestability Testing should not be hard! Really! Whenever there is no time to write unit tests, the real issue is that code is bad, but that is another story. Making code clean and testable requires time and knowledge. Code shall be written with the idea in mind that the team has to maintain it for the next ten years! Most of the time, untestability is caused by tight coupling. Premature Optimization SOLID - Good Principles Single Responsibility Principle Open Closed Principle Liskov Substitution Principle Interface Segregation Principle Dependency Inversion Principle Single Responsibility Principle Single Responsibility Principle or SRP states that every class should have a single responsibility. There should never be more than one reason for a class to change. In other words: Things what change together, belong together . Just because you can add everything you want into your class doesn\u2019t mean that you should. Thinking in terms of responsibilities will help you design your application better. Ask yourself whether the logic you are introducing should live in this class or not. Using layers in your application helps a lot. Split big classes in smaller ones, and avoid god classes. Last but not least, write straightforward comments. If you start writing comments such as in this case, but if, except when, or, then you are doing it wrong. Open Closed Principle Open/Closed Principle or OCP states that software entities should be open for extension, but closed for modification. The principles tells to write code so that it will be able to add new functionality without changing the existing code. That prevents situations in which a change to one of your classes also requires you to adapt all depending classes. This can be achived using interfaces or composition. Pure inheritance seems to be not a perfect solution, as inheritance introduces tight coupling. Liskov Substitution Principle Liskov Substitution Principle or LSP states that objects in a program should be replaceable with instances of their subtypes without altering the correctness of the program. A derived type shall be able to replace a super type, without requiring code changes on other places. It can be achived by following a few simple rules, which are similar to design by contract by Betrand Meyer. An overridden sub type method needs to have the same signature from the super type It is allowed to implement less restrictive validation rules in the sub type. It is not allowed to enforce stricter validation rules in a sub type. The result is that substition does not only enforce an API surface but also a behaviour, expressed in rules. These rules can be validated by test cases or code reviews. Interface Segregation Principle Interface Segregation Principle (ISR) states that several focused interfaces are better than one general-purpose interface. In other words, you should not have to implement methods that you don\u2019t use. Enforcing ISP gives you low coupling, and high cohesion. An interface is a contract that meets a need. Coupling as a metric for inter-component binding and cohesion as metric for inside-component binding. High cohesion means to keep similar and related things together. The idea is to keep your components focused and try to minimize the dependencies between them. Dependency Inversion Principle The Dependency Inversion Principle (DIP) states that high level components (policy making) should not depend on low level (details) components; both should depend on abstractions (e.g. interfaces). High-level modules should not depend on low-level modules. Both should depend on abstractions (e.g. interfaces). Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions. By both depending of abstraction, effectively the dependency is inverst. This allows us also to replace the low-level component with another component implementing the abstraction. This goes hand-in-hand with dependency-injection . When a component gets an abstraction injected, the using component is free to inject a different implementation. Use the same level of abstraction at a given level Other Principles Dependency Injection - Wikipedia Law of Demeter - Wikipedia Convention over configuration - Wikipedia Don\u2019t repeat yourself - Wikipedia","title":"Design Principles"},{"location":"topics/principles/#design-principles","text":"The First Rule of Program Optimization: Don't do it. The Second Rule of Program Optimization (for experts only!): Don't do it yet. -- Michael A. Jackson Software design is an important part of the software development cycle. Thinking about how to create structure before start writing code is critical. Good software design comes from capturing the requirements and playing with the question \"What happens when ...?\" \"What happens when ...?\" captures the moving parts. And parts with move together should stay together and the joints should be protected by interfaces. These principles are expressed in bad and good principles. Please bear in mind principles are not laws. But consider them as good practices and improve on them by discussion. Most comes from an article called: From STUPID to SOLID Code","title":"Design Principles"},{"location":"topics/principles/#stupid-bad-principles","text":"Singleton Tight Coupling Untestability Premature Optimization Indescriptive Naming Duplication","title":"STUPID - Bad Principles"},{"location":"topics/principles/#singleton-pattern","text":"The Singleton pattern is probably the most well-known design pattern, but also the most misunderstood one. There is something called a Singleton syndrome. It is when the developer thinks the Singleton pattern is the most appropriate pattern for the current use case. In other words, a Singleton will be used everywhere. That is definitely not cool. Singletons are controversial , and they are often considered anti-patterns . They should be avoided. Actually, the use of a singleton is not the problem, but the symptom of a problem. Here are two reasons why: Programs using global state are very difficult to test Programs that rely on global state hide their dependencies But should they be avoided at all time? You can argue yes, because they can often be replaced by something better. Avoiding global things is important to avoid something called tight coupling.","title":"Singleton Pattern"},{"location":"topics/principles/#tight-coupling","text":"Tight coupling , also known as strong coupling, it appears together with cohesion . Basically, you should reduce coupling between your modules and increase cohesion inside a module. It boils down to this: If changing one module in a program requires changing another module, then coupling exists. For instance, you instantiate objects in your constructor\u2019s class instead of passing instances as arguments. That is bad because it doesn\u2019t allow further changes such as replacing the instance by an instance of a sub-class, a mock or whatever. Tightly coupled modules are difficult to reuse, and also hard to test.","title":"Tight Coupling"},{"location":"topics/principles/#untestability","text":"Testing should not be hard! Really! Whenever there is no time to write unit tests, the real issue is that code is bad, but that is another story. Making code clean and testable requires time and knowledge. Code shall be written with the idea in mind that the team has to maintain it for the next ten years! Most of the time, untestability is caused by tight coupling.","title":"Untestability"},{"location":"topics/principles/#premature-optimization","text":"","title":"Premature Optimization"},{"location":"topics/principles/#solid-good-principles","text":"Single Responsibility Principle Open Closed Principle Liskov Substitution Principle Interface Segregation Principle Dependency Inversion Principle","title":"SOLID - Good Principles"},{"location":"topics/principles/#single-responsibility-principle","text":"Single Responsibility Principle or SRP states that every class should have a single responsibility. There should never be more than one reason for a class to change. In other words: Things what change together, belong together . Just because you can add everything you want into your class doesn\u2019t mean that you should. Thinking in terms of responsibilities will help you design your application better. Ask yourself whether the logic you are introducing should live in this class or not. Using layers in your application helps a lot. Split big classes in smaller ones, and avoid god classes. Last but not least, write straightforward comments. If you start writing comments such as in this case, but if, except when, or, then you are doing it wrong.","title":"Single Responsibility Principle"},{"location":"topics/principles/#open-closed-principle","text":"Open/Closed Principle or OCP states that software entities should be open for extension, but closed for modification. The principles tells to write code so that it will be able to add new functionality without changing the existing code. That prevents situations in which a change to one of your classes also requires you to adapt all depending classes. This can be achived using interfaces or composition. Pure inheritance seems to be not a perfect solution, as inheritance introduces tight coupling.","title":"Open Closed Principle"},{"location":"topics/principles/#liskov-substitution-principle","text":"Liskov Substitution Principle or LSP states that objects in a program should be replaceable with instances of their subtypes without altering the correctness of the program. A derived type shall be able to replace a super type, without requiring code changes on other places. It can be achived by following a few simple rules, which are similar to design by contract by Betrand Meyer. An overridden sub type method needs to have the same signature from the super type It is allowed to implement less restrictive validation rules in the sub type. It is not allowed to enforce stricter validation rules in a sub type. The result is that substition does not only enforce an API surface but also a behaviour, expressed in rules. These rules can be validated by test cases or code reviews.","title":"Liskov Substitution Principle"},{"location":"topics/principles/#interface-segregation-principle","text":"Interface Segregation Principle (ISR) states that several focused interfaces are better than one general-purpose interface. In other words, you should not have to implement methods that you don\u2019t use. Enforcing ISP gives you low coupling, and high cohesion. An interface is a contract that meets a need. Coupling as a metric for inter-component binding and cohesion as metric for inside-component binding. High cohesion means to keep similar and related things together. The idea is to keep your components focused and try to minimize the dependencies between them.","title":"Interface Segregation Principle"},{"location":"topics/principles/#dependency-inversion-principle","text":"The Dependency Inversion Principle (DIP) states that high level components (policy making) should not depend on low level (details) components; both should depend on abstractions (e.g. interfaces). High-level modules should not depend on low-level modules. Both should depend on abstractions (e.g. interfaces). Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions. By both depending of abstraction, effectively the dependency is inverst. This allows us also to replace the low-level component with another component implementing the abstraction. This goes hand-in-hand with dependency-injection . When a component gets an abstraction injected, the using component is free to inject a different implementation. Use the same level of abstraction at a given level","title":"Dependency Inversion Principle"},{"location":"topics/principles/#other-principles","text":"Dependency Injection - Wikipedia Law of Demeter - Wikipedia Convention over configuration - Wikipedia Don\u2019t repeat yourself - Wikipedia","title":"Other Principles"},{"location":"topics/prototyping/","text":"Prototyping Weeks of coding can save you hours of Planning!! Info This material is work in progress and will change! User interface prototyping shall allow an early project to advance in the exploration of the user interface using a lean work flow. It is desirable but not always realistic that the resulting code shall follow the same architecture patterns and guides created for standard projects. Ideally, also the technology and used and the environment the technology is applied to shall be near a production. Making efforts to re-create a potential production environment ensures the outcome is somewhat comparable to a real scenario. For embedded devices it important also get as close as possible to the target setup by using a similar or even less powerful board and a similar display and input methods. Also the housing can be prototyped to allow a user to experience the UI in a near real setup scenario. Introduction What is the value of a user interface demonstrated on a high-end PC compared to the experience a user interface gives you in a comparable HW inside a setup comparable to the real HW where the user can explore the user interface? There needs always a balance between investment and revenue. If the revenue is high enough it is worthwhile going the extra mile to allow a potential user and stakeholders to experience the real device. During prototyping, you want to focus on the UX less on system creation. You want to be agile and move fast. The turnaround time of a solution might be just hours or days and you focus less on testing or completeness or even correctness. You feel okay to fake data or behavior when needed and use the real data when suitable. All of these decisions come with a cost, the prototyping software will never be your production software. The solution if carefully created might be used as a starting point for a product but seldom will evolve into a product. Often is is better and cheaper to start over again from the learning of the prototype code. Using a common architecture which is suited for prototyping and production increases the potential reuse and shortens time to market and the overall product creation costs. Todo Show a diagram which shows a product platform being used for UI exploration by using and extending services and by using and extending the UI layer. A carefully crafted production architecture should be flexible enough to be scaled from a prototyping phase into a production phase. It might require certain parts to be re-written as long as these parts are clearly marked and understood the effort and risk should be acceptable. Architecture In an early prototyping architecture, you might want to skip the multi-process mode of AppMan as it removes the dependency to a Wayland setup. You still want to keep the SysUI/Application structure as it provides you a clean plan where to provide your QML components. Services should be written using QML/JS and mock the behavior of a real service. A service with static data can be purely written using a QML file. If more dynamic data is require a JSON reader plug-in of HTTP requests API can be used to request more data, e.g. from JSON files or a JSON web service. Using JSON as the underlying mock-data format makes it easy to convert it into the QML/JS data types. Also MQTT can be easily used to provide mock-data and behavior or any. An important aspect of the data source used it should be easily installable on different systems and the data must be easily create and changeable. Otherwise the idea of prototyping is not full-filled. Todo Draw a diagram which showcases a production setup and a prototyping setup where the services are using other technologies but the client APIs are in QML. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // service/counter/Counter.qml import http . requests 1.0 QtObject { id: root Requests { id: requests baseUrl: 'http://localhost:8888/api' } property var _state : ({ count: 0 }) readonly property int count: _state . count void increment () { requests . post ( 'increment' , function ( resp ) { _state = resp . data ; }); } void decrement () { requests . post ( 'decrement' , function ( resp ) { _state = resp . data ; }); } } The code snippet above uses a JSON rest API provided on local host, which on every call will return the full state of that interface. This makes the coding of the state update much easier. Your prototyping implementation might look completely different. A good technology to use could be the JSON server from NodeJS (see https://github.com/typicode/json-server ). Ideally, the resulting QML API can be easily consumed by the UI or the Stores. The API should hide which technology was used and only export the data and operations of the client API. By this, we can later change the implementation using a different technology and keep the UI from being cluttered with IPC calls. You would then use this mocked service client API as usual inside the RootStore. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // stores/RootStore.qml import services . counter 1.0 QtObject { id: root Counter { id: counter } property alias count: counter . count function up () { if ( count < 10 ) { counter . increment () } } function down () { if ( count > 0 ) { counter . decrement () } } } This code snippet looks a little bit superficial as nothing really happens here, but in a more complex UI, a client and a store both carry different aspects of logic. It is a good practice to separate this aspect. A client to adopt an IPC conversation to a QML API and the Store to ensure the UI is clean of business logic. Reloading As the client API is now a QML part we can enable live-reloading on this part. No need to compile source code or deploy libraries. If a NodeJS server is used it also supports already live-reloading using the nodemon tool, which means our whole chain would be live re-loadable, which is one of the cornerstones for Rapid-UI-Prototyping. Live-reload everything! Enjoy!","title":"Protoyping"},{"location":"topics/prototyping/#prototyping","text":"Weeks of coding can save you hours of Planning!! Info This material is work in progress and will change! User interface prototyping shall allow an early project to advance in the exploration of the user interface using a lean work flow. It is desirable but not always realistic that the resulting code shall follow the same architecture patterns and guides created for standard projects. Ideally, also the technology and used and the environment the technology is applied to shall be near a production. Making efforts to re-create a potential production environment ensures the outcome is somewhat comparable to a real scenario. For embedded devices it important also get as close as possible to the target setup by using a similar or even less powerful board and a similar display and input methods. Also the housing can be prototyped to allow a user to experience the UI in a near real setup scenario.","title":"Prototyping"},{"location":"topics/prototyping/#introduction","text":"What is the value of a user interface demonstrated on a high-end PC compared to the experience a user interface gives you in a comparable HW inside a setup comparable to the real HW where the user can explore the user interface? There needs always a balance between investment and revenue. If the revenue is high enough it is worthwhile going the extra mile to allow a potential user and stakeholders to experience the real device. During prototyping, you want to focus on the UX less on system creation. You want to be agile and move fast. The turnaround time of a solution might be just hours or days and you focus less on testing or completeness or even correctness. You feel okay to fake data or behavior when needed and use the real data when suitable. All of these decisions come with a cost, the prototyping software will never be your production software. The solution if carefully created might be used as a starting point for a product but seldom will evolve into a product. Often is is better and cheaper to start over again from the learning of the prototype code. Using a common architecture which is suited for prototyping and production increases the potential reuse and shortens time to market and the overall product creation costs. Todo Show a diagram which shows a product platform being used for UI exploration by using and extending services and by using and extending the UI layer. A carefully crafted production architecture should be flexible enough to be scaled from a prototyping phase into a production phase. It might require certain parts to be re-written as long as these parts are clearly marked and understood the effort and risk should be acceptable.","title":"Introduction"},{"location":"topics/prototyping/#architecture","text":"In an early prototyping architecture, you might want to skip the multi-process mode of AppMan as it removes the dependency to a Wayland setup. You still want to keep the SysUI/Application structure as it provides you a clean plan where to provide your QML components. Services should be written using QML/JS and mock the behavior of a real service. A service with static data can be purely written using a QML file. If more dynamic data is require a JSON reader plug-in of HTTP requests API can be used to request more data, e.g. from JSON files or a JSON web service. Using JSON as the underlying mock-data format makes it easy to convert it into the QML/JS data types. Also MQTT can be easily used to provide mock-data and behavior or any. An important aspect of the data source used it should be easily installable on different systems and the data must be easily create and changeable. Otherwise the idea of prototyping is not full-filled. Todo Draw a diagram which showcases a production setup and a prototyping setup where the services are using other technologies but the client APIs are in QML. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // service/counter/Counter.qml import http . requests 1.0 QtObject { id: root Requests { id: requests baseUrl: 'http://localhost:8888/api' } property var _state : ({ count: 0 }) readonly property int count: _state . count void increment () { requests . post ( 'increment' , function ( resp ) { _state = resp . data ; }); } void decrement () { requests . post ( 'decrement' , function ( resp ) { _state = resp . data ; }); } } The code snippet above uses a JSON rest API provided on local host, which on every call will return the full state of that interface. This makes the coding of the state update much easier. Your prototyping implementation might look completely different. A good technology to use could be the JSON server from NodeJS (see https://github.com/typicode/json-server ). Ideally, the resulting QML API can be easily consumed by the UI or the Stores. The API should hide which technology was used and only export the data and operations of the client API. By this, we can later change the implementation using a different technology and keep the UI from being cluttered with IPC calls. You would then use this mocked service client API as usual inside the RootStore. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // stores/RootStore.qml import services . counter 1.0 QtObject { id: root Counter { id: counter } property alias count: counter . count function up () { if ( count < 10 ) { counter . increment () } } function down () { if ( count > 0 ) { counter . decrement () } } } This code snippet looks a little bit superficial as nothing really happens here, but in a more complex UI, a client and a store both carry different aspects of logic. It is a good practice to separate this aspect. A client to adopt an IPC conversation to a QML API and the Store to ensure the UI is clean of business logic.","title":"Architecture"},{"location":"topics/prototyping/#reloading","text":"As the client API is now a QML part we can enable live-reloading on this part. No need to compile source code or deploy libraries. If a NodeJS server is used it also supports already live-reloading using the nodemon tool, which means our whole chain would be live re-loadable, which is one of the cornerstones for Rapid-UI-Prototyping. Live-reload everything! Enjoy!","title":"Reloading"},{"location":"topics/refactor/","text":"Micro - Refactorings Wexelblat's Scheduling Algorithm: Choose two: Good, Fast, Cheap Refactoring shall provide the reader with insights how to re-factor slowly an existing user interface architecture toward the CoreUI architecture by applying a series of micro-re-factorings. A micro-refactoring is a small rewrite of source code which fits mentally inside the developers head. This is important to ensure the developer is aware about any side-effects and can fix these before committing. We must avoid a large refactoring where the developer require days before the software is stable again. Ideally the software stays stable all the time during refactoring. Refactoring must be planned and executed over time. A larger user interface project can not be moved over night into a new direction, especially when many developer participate and still defects and features are on the road-map. To ensure the team has an understanding of the healthiness of the architecture certain KPI must be introduced and measured over time. Architecture KPIs A KPI (key performance indicator) provides high level insights about the healthiness of the software architecture. To understand the KPIs presented, we need to understand that the UI is a tree with a root node and edge nodes and many nodes in between. Ideally the outer nodes are clean from difficult dependencies, whereas the inner notes can depend on those dependencies but even here ideally these dependencies are extracted into another set of objects, the stores. In general, we have stores, views, panels and controls. The controls form the edge nodes of our UI tree. Right below the controls are the panels. The panels care the most UI load as they use semantic free controls to introduce application semantic. Below the panels, sit the views which bring together the UI surface. Views are part of the UI that depend on data providers which are the stores. The stores encapsulate the application business logic and interface to the platform services. Based on this description we can start to extract some KPIs. At first, we need to identify the complex dependencies. These are dependencies which make unit testing more painful. These harmful dependencies can be a module which uses a network service or a global object introducing global state or a rendering node which introduces certain hardware dependencies to the UI. We must ensure our goal to decompose the UI and unit test of each component must not be compromised. Info Ensure UI can be decomposed and run independent and the testability is guaranteed. KPI - Number of singletons used in edge nodes Measure the number of singletons used in edge nodes and above (2nd level edges). This number indicates how much these nodes depend on global state. This number should go down over time. KPI - Relation of kind of components count vs the classic component count This measures the relation between the identified and converted kind of components to the uncategorized components. The goal is to ensure over time the number of components with unmanaged dependencies are reduced and the converted components can be checked for harmful imports. KPI - Number of harmful imports per kind of component This counts the number of harmful imports per kind of component. Ideally the controls and panels will reduce the number of harmful components and most harmful imports will be isolated inside the stores. Micro Refactoring Cookbook Refactoring is a disciplined technique for restructuring an existing body of code, altering its internal structure without changing its external behavior. Its heart is a series of small behavior preserving transformations. Each transformation (called a \"refactoring\") does little, but a sequence of these transformations can produce a significant restructuring. Since each refactoring is small, it's less likely to go wrong. The system is kept fully working after each refactoring, reducing the chances that a system can get seriously broken during the restructuring. Martin Fowler ( https://refactoring.com ) Recipe: Stop leaking object internals from singletons A singleton which exposes an object, opens the opportunity for anyone to navigate to the object internals. By this, open up the opportunities to any kind of cross-dependencies. Take a look on the example below. Assume that there is a singleton which expose an object 1 2 3 4 // HelperSingleton.qml QtObject { property Item appWindow } The desired usage could be to allow others to control its window visibility. 1 2 3 4 5 6 7 // AppPanel.qml Panel { Button { text: \"Hide window\" onClicked: HelperSingleton . appWindow . visible = false } } But, it also allows others to expose the object in an evil way like an example below: 1 2 3 4 5 6 7 // EvilPanel.qml Panel { Button { text: \"Set Title of Window\" onClicked: HelperSingleton . appWindow . children [ 0 ]. text = \"A new title\" } } Now, the EvilPanel depends on the internal structure and even existence of internal UI types. And even worse, the developer of the AppWindow is not aware that someone is using the same API somewhere else. Hence, don't expose your object internals, and do not use other object's internals. The point is, the user of a singleton could now navigate to the parents of the window, just to fulfill a single requirement. anything could happen, can happen To close down this object's leakage, we need to investigate how the object is meant to be used. Often, we see pattern in the usage. The patterns then need to be extracted into a function, and the function would then navigate the object. 1 2 3 4 5 6 7 8 9 10 11 12 13 // HelperSingleton.qml - improved QtObject { - property Item appWindow + readonly property Item __appWindow + function hideWindow() { + __appWindow.visible = false + } + function setWindowTitle(title) { + __appWindow.setTitle(title) + } } And better panels 1 2 3 4 5 6 7 8 // AppPanel.qml - improved Panel { Button { text: \"Hide window\" - onClicked: HelperSingleton.appWindow.visible = false + onClicked: HelperSingleton.hideWindow() } } 1 2 3 4 5 6 7 8 // EvilPanel.qml - improved Panel { Button { text: \"Set Title of Window\" - onClicked: HelperSingleton.appWindow.children[0].text = \"A new title\" + onClicked: HelperSingleton.setWindowTitle(\"A new title\") } } Over time, we will be able to eliminate the object from the public interface and only allow users to use these functions. From now on, we can ensure there will be no new internals of this object will be leaked. And even better, we are now able to understand how users want to use the API. Additionally, by making the object's property become readonly will make sure that users will not be able to change the content of that object as well. Expose functions with meanings, not objects with internals Recipe: Push singletons up When investigating the usage of certain singletons, usually they are found in a related code area. It seems that developers are too lazy to pass in these dependencies and rather find a shortcut of the relations. Assuming that we have a panel which show a title and some content. The title shall present the current time and the content shall present the time but also be able to reset the current time. The parent application panel, which holds both children panels. 1 2 3 4 5 // AppPanel.qml Panel { TitlePanel {} ContentPanel {} } The title panel displays the current time. 1 2 3 4 5 6 7 8 // TitlePanel.qml import service . time 1.0 Panel { Label { text: Clock . currentTime } } The content panel will display the time and is allowed to reset the current time. 1 2 3 4 5 6 7 8 9 // ContentPanel.qml import service . time 1.0 Panel { Button { text: Clock . currentTime onClicked: Clock . resetTime () } } We can revert this by looking at the singleton usage in a component and move the usage up to the root level. 1 2 3 4 5 6 7 8 9 10 11 // TitlePanel.qml import service.time 1.0 Panel { id: root + property string currentTime: Clock.currentTime Label { - text: Clock.currentTime + text: root.currentTime } } The same way can be applied to content panel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // ContentPanel.qml import service.time 1.0 Panel { id: root + property string currentTime: Clock.currentTime + signal resetTime() + onResetTime: Clock.resetTime() Button { - text: Clock.currentTime + text: root.currentTime - onClicked: Clock.resetTime() + onClicked: root.resetTime() } } In the next step, we can then move the singleton onto the other side and pass it into the component. 1 2 3 4 5 6 7 8 9 10 11 12 // AppPanel.qml + import service.time 1.0 Panel { TitlePanel { + currentTime: Clock.currentTime } ContentPanel { + currentTime: Clock.currentTime + onResetTime: Clock.resetTime() } } Now, we can eliminate the usage of the singletons in the children. 1 2 3 4 5 6 7 8 9 10 // TitlePanel.qml - import service.time 1.0 Panel { id: root - property string currentTime: Clock.currentTime + property string currentTime Label { text: root.currentTime } } And similar to the content panel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ContentPanel.qml - import service.time 1.0 Panel { id: root - property string currentTime: Clock.currentTime + property string currentTime signal resetTime() - onResetTime: Clock.resetTime() Button { text: root.currentTime onClicked: root.resetTime() } } Be aware that we are now able to remove the dependency on the service.time module and by this making the TitlePanel and ContentPanel easier to test as dependencies are now injected instead of directly implemented inside. By doing this, we effectively push the singleton usage one level up. Normally, it is expected after several commits until we reach a level where several child components suddenly depend on the same information injected from the singleton. To effectively predict how many levels you need to push this dependency up, we would need to identify the node which creates the child nodes using the singleton. If we reach that point, there is no need for a singleton and we can convert the singleton into an instance of even eliminate it all together. Recipe: Eliminate singletons A singleton normally shares global state, functionality and events. To eliminate this we need to find the common ancestor node from where we can inject the dependencies. For a share event, we often can just connect the signal with a state change on that level, for shared properties we could do similar. For common functionality we can connect a signal which bubbles up to a function being executed. Ideally the function is extracted into a store if its application business relevant. So after we pushed the singleton up, we could now convert it to an instance, which acts like a small store. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // AppPanel.qml + import service.time 1.0 Panel { + Clock { + id: clock + } TitlePanel { - currentTime: Clock.currentTime + currentTime: clock.currentTime } ContentPanel { - currentTime: Clock.currentTime + currentTime: clock.currentTime - onResetTime: Clock.resetTime() + onResetTime: clock.resetTime() } } Now that we have an instance, we can in our tests create and destroy this instance. Also when this UI portion is destroyed, the service instance will also be destroyed and does not use any resources. To go a step forward we can even inject the service as a dependency. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // AppPanel.qml + import service.time 1.0 Panel { - Clock { - id: clock - } + property Clock clock : Clock { } TitlePanel { currentTime: clock.currentTime } ContentPanel { currentTime: clock.currentTime onResetTime: clock.resetTime() } } This allows use to configure the dependency of the AppPanel and with this make it better testable. Recipe: Extract harmful dependency conditions A harmful dependency is a dependency which breaks decomposition and testability by introducing (often indirect) not testable dependencies (e.g. network, hardware, global state). For this to be eliminated we need to push the dependency up, by first moving the dependency out of the internal of the component to the root level of the component and in a second step injecting the dependency into the component form the outside. By this practically removing the dependency from that particular component. The pattern is very similar to the removing a singleton refactoring. Assuming we have a station panel, which depends on a tuner service, to receive a list of stations and tune to the selected station. In the first instance the panel instantiates the service directly and by this introduces a dependency to the service as also makes it harder for testing. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // StationPanel.qml import service . radio 1.0 Panel { id: root TunerService { id: service } ListView { enabled: root . visible && service . on model: service . stations delegate: StationItem { title: model . name icon: model . icon onClicked: service . tune ( model . stationID ) } } } We use the same strategy as before to move the dependency to the root level, to be able in a later step to inject it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // StationPanel.qml import service . radio 1.0 Panel { id: root property TunerService service ListView { enabled: root . visible && root . service . on model: root . service . stations delegate: StationItem { title: model . name icon: model . icon onClicked: root . service . tune ( model . stationID ) } } } This step splits the dependency to the individual parts to be able to remove the service dependency and by this make this component more testable. Note We use the type Model which was registered as qmlRegisterUncreatableType to be able to define a object derived from QAbstractItemModel shall be used here. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // StationPanel.qml Panel { id: root property Model stations property bool on signal tune ( string stationID ) ListView { enabled: root . on model: root . stations delegate: StationItem { title: model . name icon: model . icon onClicked: root . tune ( model . stationID ) } } } Now we can use the panel from the outside and create the service one layer on top. As we saw in the singleton refactoring we then can introduce a store to wrap the service even further. 1 2 3 4 5 6 7 8 9 10 11 /// TunerView.qml View { StationService { id: service } StationPanel { stations: service . stations on: visible && service . on onTune: service . tune ( stationID ) } } Recipe: Convert Component to Kinds A kind of component is a component which fits into a category. For this the component needs to be moved to a kind folder where all components of the same kind and which similar dependencies are collected. Ideally you start with the edge nodes and convert them to controls or panels. We define initial the following components: Control , Panel , View , Store . You might decide that other kind of components are required, than these should be documented as with the purpose as also typical external dependencies. In short, a control is a reusable visual item, which is not application specific. A panel is a container of controls or other panels. A view depends on a store and contains other panels or views. A store is a logical object, which can contain child stores. Based on this, we need to create a set of folders and start sorting these components into the kind folders. 1 2 3 4 5 controls/ panels/ views/ stores/ Main.qml It is advisable only to move a component into the kind folder after it has been cleaned up. Ideally you start with controls first and then panels, then views and stores. The strategy is to work from the UI tree from the edges towards the internal nodes. Note Be sure to only move components which follow the dependency guidelines, otherwise it is better to first eliminate of push up the harmful dependencies before moving the component. Recipe: Extract a Store After pushing conditions up to the root level of the current component sometimes it is a good practice to collect them into an object. So the object gets injected into this component. This component is the first version of a potential store. This object then collects these dependencies and will carry the harmful dependencies. The component itself will only depend on this particular object (aka store). This makes it also easier to push dependencies up the UI tree as we only have to push the object up not individual properties. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // AppPanel.qml import service . time 1.0 Panel { id: root property Clock clock : Clock { } property string stationName TitlePanel { title: root . stationName currentTime: clock . currentTime } ContentPanel { currentTime: clock . currentTime onResetTime: clock . resetTime () } } Step: name space your dependency We create a new object called AppStore. This object shall wrap the dependencies. 1 2 3 4 5 6 + // AppStore.qml + import service.time 1.0 + + Store { + property Clock clock: Clock {} + } Now we can replace the direct dependencies with indirect dependencies using the new used store object. So practically name spacing the dependencies. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // AppPanel.qml - import service.time 1.0 Panel { id: root - property Clock clock : Clock { } + property AppStore store: AppStore {} property string stationName TitlePanel { title: root.stationName - currentTime: clock.currentTime + currentTime: store.clock.currentTime } ContentPanel { + currentTime: clock.currentTime + currentTime: store.clock.currentTime - onResetTime: clock.resetTime() + onResetTime: store.clock.resetTime() } } In the next step this will allow us now to do the trick and remove the dependencies from our panels. Step: Prevent object leaking We still have a problem in the store, we leak an object and the internals of the object can be discovered. We could prevent it by hiding the object behind the store interface. 1 2 3 4 5 6 7 8 9 10 11 12 // AppStore.qml import service.time 1.0 Store { - property Clock clock: Clock {} + property Clock __clock: Clock {} + property string currentTime: __clock.currentTime + function resetTime() { + __clock.resetTime() + } } This will change our panel in a way that it only depends on properties, signals or functions of the store and the store is able to conceal its internals. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // AppPanel.qml Panel { id: root property AppStore store: AppStore {} property string stationName TitlePanel { title: root.stationName - currentTime: store.clock.currentTime + currentTime: store.currentTime } ContentPanel { - currentTime: store.clock.currentTime + currentTime: store.clock.currentTime - onResetTime: store.clock.resetTime() + onResetTime: store.clock.resetTime() } } Step: extract data interface into a data object Now we can also add the remaining station name, which might come from another service. The relevant part is it is not a visual property it is a data property, and as such should be contained inside the data store. 1 2 3 4 5 6 7 // AppStore.qml import service.time 1.0 Store { property Clock clock: Clock {} + property string stationName } Now the panel does not use the name property anymore it gets the information from the store. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // AppPanel.qml Panel { id: root - property AppStore store: AppStore {} + property AppStore store: AppStore { + stationName: root.stationName + } property string stationName TitlePanel { - title: root.stationName + title: store.stationName currentTime: store.clock.currentTime } ContentPanel { currentTime: store.clock.currentTime onResetTime: store.clock.resetTime() } } On the first sight this seems to make thing more complicated. But think about, we want to inject dependency. So we want to make it the duty of the instance which instantiates us to think about where the data comes from. As the panel does now solely depend on the store for its data, testing the panel also now gets much more easier as also passing on the data between parts its now easier. To test now the business side, we can simple test the none visual store. Step: inject store So this allows us now to inject the store as dependency and make our dependency much more clearer. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // AppPanel.qml // import service.time 1.0 Panel { id: root - property AppStore store: AppStore { - stationName: root.stationName - } - property string stationName + property AppStore store TitlePanel { title: store.stationName currentTime: store.clock.currentTime } ContentPanel { currentTime: store.clock.currentTime onResetTime: store.clock.resetTime() } } We would call this component now a View (from View in Model-View-ViewModel pattern), as it depends on a store. A panels just depend on data properties, a view on a store. 1 2 3 4 5 6 7 8 9 - // AppPanel.qml + // AppView.qml - Panel { + View { id: root property AppStore store ... } Maybe our AppPanel is called by a Main item, this would be the change there. 1 2 3 4 5 6 7 8 9 10 11 // Main.qml Item { width: 800 height: 600 AppPanel { - stationName: 'Last Station' + store: AppStore { + stationName: 'Last Station' + } } } Conclusion Injecting dependencies, means roughly: make it the problem of the object calling you. When looking back we have now a set of nice to test components and clear idea where the data comes from. 1 2 3 4 5 6 7 8 9 10 // Main.qml Item { width: 800 height: 600 AppPanel { store: AppStore { stationName: 'Last Station' } } } 1 2 3 4 5 6 7 8 9 10 11 // AppStore.qml import service . time 1.0 Store { property Clock __clock : Clock {} property string stationName property string currentTime: __clock . currentTime function resetTime () { return __clock . resetTime () } } 1 2 3 4 5 6 7 8 9 10 11 12 13 // AppView.qml View { id: root property AppStore store TitlePanel { title: store . stationName currentTime: store . currentTime } ContentPanel { currentTime: store . currentTime onResetTime: store . resetTime () } } 1 2 3 4 5 6 7 8 9 10 11 // ContentPanel.qml Panel { id: root property string currentTime signal resetTime () Button { text: root . currentTime onClicked: root . resetTime () } } 1 2 3 4 5 6 7 8 // TitlePanel.qml Panel { id: root property string currentTime Label { text: root . currentTime } }","title":"Refactoring"},{"location":"topics/refactor/#micro-refactorings","text":"Wexelblat's Scheduling Algorithm: Choose two: Good, Fast, Cheap Refactoring shall provide the reader with insights how to re-factor slowly an existing user interface architecture toward the CoreUI architecture by applying a series of micro-re-factorings. A micro-refactoring is a small rewrite of source code which fits mentally inside the developers head. This is important to ensure the developer is aware about any side-effects and can fix these before committing. We must avoid a large refactoring where the developer require days before the software is stable again. Ideally the software stays stable all the time during refactoring. Refactoring must be planned and executed over time. A larger user interface project can not be moved over night into a new direction, especially when many developer participate and still defects and features are on the road-map. To ensure the team has an understanding of the healthiness of the architecture certain KPI must be introduced and measured over time.","title":"Micro - Refactorings"},{"location":"topics/refactor/#architecture-kpis","text":"A KPI (key performance indicator) provides high level insights about the healthiness of the software architecture. To understand the KPIs presented, we need to understand that the UI is a tree with a root node and edge nodes and many nodes in between. Ideally the outer nodes are clean from difficult dependencies, whereas the inner notes can depend on those dependencies but even here ideally these dependencies are extracted into another set of objects, the stores. In general, we have stores, views, panels and controls. The controls form the edge nodes of our UI tree. Right below the controls are the panels. The panels care the most UI load as they use semantic free controls to introduce application semantic. Below the panels, sit the views which bring together the UI surface. Views are part of the UI that depend on data providers which are the stores. The stores encapsulate the application business logic and interface to the platform services. Based on this description we can start to extract some KPIs. At first, we need to identify the complex dependencies. These are dependencies which make unit testing more painful. These harmful dependencies can be a module which uses a network service or a global object introducing global state or a rendering node which introduces certain hardware dependencies to the UI. We must ensure our goal to decompose the UI and unit test of each component must not be compromised. Info Ensure UI can be decomposed and run independent and the testability is guaranteed.","title":"Architecture KPIs"},{"location":"topics/refactor/#kpi-number-of-singletons-used-in-edge-nodes","text":"Measure the number of singletons used in edge nodes and above (2nd level edges). This number indicates how much these nodes depend on global state. This number should go down over time.","title":"KPI - Number of singletons used in edge nodes"},{"location":"topics/refactor/#kpi-relation-of-kind-of-components-count-vs-the-classic-component-count","text":"This measures the relation between the identified and converted kind of components to the uncategorized components. The goal is to ensure over time the number of components with unmanaged dependencies are reduced and the converted components can be checked for harmful imports.","title":"KPI - Relation of kind of components count vs the classic component count"},{"location":"topics/refactor/#kpi-number-of-harmful-imports-per-kind-of-component","text":"This counts the number of harmful imports per kind of component. Ideally the controls and panels will reduce the number of harmful components and most harmful imports will be isolated inside the stores.","title":"KPI - Number of harmful imports per kind of component"},{"location":"topics/refactor/#micro-refactoring-cookbook","text":"Refactoring is a disciplined technique for restructuring an existing body of code, altering its internal structure without changing its external behavior. Its heart is a series of small behavior preserving transformations. Each transformation (called a \"refactoring\") does little, but a sequence of these transformations can produce a significant restructuring. Since each refactoring is small, it's less likely to go wrong. The system is kept fully working after each refactoring, reducing the chances that a system can get seriously broken during the restructuring. Martin Fowler ( https://refactoring.com )","title":"Micro Refactoring Cookbook"},{"location":"topics/refactor/#recipe-stop-leaking-object-internals-from-singletons","text":"A singleton which exposes an object, opens the opportunity for anyone to navigate to the object internals. By this, open up the opportunities to any kind of cross-dependencies. Take a look on the example below. Assume that there is a singleton which expose an object 1 2 3 4 // HelperSingleton.qml QtObject { property Item appWindow } The desired usage could be to allow others to control its window visibility. 1 2 3 4 5 6 7 // AppPanel.qml Panel { Button { text: \"Hide window\" onClicked: HelperSingleton . appWindow . visible = false } } But, it also allows others to expose the object in an evil way like an example below: 1 2 3 4 5 6 7 // EvilPanel.qml Panel { Button { text: \"Set Title of Window\" onClicked: HelperSingleton . appWindow . children [ 0 ]. text = \"A new title\" } } Now, the EvilPanel depends on the internal structure and even existence of internal UI types. And even worse, the developer of the AppWindow is not aware that someone is using the same API somewhere else. Hence, don't expose your object internals, and do not use other object's internals. The point is, the user of a singleton could now navigate to the parents of the window, just to fulfill a single requirement. anything could happen, can happen To close down this object's leakage, we need to investigate how the object is meant to be used. Often, we see pattern in the usage. The patterns then need to be extracted into a function, and the function would then navigate the object. 1 2 3 4 5 6 7 8 9 10 11 12 13 // HelperSingleton.qml - improved QtObject { - property Item appWindow + readonly property Item __appWindow + function hideWindow() { + __appWindow.visible = false + } + function setWindowTitle(title) { + __appWindow.setTitle(title) + } } And better panels 1 2 3 4 5 6 7 8 // AppPanel.qml - improved Panel { Button { text: \"Hide window\" - onClicked: HelperSingleton.appWindow.visible = false + onClicked: HelperSingleton.hideWindow() } } 1 2 3 4 5 6 7 8 // EvilPanel.qml - improved Panel { Button { text: \"Set Title of Window\" - onClicked: HelperSingleton.appWindow.children[0].text = \"A new title\" + onClicked: HelperSingleton.setWindowTitle(\"A new title\") } } Over time, we will be able to eliminate the object from the public interface and only allow users to use these functions. From now on, we can ensure there will be no new internals of this object will be leaked. And even better, we are now able to understand how users want to use the API. Additionally, by making the object's property become readonly will make sure that users will not be able to change the content of that object as well. Expose functions with meanings, not objects with internals","title":"Recipe: Stop leaking object internals from singletons"},{"location":"topics/refactor/#recipe-push-singletons-up","text":"When investigating the usage of certain singletons, usually they are found in a related code area. It seems that developers are too lazy to pass in these dependencies and rather find a shortcut of the relations. Assuming that we have a panel which show a title and some content. The title shall present the current time and the content shall present the time but also be able to reset the current time. The parent application panel, which holds both children panels. 1 2 3 4 5 // AppPanel.qml Panel { TitlePanel {} ContentPanel {} } The title panel displays the current time. 1 2 3 4 5 6 7 8 // TitlePanel.qml import service . time 1.0 Panel { Label { text: Clock . currentTime } } The content panel will display the time and is allowed to reset the current time. 1 2 3 4 5 6 7 8 9 // ContentPanel.qml import service . time 1.0 Panel { Button { text: Clock . currentTime onClicked: Clock . resetTime () } } We can revert this by looking at the singleton usage in a component and move the usage up to the root level. 1 2 3 4 5 6 7 8 9 10 11 // TitlePanel.qml import service.time 1.0 Panel { id: root + property string currentTime: Clock.currentTime Label { - text: Clock.currentTime + text: root.currentTime } } The same way can be applied to content panel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // ContentPanel.qml import service.time 1.0 Panel { id: root + property string currentTime: Clock.currentTime + signal resetTime() + onResetTime: Clock.resetTime() Button { - text: Clock.currentTime + text: root.currentTime - onClicked: Clock.resetTime() + onClicked: root.resetTime() } } In the next step, we can then move the singleton onto the other side and pass it into the component. 1 2 3 4 5 6 7 8 9 10 11 12 // AppPanel.qml + import service.time 1.0 Panel { TitlePanel { + currentTime: Clock.currentTime } ContentPanel { + currentTime: Clock.currentTime + onResetTime: Clock.resetTime() } } Now, we can eliminate the usage of the singletons in the children. 1 2 3 4 5 6 7 8 9 10 // TitlePanel.qml - import service.time 1.0 Panel { id: root - property string currentTime: Clock.currentTime + property string currentTime Label { text: root.currentTime } } And similar to the content panel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ContentPanel.qml - import service.time 1.0 Panel { id: root - property string currentTime: Clock.currentTime + property string currentTime signal resetTime() - onResetTime: Clock.resetTime() Button { text: root.currentTime onClicked: root.resetTime() } } Be aware that we are now able to remove the dependency on the service.time module and by this making the TitlePanel and ContentPanel easier to test as dependencies are now injected instead of directly implemented inside. By doing this, we effectively push the singleton usage one level up. Normally, it is expected after several commits until we reach a level where several child components suddenly depend on the same information injected from the singleton. To effectively predict how many levels you need to push this dependency up, we would need to identify the node which creates the child nodes using the singleton. If we reach that point, there is no need for a singleton and we can convert the singleton into an instance of even eliminate it all together.","title":"Recipe: Push singletons up"},{"location":"topics/refactor/#recipe-eliminate-singletons","text":"A singleton normally shares global state, functionality and events. To eliminate this we need to find the common ancestor node from where we can inject the dependencies. For a share event, we often can just connect the signal with a state change on that level, for shared properties we could do similar. For common functionality we can connect a signal which bubbles up to a function being executed. Ideally the function is extracted into a store if its application business relevant. So after we pushed the singleton up, we could now convert it to an instance, which acts like a small store. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // AppPanel.qml + import service.time 1.0 Panel { + Clock { + id: clock + } TitlePanel { - currentTime: Clock.currentTime + currentTime: clock.currentTime } ContentPanel { - currentTime: Clock.currentTime + currentTime: clock.currentTime - onResetTime: Clock.resetTime() + onResetTime: clock.resetTime() } } Now that we have an instance, we can in our tests create and destroy this instance. Also when this UI portion is destroyed, the service instance will also be destroyed and does not use any resources. To go a step forward we can even inject the service as a dependency. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // AppPanel.qml + import service.time 1.0 Panel { - Clock { - id: clock - } + property Clock clock : Clock { } TitlePanel { currentTime: clock.currentTime } ContentPanel { currentTime: clock.currentTime onResetTime: clock.resetTime() } } This allows use to configure the dependency of the AppPanel and with this make it better testable.","title":"Recipe: Eliminate singletons"},{"location":"topics/refactor/#recipe-extract-harmful-dependency-conditions","text":"A harmful dependency is a dependency which breaks decomposition and testability by introducing (often indirect) not testable dependencies (e.g. network, hardware, global state). For this to be eliminated we need to push the dependency up, by first moving the dependency out of the internal of the component to the root level of the component and in a second step injecting the dependency into the component form the outside. By this practically removing the dependency from that particular component. The pattern is very similar to the removing a singleton refactoring. Assuming we have a station panel, which depends on a tuner service, to receive a list of stations and tune to the selected station. In the first instance the panel instantiates the service directly and by this introduces a dependency to the service as also makes it harder for testing. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // StationPanel.qml import service . radio 1.0 Panel { id: root TunerService { id: service } ListView { enabled: root . visible && service . on model: service . stations delegate: StationItem { title: model . name icon: model . icon onClicked: service . tune ( model . stationID ) } } } We use the same strategy as before to move the dependency to the root level, to be able in a later step to inject it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // StationPanel.qml import service . radio 1.0 Panel { id: root property TunerService service ListView { enabled: root . visible && root . service . on model: root . service . stations delegate: StationItem { title: model . name icon: model . icon onClicked: root . service . tune ( model . stationID ) } } } This step splits the dependency to the individual parts to be able to remove the service dependency and by this make this component more testable. Note We use the type Model which was registered as qmlRegisterUncreatableType to be able to define a object derived from QAbstractItemModel shall be used here. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // StationPanel.qml Panel { id: root property Model stations property bool on signal tune ( string stationID ) ListView { enabled: root . on model: root . stations delegate: StationItem { title: model . name icon: model . icon onClicked: root . tune ( model . stationID ) } } } Now we can use the panel from the outside and create the service one layer on top. As we saw in the singleton refactoring we then can introduce a store to wrap the service even further. 1 2 3 4 5 6 7 8 9 10 11 /// TunerView.qml View { StationService { id: service } StationPanel { stations: service . stations on: visible && service . on onTune: service . tune ( stationID ) } }","title":"Recipe: Extract harmful dependency conditions"},{"location":"topics/refactor/#recipe-convert-component-to-kinds","text":"A kind of component is a component which fits into a category. For this the component needs to be moved to a kind folder where all components of the same kind and which similar dependencies are collected. Ideally you start with the edge nodes and convert them to controls or panels. We define initial the following components: Control , Panel , View , Store . You might decide that other kind of components are required, than these should be documented as with the purpose as also typical external dependencies. In short, a control is a reusable visual item, which is not application specific. A panel is a container of controls or other panels. A view depends on a store and contains other panels or views. A store is a logical object, which can contain child stores. Based on this, we need to create a set of folders and start sorting these components into the kind folders. 1 2 3 4 5 controls/ panels/ views/ stores/ Main.qml It is advisable only to move a component into the kind folder after it has been cleaned up. Ideally you start with controls first and then panels, then views and stores. The strategy is to work from the UI tree from the edges towards the internal nodes. Note Be sure to only move components which follow the dependency guidelines, otherwise it is better to first eliminate of push up the harmful dependencies before moving the component.","title":"Recipe: Convert Component to Kinds"},{"location":"topics/refactor/#recipe-extract-a-store","text":"After pushing conditions up to the root level of the current component sometimes it is a good practice to collect them into an object. So the object gets injected into this component. This component is the first version of a potential store. This object then collects these dependencies and will carry the harmful dependencies. The component itself will only depend on this particular object (aka store). This makes it also easier to push dependencies up the UI tree as we only have to push the object up not individual properties. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // AppPanel.qml import service . time 1.0 Panel { id: root property Clock clock : Clock { } property string stationName TitlePanel { title: root . stationName currentTime: clock . currentTime } ContentPanel { currentTime: clock . currentTime onResetTime: clock . resetTime () } } Step: name space your dependency We create a new object called AppStore. This object shall wrap the dependencies. 1 2 3 4 5 6 + // AppStore.qml + import service.time 1.0 + + Store { + property Clock clock: Clock {} + } Now we can replace the direct dependencies with indirect dependencies using the new used store object. So practically name spacing the dependencies. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // AppPanel.qml - import service.time 1.0 Panel { id: root - property Clock clock : Clock { } + property AppStore store: AppStore {} property string stationName TitlePanel { title: root.stationName - currentTime: clock.currentTime + currentTime: store.clock.currentTime } ContentPanel { + currentTime: clock.currentTime + currentTime: store.clock.currentTime - onResetTime: clock.resetTime() + onResetTime: store.clock.resetTime() } } In the next step this will allow us now to do the trick and remove the dependencies from our panels. Step: Prevent object leaking We still have a problem in the store, we leak an object and the internals of the object can be discovered. We could prevent it by hiding the object behind the store interface. 1 2 3 4 5 6 7 8 9 10 11 12 // AppStore.qml import service.time 1.0 Store { - property Clock clock: Clock {} + property Clock __clock: Clock {} + property string currentTime: __clock.currentTime + function resetTime() { + __clock.resetTime() + } } This will change our panel in a way that it only depends on properties, signals or functions of the store and the store is able to conceal its internals. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // AppPanel.qml Panel { id: root property AppStore store: AppStore {} property string stationName TitlePanel { title: root.stationName - currentTime: store.clock.currentTime + currentTime: store.currentTime } ContentPanel { - currentTime: store.clock.currentTime + currentTime: store.clock.currentTime - onResetTime: store.clock.resetTime() + onResetTime: store.clock.resetTime() } } Step: extract data interface into a data object Now we can also add the remaining station name, which might come from another service. The relevant part is it is not a visual property it is a data property, and as such should be contained inside the data store. 1 2 3 4 5 6 7 // AppStore.qml import service.time 1.0 Store { property Clock clock: Clock {} + property string stationName } Now the panel does not use the name property anymore it gets the information from the store. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // AppPanel.qml Panel { id: root - property AppStore store: AppStore {} + property AppStore store: AppStore { + stationName: root.stationName + } property string stationName TitlePanel { - title: root.stationName + title: store.stationName currentTime: store.clock.currentTime } ContentPanel { currentTime: store.clock.currentTime onResetTime: store.clock.resetTime() } } On the first sight this seems to make thing more complicated. But think about, we want to inject dependency. So we want to make it the duty of the instance which instantiates us to think about where the data comes from. As the panel does now solely depend on the store for its data, testing the panel also now gets much more easier as also passing on the data between parts its now easier. To test now the business side, we can simple test the none visual store. Step: inject store So this allows us now to inject the store as dependency and make our dependency much more clearer. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // AppPanel.qml // import service.time 1.0 Panel { id: root - property AppStore store: AppStore { - stationName: root.stationName - } - property string stationName + property AppStore store TitlePanel { title: store.stationName currentTime: store.clock.currentTime } ContentPanel { currentTime: store.clock.currentTime onResetTime: store.clock.resetTime() } } We would call this component now a View (from View in Model-View-ViewModel pattern), as it depends on a store. A panels just depend on data properties, a view on a store. 1 2 3 4 5 6 7 8 9 - // AppPanel.qml + // AppView.qml - Panel { + View { id: root property AppStore store ... } Maybe our AppPanel is called by a Main item, this would be the change there. 1 2 3 4 5 6 7 8 9 10 11 // Main.qml Item { width: 800 height: 600 AppPanel { - stationName: 'Last Station' + store: AppStore { + stationName: 'Last Station' + } } }","title":"Recipe: Extract a Store"},{"location":"topics/refactor/#conclusion","text":"Injecting dependencies, means roughly: make it the problem of the object calling you. When looking back we have now a set of nice to test components and clear idea where the data comes from. 1 2 3 4 5 6 7 8 9 10 // Main.qml Item { width: 800 height: 600 AppPanel { store: AppStore { stationName: 'Last Station' } } } 1 2 3 4 5 6 7 8 9 10 11 // AppStore.qml import service . time 1.0 Store { property Clock __clock : Clock {} property string stationName property string currentTime: __clock . currentTime function resetTime () { return __clock . resetTime () } } 1 2 3 4 5 6 7 8 9 10 11 12 13 // AppView.qml View { id: root property AppStore store TitlePanel { title: store . stationName currentTime: store . currentTime } ContentPanel { currentTime: store . currentTime onResetTime: store . resetTime () } } 1 2 3 4 5 6 7 8 9 10 11 // ContentPanel.qml Panel { id: root property string currentTime signal resetTime () Button { text: root . currentTime onClicked: root . resetTime () } } 1 2 3 4 5 6 7 8 // TitlePanel.qml Panel { id: root property string currentTime Label { text: root . currentTime } }","title":"Conclusion"},{"location":"topics/reload/","text":"Live Reloading Reloading or live reloading is the process where a user interface is changed by the developer and instead of restarting the user interface process it is possible just to reload the content. This can go manually, e.g. by pressing a assigned key shortcut or automatically by detecting the change. Reloading is possible as QML as the underlying user interface description language is a scripting language and not a compiled language, such as C++. The mechanics of reloading are fundamentally very simple detect change (manual / automatic) clear component cache reset current document onto qml engine Let's assume a we detect the changes manually and bind a shortcut to the F5 key. TODO: Add header only reload class 1 2 3 4 5 6 7 8 int main ( int argc , char ** argv ) { QGuiApplication app ( argc , argv ); a ... tbd shortcut = QShortcut ( QKeySequence ( \"F5\" ), return app . exec () } Auto Reloading To enable auto reloading the engine needs to detect the change in the underlying source code. For this we need to watch file system changes using QFileSystemWatcher . Info The underlying OS imposes often restrictions about how many files can be watched, to not hit these restrictions to early we will not warch files but folder changes. This is possible as modern editors have atomic writes. Atomic writes ensures that at any time the write operation can be reverted. This is done by a series of create/rename/delete operations. Pure file writes are not detected by the OS as directory changes but the creation and deletion of files are and this is where we listen on. To not flood the UI with reload messages by hundred of files creation, there is a deleay timer of e.g. 100ms before a reload is triggered. To watcher needs a set of initial directories which it will traverse and each directory will be added to the list of directories to be watched. There should be an exclude filter to exclude directories from being watched. When a change is detected the watcher restarts the delay timer. And when the delayh time is triggered it simply emits a change signal. Onto this change signak we can then connect our reload action. TODO: Add watcher class to trigger reload !!! note State preserving or state resetting That is the question! Practical Implications How best to apply reloading Which impact has reloading on architecture Advanced reloading use cases Pitfalls There are several aspects which often can disable live reloading due to crashing or sheer complexity in the underlying QML engine. During livereload a large amount of Qt objects are deleted and then newly created. Any referenced null pointers will crash the engine when the UI tree is destructed. This is normally not a problem of the engine but a clear indication that there are places where Qt objects are passed back and force between C++ and QML without clear checks and ownership. As a general advice: Just do not pass dynamic objects back and forth between QML and C++ and do not be fancy when creating a QML/C++ API. Predictability on the API user perspective outweights any smartness. Boring is good! Another reason that reloading might not work is when the code is too complex, interwined or based on a previuos state in the UI that reloading does takes seconds. Reloading always should be fluent which we define as below 1 seconds (reload <1s). Otherwise it is better to break up the UI and reload a partial UI. This requires the architecture and component design supports reloading of individual components.","title":"(Live) Reloading"},{"location":"topics/reload/#live-reloading","text":"Reloading or live reloading is the process where a user interface is changed by the developer and instead of restarting the user interface process it is possible just to reload the content. This can go manually, e.g. by pressing a assigned key shortcut or automatically by detecting the change. Reloading is possible as QML as the underlying user interface description language is a scripting language and not a compiled language, such as C++. The mechanics of reloading are fundamentally very simple detect change (manual / automatic) clear component cache reset current document onto qml engine Let's assume a we detect the changes manually and bind a shortcut to the F5 key. TODO: Add header only reload class 1 2 3 4 5 6 7 8 int main ( int argc , char ** argv ) { QGuiApplication app ( argc , argv ); a ... tbd shortcut = QShortcut ( QKeySequence ( \"F5\" ), return app . exec () }","title":"Live Reloading"},{"location":"topics/reload/#auto-reloading","text":"To enable auto reloading the engine needs to detect the change in the underlying source code. For this we need to watch file system changes using QFileSystemWatcher . Info The underlying OS imposes often restrictions about how many files can be watched, to not hit these restrictions to early we will not warch files but folder changes. This is possible as modern editors have atomic writes. Atomic writes ensures that at any time the write operation can be reverted. This is done by a series of create/rename/delete operations. Pure file writes are not detected by the OS as directory changes but the creation and deletion of files are and this is where we listen on. To not flood the UI with reload messages by hundred of files creation, there is a deleay timer of e.g. 100ms before a reload is triggered. To watcher needs a set of initial directories which it will traverse and each directory will be added to the list of directories to be watched. There should be an exclude filter to exclude directories from being watched. When a change is detected the watcher restarts the delay timer. And when the delayh time is triggered it simply emits a change signal. Onto this change signak we can then connect our reload action. TODO: Add watcher class to trigger reload !!! note","title":"Auto Reloading"},{"location":"topics/reload/#state-preserving-or-state-resetting","text":"That is the question!","title":"State preserving or state resetting"},{"location":"topics/reload/#practical-implications","text":"How best to apply reloading Which impact has reloading on architecture Advanced reloading use cases","title":"Practical Implications"},{"location":"topics/reload/#pitfalls","text":"There are several aspects which often can disable live reloading due to crashing or sheer complexity in the underlying QML engine. During livereload a large amount of Qt objects are deleted and then newly created. Any referenced null pointers will crash the engine when the UI tree is destructed. This is normally not a problem of the engine but a clear indication that there are places where Qt objects are passed back and force between C++ and QML without clear checks and ownership. As a general advice: Just do not pass dynamic objects back and forth between QML and C++ and do not be fancy when creating a QML/C++ API. Predictability on the API user perspective outweights any smartness. Boring is good! Another reason that reloading might not work is when the code is too complex, interwined or based on a previuos state in the UI that reloading does takes seconds. Reloading always should be fluent which we define as below 1 seconds (reload <1s). Otherwise it is better to break up the UI and reload a partial UI. This requires the architecture and component design supports reloading of individual components.","title":"Pitfalls"},{"location":"topics/runtime/","text":"Runtime & Modules Craziness is doing the same thing and expecting a different result. -- Einstein The QML runtime used in the CoreUI architecture is Qt Application Manager. Which is designed to provide a multi-process architecture, where each application runs in an own process, started by its own runtime. Engine A runtime is just a small C++ application starting the JS engine and QML engine and loading the initial qml document. 1 2 3 4 5 6 7 8 9 #include <QGuiApplication> #include <QQmlApplicationEngine> int main ( int argc , char * argv []) { QGuiApplication app ( argc , argv ); QQmlApplicationEngine engine ( \"main.qml\" ); return app . exec (); } The QML application engine in the background handles the quit signal, loads translations, handles windows correctly and setups a QML file selector. Note If you look for more inspiration how to write a custom runtime check out $QTSRC/qtdeclarative/tools/qmlscene . This runtime provides also command line parsing, import path configuration, etc... The Qt Application Manager is more complex as contains a lot more features, configuration capabilities and security mechanisms as also support for launching other runtimes in separate processes and watching over them. Plugin Extensions A runtime is extended using QtQuick plugins. A plugin is a defined C++ interface to be implemented and the plugin library needs to placed in a defined folder structure with a small description file the qmldir . Qt Creator contains a wizard to create a plugin. The CoreUI admin also has a generator, which fits the plugin into the existing native project. When build and installed, te runtime will load the plugin when the module import is the first time requested by a QML document. By this we can control the loading of plugins by ensuring the module is only loaded when required. The runtime lookups the QML import declaration in the import paths and when detected loads the corresponding plugin library. The plugin declares a set of QML types which are then registered into the module namespace and made available to the QML engine. Like below code which provides the interface vor the plugin to register the QML types. 1 2 3 4 5 6 7 8 9 10 11 12 13 // plugin.h #pragma once #include <QtQml> class AlarmPlugin : public QQmlExtensionPlugin { Q_OBJECT Q_PLUGIN_METADATA ( IID QQmlExtensionInterface_iid ) public : void registerTypes ( const char * uri ) override ; }; A type is registered using one of the qmlRegister... template methods. By this this object is now accessible under the import URL with the type name in QML. 1 2 3 4 5 6 7 8 9 #include \"plugin.h\" #include \"teatimer.h\" void TeaTimerPlugin :: registerTypes ( const char * uri ) { Q_ASSERT ( uri == QLatin1String ( \"Tea\" )); qmlRegisterType < TeaTimer > ( uri , 1 , 0 , \"TeaTimer\" ); } The object registered can be either a visual type inheriting from QtQuickItem or a business type , inheriting from QObject . If the type shall take part of the rendering than it must inherit from QQuickItem . Our example is a tea timer, which allows the user to set a duration and the time triggers a signal when the timer is done. The tea timer is a standard object with properties and signals. Additionally Q_INVOKABLE is used to make the method available to QML. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #pragma once #include <QtCore> class TeaTimer : public QObject { Q_OBJECT QPROPERTY ( int currentTime READ currentTime NOTIFY currentTimeChanged ) Q_INVOKABLE void set ( int min , int sec ); Q_INVOKABLE void start (); Q_INVOKABLE void stop (); int currentTime () const ; void setCurrentTime ( int currentTime ); private : void handleTick (); signals : void currentTimeChanged (); void ring (); private : QTimer * m_timer ; int m_currentTime ; int m_duration ; }; For the implementation the tea timer uses a QTimer which timeouts every 100msecs to forward the current time and when the duration is reached it rings. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // teatimer.cpp #include \"teatimer.h\" TeaTimer :: TeaTimer ( QObject * parent ) : QObject ( parent ) , m_timer ( new QTimer ( this )) , m_currentTime ( 0 ) { connect ( m_timer , & QTimer :: timeout , this , & TeaTimer :: handleTick ); m_timer -> setInterval ( 100 ); // 100 msecs } void TeaTimer :: set ( int min , int sec ) { stop (); m_duration = ( min * 60 + sec ) * 1000 ); } void TeaTimer :: start () { m_timer - start (); } void TeaTimer :: stop () { m_timer - stop (); setCurrentTime ( 0 ); } void TeaTimer :: handleTick () { setCurrentTime ( currentTime () + m_timer -> interval ()); } int TeaTimer :: currentTime () const { return m_currentTime ; } void setCurrentTime ( int currentTime ) { if ( m_currentTime == currentTime ) { return ; } m_currentTime = msec ; emit currentTimeChanged (); if ( m_currentTime >= m_duration ) { stop (); emit ring (); } } We can now use the tea timer inside our QML code through importing the tea module and instantiating the TeaTimer object. 1 2 3 4 5 6 7 8 import Tea 1.0 MainWindow { id: root TeaTimer { duration: 2 * TeaTimer . Minutes } } Object Patterns Instances vs Singletons QML also allows to register singletons. They are instantiated when the first time the module is imported. The problem with them are they are never destroyed and also they can be used anywhere in your code. Sounds great on first hand, but these singletons are tricky as they introduce dependencies which makes it hard to test these QML components. Ideally you try to avoid singletons wherever you can and use the dependency injections (aka configurable dependencies) to pass on instances of logic object into QML. This is a bad example of using a tea timer type, by registering the type as singleton and using it inside a panel. Now it is very difficult to test this component. 1 2 3 4 5 6 // TeaPanel Panel { Label { text: TeaTimer . currentTime } } This is better, we have the incoming dependency under control. 1 2 3 4 5 6 7 // TeaPanel Panel { property TeaTimer teaTimer Label { text: teaTimer . currentTime } } Even better, avoid the dependency on the type at all 1 2 3 4 5 6 7 8 // TeaPanel.qml Panel { id: root property int currentTime Label { text: root . currentTime } } Delayed Init Also when using instances we need to ensure the instantiation goes fast as this directly relates to the UI startup. Which means the constructor must be slim. Any longer startup (e.g. pinging a server) should be done using a delayed init call. 1 2 3 4 5 6 7 8 9 10 TeaTimer :: TeaTimer ( QObject * parent ) : QObject ( parent ) { QTimer :: singleshot ( this , & TeaTimer :: init ); } TeaTimer :: init () { // do long initialization }","title":"Runtime & Modules"},{"location":"topics/runtime/#runtime-modules","text":"Craziness is doing the same thing and expecting a different result. -- Einstein The QML runtime used in the CoreUI architecture is Qt Application Manager. Which is designed to provide a multi-process architecture, where each application runs in an own process, started by its own runtime.","title":"Runtime &amp; Modules"},{"location":"topics/runtime/#engine","text":"A runtime is just a small C++ application starting the JS engine and QML engine and loading the initial qml document. 1 2 3 4 5 6 7 8 9 #include <QGuiApplication> #include <QQmlApplicationEngine> int main ( int argc , char * argv []) { QGuiApplication app ( argc , argv ); QQmlApplicationEngine engine ( \"main.qml\" ); return app . exec (); } The QML application engine in the background handles the quit signal, loads translations, handles windows correctly and setups a QML file selector. Note If you look for more inspiration how to write a custom runtime check out $QTSRC/qtdeclarative/tools/qmlscene . This runtime provides also command line parsing, import path configuration, etc... The Qt Application Manager is more complex as contains a lot more features, configuration capabilities and security mechanisms as also support for launching other runtimes in separate processes and watching over them.","title":"Engine"},{"location":"topics/runtime/#plugin-extensions","text":"A runtime is extended using QtQuick plugins. A plugin is a defined C++ interface to be implemented and the plugin library needs to placed in a defined folder structure with a small description file the qmldir . Qt Creator contains a wizard to create a plugin. The CoreUI admin also has a generator, which fits the plugin into the existing native project. When build and installed, te runtime will load the plugin when the module import is the first time requested by a QML document. By this we can control the loading of plugins by ensuring the module is only loaded when required. The runtime lookups the QML import declaration in the import paths and when detected loads the corresponding plugin library. The plugin declares a set of QML types which are then registered into the module namespace and made available to the QML engine. Like below code which provides the interface vor the plugin to register the QML types. 1 2 3 4 5 6 7 8 9 10 11 12 13 // plugin.h #pragma once #include <QtQml> class AlarmPlugin : public QQmlExtensionPlugin { Q_OBJECT Q_PLUGIN_METADATA ( IID QQmlExtensionInterface_iid ) public : void registerTypes ( const char * uri ) override ; }; A type is registered using one of the qmlRegister... template methods. By this this object is now accessible under the import URL with the type name in QML. 1 2 3 4 5 6 7 8 9 #include \"plugin.h\" #include \"teatimer.h\" void TeaTimerPlugin :: registerTypes ( const char * uri ) { Q_ASSERT ( uri == QLatin1String ( \"Tea\" )); qmlRegisterType < TeaTimer > ( uri , 1 , 0 , \"TeaTimer\" ); } The object registered can be either a visual type inheriting from QtQuickItem or a business type , inheriting from QObject . If the type shall take part of the rendering than it must inherit from QQuickItem . Our example is a tea timer, which allows the user to set a duration and the time triggers a signal when the timer is done. The tea timer is a standard object with properties and signals. Additionally Q_INVOKABLE is used to make the method available to QML. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #pragma once #include <QtCore> class TeaTimer : public QObject { Q_OBJECT QPROPERTY ( int currentTime READ currentTime NOTIFY currentTimeChanged ) Q_INVOKABLE void set ( int min , int sec ); Q_INVOKABLE void start (); Q_INVOKABLE void stop (); int currentTime () const ; void setCurrentTime ( int currentTime ); private : void handleTick (); signals : void currentTimeChanged (); void ring (); private : QTimer * m_timer ; int m_currentTime ; int m_duration ; }; For the implementation the tea timer uses a QTimer which timeouts every 100msecs to forward the current time and when the duration is reached it rings. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // teatimer.cpp #include \"teatimer.h\" TeaTimer :: TeaTimer ( QObject * parent ) : QObject ( parent ) , m_timer ( new QTimer ( this )) , m_currentTime ( 0 ) { connect ( m_timer , & QTimer :: timeout , this , & TeaTimer :: handleTick ); m_timer -> setInterval ( 100 ); // 100 msecs } void TeaTimer :: set ( int min , int sec ) { stop (); m_duration = ( min * 60 + sec ) * 1000 ); } void TeaTimer :: start () { m_timer - start (); } void TeaTimer :: stop () { m_timer - stop (); setCurrentTime ( 0 ); } void TeaTimer :: handleTick () { setCurrentTime ( currentTime () + m_timer -> interval ()); } int TeaTimer :: currentTime () const { return m_currentTime ; } void setCurrentTime ( int currentTime ) { if ( m_currentTime == currentTime ) { return ; } m_currentTime = msec ; emit currentTimeChanged (); if ( m_currentTime >= m_duration ) { stop (); emit ring (); } } We can now use the tea timer inside our QML code through importing the tea module and instantiating the TeaTimer object. 1 2 3 4 5 6 7 8 import Tea 1.0 MainWindow { id: root TeaTimer { duration: 2 * TeaTimer . Minutes } }","title":"Plugin Extensions"},{"location":"topics/runtime/#object-patterns","text":"","title":"Object Patterns"},{"location":"topics/runtime/#instances-vs-singletons","text":"QML also allows to register singletons. They are instantiated when the first time the module is imported. The problem with them are they are never destroyed and also they can be used anywhere in your code. Sounds great on first hand, but these singletons are tricky as they introduce dependencies which makes it hard to test these QML components. Ideally you try to avoid singletons wherever you can and use the dependency injections (aka configurable dependencies) to pass on instances of logic object into QML. This is a bad example of using a tea timer type, by registering the type as singleton and using it inside a panel. Now it is very difficult to test this component. 1 2 3 4 5 6 // TeaPanel Panel { Label { text: TeaTimer . currentTime } } This is better, we have the incoming dependency under control. 1 2 3 4 5 6 7 // TeaPanel Panel { property TeaTimer teaTimer Label { text: teaTimer . currentTime } } Even better, avoid the dependency on the type at all 1 2 3 4 5 6 7 8 // TeaPanel.qml Panel { id: root property int currentTime Label { text: root . currentTime } }","title":"Instances vs Singletons"},{"location":"topics/runtime/#delayed-init","text":"Also when using instances we need to ensure the instantiation goes fast as this directly relates to the UI startup. Which means the constructor must be slim. Any longer startup (e.g. pinging a server) should be done using a delayed init call. 1 2 3 4 5 6 7 8 9 10 TeaTimer :: TeaTimer ( QObject * parent ) : QObject ( parent ) { QTimer :: singleshot ( this , & TeaTimer :: init ); } TeaTimer :: init () { // do long initialization }","title":"Delayed Init"},{"location":"topics/services/","text":"Services \"The code is the truth, but not the whole truth\" -- Grady Booch Info This material is work in progress and will change! Services exposes features either from the system or a networked resource to the application layer. Services can be categorized based on their process-association, inter-service dependencies and the handling of state. In general a service is an instance of vertical communication. This vertical communication can be done via an IPC out-of-process or via a library in-process. The API can be designed state-less or state-full. You should prefer state-full if the API shall reflect the system state (e.g. volume, temperature) which shall be shown on several displays and state-less if the API is used to primary query backends and no shared state is required. In general in embedded system a state-full service is preferred as the system shall reflect the machine state. A service is a vertical communication layer APIs in embedded devices are primary state-full Be aware that the service API will not directly consumed by the UI elements and rather be wrapped by a store API optimized for UI consumption. A service API will not be directly consumed by the UI Services are system features which expose an API surface published using primary a system specific IPC. A service is often defined as a client/server model, where the client (e.g. the UI or another service) and the server (a bundle of services in one process) communicate via an IPC (typically TCP/IP based or D-BUS based). During development a service needs to be simulated in case the endpoint is not available or depends on a hardware which is difficult to gain access to or work with. Often HW is also not available in an early project phase, still the UI development needs to start. When looking on a system there exists often many services, and ideally each service can be individually configured to use either a simulation or a real backend. Simulation and services will often be used across device boundaries. For example a host running the user interface tries to connect to an embedded device connected via an ethernet or serial connection. In these cases it is important that the selected IPC supports this use case. This is why the author things D-BUS is not a valid choice for this layer and TCP/IP based solutions are better suited. A service needs to support a simulation backend A simulation backend needs to be enabled per service For out-of-process services of the IPC is very specific to the individual project and the service needs to be able to adapt to this communication library. IN a rare case the project does not define an IPC solution and the developers can choose their best fiffting solution. There is a difference between the services consumed by the UI and the services the system is offering. Often system services are available using D-BUS as IPC and are meant to be consumed using some low-level API. These middle-ware services offer a higher-level API already defined with the UI in mind, still, the API is only loosely coupled towards the UI. It is assumed that this service API will change over the development time of the project and it will take several iterations to get a stable API. As such it is not wise that the UI directly consumes this API. The changes will lead to many small defects in the UI which will make it very hard to detect and fix them. Hint It is preferred that the service client API either be consumed by a C++ native extension or in a QML/JS based UI store. The C++ compiler will detect many API changes and report them before they appear in the UI and when using a QML/JS based store there needs to be 100% test coverage to ensure that these changes will be detected. It is important that the release cycle of the store API is fully controlled by the UI developer to avoid suprises and the release cycle of the service API is harmonized between the UI and platform developers. API Shape The API should be shaped after easy to understand patterns and ideally be familiar to the developer but also easy to explain to non-technical API authors. The API should define a common vocabulary and provide a way to structure larger projects. The API shall be shaped around the idea of a module. Each module is identified by a reverse URI (e.g. like a Java package convention). Each module can contain a list of interfaces. An interface is a collection of properties, operations and signals. The collection of properties define the state of the interface. The operations provide a mean to modify the state or to retrieve data. Signals allow a service to notify a client about external changes. It is assumed for pure property changes the API will auto-provide signals. 1 2 3 4 5 6 7 8 9 - module # module is a namespace for all child symbols exists - Interface # named symbol which defines a set of properties , operations , and signals - Properties # data entry with a name and type - Operations # operation with parameters and return value - Signals # notification sent from the service back to the consumer - Struct # data structure to define a message - Fields # entries of a struct with name and type - Enum / Flag # An enumeration which can be used e . g . for properties and / or operations - Values # entries of an enumeration with name and value A module can have one or more interfaces, structs or enums/flags. As such a module is a higher level feature. To adhere to the micro-service architecture a service API should not depend directly on another service, instead, the API author should use identifiers (IDs), which are typically integers or strings to identify a resource from another module. Below is an example of a simple counter API. Please be aware this is a state-full example as the state of the interface is encoded in the count property. 1 2 3 4 5 6 7 module counter 1.0 interface Counter { int count void increment () void decrement () } A state-less example would look like this 1 2 3 4 5 6 7 module counter 1.0 interface Counter { int count () int increment () int decrement () } Interface Definition The API exposed by all middle-ware services needs to be harmonized across all services. To ensure a well defined and harmonized API can be created the API shall be defined in an interface definition language (IDL) with an attached code generation. The IDL should be independent of the target technology to allow securing the investment into an API also if the UI technology or the backend technolgy changes in the future. The IDL should be designed so that it is simple to understand and expressive. It should be able to express the API exact enough for developers to get an idea which code will be generated out of the API, still, it should be high level enough that a non-technical person understands which features are covered in the API. The IDL needs to be able to generate a well-defined API documentation for externals to lookup the documentation as a reference how to use the API. Also, the IDL shall allow extensions to provide meta information to transport project specific information such as deployment information or specific directives for the code generator. Code Generation The IDL should have a sophisticated code generator attached, ideally independent from the target technology, to allow customers to use a different technology or a different IPC. During the lifetime of a project, there are many needs to generate a different kind of source code or reports about an API. For example also if the client/server communication is done in C++ using a TCP/IP based IPC there might be a requirement during development to potentially use a WebSocket JSON protocol to make debugging easier. Also, developers would like to generate documentation with a custom style to map the project colors or in a format which can be consumed by their tool-chain. In the past, there was also some need to report back some statistics about the API. All of these use cases call for a flexible yet powerful code generation framework where a development team can use existing code generator or provide their own if the requirements of the project change. Still, the investment into the API definition should not be lost and be reusable. Service Implementation A service generated from the code generator should ideally already be compilable and runnable by the user also if it does not provide any implementation. This allows the user to implement features piece by piece iteratively. This normally results in a conflict if the code generator writes files which need to be edited by the user. It is important that the code generator differentiate between files which can be overwritten and those which need to be preserved for the user. The service implementation is typically based on an abstract base class which provides the interface to be implemented. The developer then needs to edit the concrete classes and implement the interface. Client Usage From the UI perspective the client should just be instantiated. The UI should be in charge to decide at which time a client is created and connected to the device. The client configuration should be read from some kind of data storage (e.g. settings file) and/or environment variable. By this configuration of the client is separated from the instantiation. The UI shall be in charge of the startup sequence. And as such must be able to delay certain clients only to be constructed on demand. A service API shall not be exposed to the UI, this is merely to allow better testing. For this a store wrappes the used service APIs in a common API for the UI. The store can be written either in QML/JS or C++. QML/JS is great during prototyping but C++ offers more performance and better control of the API usage. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // store/RootStore.qml import services . phone 1.0 Store { id: root property alias callActive: phone . callActive PhoneService { id: phone active: true } function call ( number ) { if ( ! phone . enabled ) { return ; } phone . call ( number , function ( result ) { if ( result . error ) { console . warning ( 'ERROR: ' , result . error ); } }); } } Calling service function is often more complex than just calling the operation. Certain conditions defeind by the requirements specification and or error cases needs to be handled. To avoid this code pollutes the UI these functions are coded inside a store. Often used functions can also be encoded into helpers to even more reduce code clutter. Service Simulation Service simulation allows a client to be used without a real-service attached and furthermore allows the testing of service conditions which are difficult to establish. It is used in the UI creation when user stories need to be tested to ensure certain system conditions are established to effectively validate the user story. This does not replace the need for system testing as these kinds of prototypes are more designed to demo a user story to a product owner before it will be validated in the actual hardware. Establishing flexible simulated services is the key factor to separate the UI software from the hardware. Simulation needs to be switched per service base so that the system can run in a mixed simulation mode. This requires a service not to depend on other services which leads to a micro-service architecture. In case a service depends on an object from another service it is better to exchange object ids and the other service would acquire the object using this object id. A simulated service should be more than just a static representation of the service state, it should also be able to simulate the execution of operations and their effects. Ideally the simulation is able to simulate how data changes over time, e.g. a time or event based scripting. This could be a script attached to the simulated service or as simple as a timed data read from a file. The configuration of the services is ideally located in one shared document and can be edited to switch between real-services and simulated services. Most of the times a service is bound through a TCP/IP protocol, the switch could then be as simple as changing the port or the IP address of a service.","title":"Services"},{"location":"topics/services/#services","text":"\"The code is the truth, but not the whole truth\" -- Grady Booch Info This material is work in progress and will change! Services exposes features either from the system or a networked resource to the application layer. Services can be categorized based on their process-association, inter-service dependencies and the handling of state. In general a service is an instance of vertical communication. This vertical communication can be done via an IPC out-of-process or via a library in-process. The API can be designed state-less or state-full. You should prefer state-full if the API shall reflect the system state (e.g. volume, temperature) which shall be shown on several displays and state-less if the API is used to primary query backends and no shared state is required. In general in embedded system a state-full service is preferred as the system shall reflect the machine state. A service is a vertical communication layer APIs in embedded devices are primary state-full Be aware that the service API will not directly consumed by the UI elements and rather be wrapped by a store API optimized for UI consumption. A service API will not be directly consumed by the UI Services are system features which expose an API surface published using primary a system specific IPC. A service is often defined as a client/server model, where the client (e.g. the UI or another service) and the server (a bundle of services in one process) communicate via an IPC (typically TCP/IP based or D-BUS based). During development a service needs to be simulated in case the endpoint is not available or depends on a hardware which is difficult to gain access to or work with. Often HW is also not available in an early project phase, still the UI development needs to start. When looking on a system there exists often many services, and ideally each service can be individually configured to use either a simulation or a real backend. Simulation and services will often be used across device boundaries. For example a host running the user interface tries to connect to an embedded device connected via an ethernet or serial connection. In these cases it is important that the selected IPC supports this use case. This is why the author things D-BUS is not a valid choice for this layer and TCP/IP based solutions are better suited. A service needs to support a simulation backend A simulation backend needs to be enabled per service For out-of-process services of the IPC is very specific to the individual project and the service needs to be able to adapt to this communication library. IN a rare case the project does not define an IPC solution and the developers can choose their best fiffting solution. There is a difference between the services consumed by the UI and the services the system is offering. Often system services are available using D-BUS as IPC and are meant to be consumed using some low-level API. These middle-ware services offer a higher-level API already defined with the UI in mind, still, the API is only loosely coupled towards the UI. It is assumed that this service API will change over the development time of the project and it will take several iterations to get a stable API. As such it is not wise that the UI directly consumes this API. The changes will lead to many small defects in the UI which will make it very hard to detect and fix them. Hint It is preferred that the service client API either be consumed by a C++ native extension or in a QML/JS based UI store. The C++ compiler will detect many API changes and report them before they appear in the UI and when using a QML/JS based store there needs to be 100% test coverage to ensure that these changes will be detected. It is important that the release cycle of the store API is fully controlled by the UI developer to avoid suprises and the release cycle of the service API is harmonized between the UI and platform developers.","title":"Services"},{"location":"topics/services/#api-shape","text":"The API should be shaped after easy to understand patterns and ideally be familiar to the developer but also easy to explain to non-technical API authors. The API should define a common vocabulary and provide a way to structure larger projects. The API shall be shaped around the idea of a module. Each module is identified by a reverse URI (e.g. like a Java package convention). Each module can contain a list of interfaces. An interface is a collection of properties, operations and signals. The collection of properties define the state of the interface. The operations provide a mean to modify the state or to retrieve data. Signals allow a service to notify a client about external changes. It is assumed for pure property changes the API will auto-provide signals. 1 2 3 4 5 6 7 8 9 - module # module is a namespace for all child symbols exists - Interface # named symbol which defines a set of properties , operations , and signals - Properties # data entry with a name and type - Operations # operation with parameters and return value - Signals # notification sent from the service back to the consumer - Struct # data structure to define a message - Fields # entries of a struct with name and type - Enum / Flag # An enumeration which can be used e . g . for properties and / or operations - Values # entries of an enumeration with name and value A module can have one or more interfaces, structs or enums/flags. As such a module is a higher level feature. To adhere to the micro-service architecture a service API should not depend directly on another service, instead, the API author should use identifiers (IDs), which are typically integers or strings to identify a resource from another module. Below is an example of a simple counter API. Please be aware this is a state-full example as the state of the interface is encoded in the count property. 1 2 3 4 5 6 7 module counter 1.0 interface Counter { int count void increment () void decrement () } A state-less example would look like this 1 2 3 4 5 6 7 module counter 1.0 interface Counter { int count () int increment () int decrement () }","title":"API Shape"},{"location":"topics/services/#interface-definition","text":"The API exposed by all middle-ware services needs to be harmonized across all services. To ensure a well defined and harmonized API can be created the API shall be defined in an interface definition language (IDL) with an attached code generation. The IDL should be independent of the target technology to allow securing the investment into an API also if the UI technology or the backend technolgy changes in the future. The IDL should be designed so that it is simple to understand and expressive. It should be able to express the API exact enough for developers to get an idea which code will be generated out of the API, still, it should be high level enough that a non-technical person understands which features are covered in the API. The IDL needs to be able to generate a well-defined API documentation for externals to lookup the documentation as a reference how to use the API. Also, the IDL shall allow extensions to provide meta information to transport project specific information such as deployment information or specific directives for the code generator.","title":"Interface Definition"},{"location":"topics/services/#code-generation","text":"The IDL should have a sophisticated code generator attached, ideally independent from the target technology, to allow customers to use a different technology or a different IPC. During the lifetime of a project, there are many needs to generate a different kind of source code or reports about an API. For example also if the client/server communication is done in C++ using a TCP/IP based IPC there might be a requirement during development to potentially use a WebSocket JSON protocol to make debugging easier. Also, developers would like to generate documentation with a custom style to map the project colors or in a format which can be consumed by their tool-chain. In the past, there was also some need to report back some statistics about the API. All of these use cases call for a flexible yet powerful code generation framework where a development team can use existing code generator or provide their own if the requirements of the project change. Still, the investment into the API definition should not be lost and be reusable.","title":"Code Generation"},{"location":"topics/services/#service-implementation","text":"A service generated from the code generator should ideally already be compilable and runnable by the user also if it does not provide any implementation. This allows the user to implement features piece by piece iteratively. This normally results in a conflict if the code generator writes files which need to be edited by the user. It is important that the code generator differentiate between files which can be overwritten and those which need to be preserved for the user. The service implementation is typically based on an abstract base class which provides the interface to be implemented. The developer then needs to edit the concrete classes and implement the interface.","title":"Service Implementation"},{"location":"topics/services/#client-usage","text":"From the UI perspective the client should just be instantiated. The UI should be in charge to decide at which time a client is created and connected to the device. The client configuration should be read from some kind of data storage (e.g. settings file) and/or environment variable. By this configuration of the client is separated from the instantiation. The UI shall be in charge of the startup sequence. And as such must be able to delay certain clients only to be constructed on demand. A service API shall not be exposed to the UI, this is merely to allow better testing. For this a store wrappes the used service APIs in a common API for the UI. The store can be written either in QML/JS or C++. QML/JS is great during prototyping but C++ offers more performance and better control of the API usage. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // store/RootStore.qml import services . phone 1.0 Store { id: root property alias callActive: phone . callActive PhoneService { id: phone active: true } function call ( number ) { if ( ! phone . enabled ) { return ; } phone . call ( number , function ( result ) { if ( result . error ) { console . warning ( 'ERROR: ' , result . error ); } }); } } Calling service function is often more complex than just calling the operation. Certain conditions defeind by the requirements specification and or error cases needs to be handled. To avoid this code pollutes the UI these functions are coded inside a store. Often used functions can also be encoded into helpers to even more reduce code clutter.","title":"Client Usage"},{"location":"topics/services/#service-simulation","text":"Service simulation allows a client to be used without a real-service attached and furthermore allows the testing of service conditions which are difficult to establish. It is used in the UI creation when user stories need to be tested to ensure certain system conditions are established to effectively validate the user story. This does not replace the need for system testing as these kinds of prototypes are more designed to demo a user story to a product owner before it will be validated in the actual hardware. Establishing flexible simulated services is the key factor to separate the UI software from the hardware. Simulation needs to be switched per service base so that the system can run in a mixed simulation mode. This requires a service not to depend on other services which leads to a micro-service architecture. In case a service depends on an object from another service it is better to exchange object ids and the other service would acquire the object using this object id. A simulated service should be more than just a static representation of the service state, it should also be able to simulate the execution of operations and their effects. Ideally the simulation is able to simulate how data changes over time, e.g. a time or event based scripting. This could be a script attached to the simulated service or as simple as a timed data read from a file. The configuration of the services is ideally located in one shared document and can be edited to switch between real-services and simulated services. Most of the times a service is bound through a TCP/IP protocol, the switch could then be as simple as changing the port or the IP address of a service.","title":"Service Simulation"},{"location":"topics/styles/","text":"UI Styling Info This material is work in progress and will change! A style changes the visual appearance of styled controls. These can be common controls as part of the component library but also application controls or even containers. To be able to style a UI successfully, all controls need to adhere to a common style programming guide which shows the developer how to ensure that newly created components are styleable. In case the application does not use custom controls and all styling is already done by the common controls library and no work is needed here. This chapter is more for people who need to create custom controls or have specific UI requirements deviating from a common set. Skin / Style / Theme There are often different terms used for a similar set of functionality offered to change the appearance of the user interface. Here are the terms used in this book. Skin - A skin is a re-programming of the topmost UI layer. It may re-use or adapt larger parts of the existing UI code but in general, a skin deviates so much from the original UI that it can not be embedded into the original code and often this leads to a fork of the UI layer. Style - A central visual appearance hub to manage the appearance of controls. This can contain geometry, colors, effects, font and font geometry or other output methods. Theme - Themes are variants of a given Style. They change some properties of it, such as the color palette, but still share the same essence and major design features. A classic example is having a \"light\" and a \"dark\" theme for you Style, which you change at runtime depending on the time of day or user preference. A theme is the simplest visual change. A theme requires a style which supports the theming functionality. A skin changes the layout of the user interface. If the information architecture is preserved the work required is to re-write the UI layer based custom style. All appearance changes require they run on top of the same platform. Styling versus creating new controls You should strive to have the UI code of your QML application look familiar to any experienced QML UI developer. This means avoiding the introduction of new idioms and concepts unless when actually necessary. Qt Quick Controls 2 comes already with several common controls, such as Button, CheckBox, ComboBox, etc. It's worth making an effort to use those and make them look and behave according to your design specs via styling instead of jumping into the creation new controls such as MySpecialButton, MyProjectNameComboBox, and so on. It's a harder route, but it has multiple benefits, such as: It reduces the learning curve for new members in your team, as there are less new APIs and concepts to be learned. Makes your application easier to maintain. A consequence of the previous point. It's easier to port QML applications made for other platforms into your platform, as there are less APIs and concepts exclusive to your project or platform, which translates into less code changes. Don't reinvent the wheel, or \"stand on the shoulders of giants\". Time and effort was put into making the APIs of Qt Quick Controls 2 components, so it makes sense to try to use them instead of coming up with your own, which could be just duplicating effort. Customizing an existing Style This is the process of modifying one of the built-in styles. It is often the initial step when defining your own style. The API of the controls does not change and for an initial UI, using an existing style and tweaking it for your own purposes is notably simpler than creating a brand new one from scratch. How to customize an existing style is covered :qt5: here <qtquickcontrols2-styles.html> . Creating a new Style If your HMI has its own particlar look and feel, its own UI design guide, the :qt5: existing Qt Quick Controls 2 styles <qtquickcontrols2-styles.html> probably won't suite you and you will have to create your own style to implement what the UI/UX designers envisioned. To exemplify how this is achieved let's start with a simple UI, a sort of components gallery showcasing a handful of Qt Quick Controls 2 components in different states. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import QtQuick 2.11 import QtQuick . Controls 2.1 Pane { width: 600 height: 600 Column { anchors.fill: parent padding: 50 spacing: 25 Row { spacing: 25 Button { text: \"Button\" } Button { text: \"Button\" ; enabled: false } } Row { spacing: 25 CheckBox { text: \"Checkbox\" } CheckBox { text: \"Checkbox\" ; checked: true } } Row { spacing: 25 Switch {} Switch { checked: true } } Label { text: \"Label\" } } } Save it as, say, controls.qml. Now run it with the qml tool 1 $ qml controls.qml You should see something like this: Then try it with one of the styles shipped with Qt Quick Controls 2, such as \"material\" 1 $ qml controls.qml -style material Or \"fusion\" (in a desktop environment that's using a dark theme) 1 $ qml controls.qml -style fusion You can see that by using Qt Quick Controls 2 styles you can have the application code independent of the look and feel of its components. So no changes are needed in the components' API exposed to application code. Now we are going to create a new style that implements a different look and feel, which we will call \"foobar\". The first component we will customize in the foobar style is going to be the Pane, as it's the simplest. Create a subdirectory called \"foobar\". Then copy the file QT_INSTALL_DIR/qml/QtQuick/Controls.2/Pane.qml to it, where QT_INSTALL_DIR is the path where your Qt is installed. It should look like the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import QtQuick 2.12 import QtQuick . Controls 2.5 import QtQuick . Controls . impl 2.5 import QtQuick . Templates 2.5 as T T . Pane { id: control implicitWidth: Math . max ( implicitBackgroundWidth + leftInset + rightInset , contentWidth + leftPadding + rightPadding ) implicitHeight: Math . max ( implicitBackgroundHeight + topInset + bottomInset , contentHeight + topPadding + bottomPadding ) padding: 12 background: Rectangle { color: control . palette . window } } The idea is to collect the standard implementation of the component whose look & feel you want to customize in your style from that directory in Qt to your own style directory and then modify it at will. In our foobar style we want the Pane background to be a Gradient instead, hence we will make the following change: 1 2 3 4 5 6 7 8 ... background: Rectangle { gradient: Gradient { GradientStop { position: 0.0 ; color: \"dodgerblue\" } GradientStop { position: 1.0 ; color: \"lightsteelblue\" } } } ... Now let's run our controls.qml app with our brand new style. For that we will have to supply two additional environment variables: QT_QUICK_CONTROLS_STYLE_PATH to tell Qt where in the filesystem to look for more styles and QT_QUICK_CONTROLS_FALLBACK_STYLE to tell Qt which style to fallback on in case the chosen one is missing the implementation of some component (more info :qt5: here <qtquickcontrols2-environment.html> ). Since our foobar style just has the implementation of Pane, all other components will fallback to another implementation. 1 $ QT_QUICK_CONTROLS_STYLE_PATH = . QT_QUICK_CONTROLS_FALLBACK_STYLE = Material qml controls.qml -style foobar Next we want to style the Button component. As with did with Pane, just copy Button.qml over from QT_INSTALL_DIR/qml/QtQuick/Controls.2 into our foobar style directory. If you open that file now you will see that it's quite more involded than the Pane: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import QtQuick 2.12 import QtQuick . Controls 2.5 import QtQuick . Controls . impl 2.5 import QtQuick . Templates 2.5 as T T . Button { id: control implicitWidth: Math . max ( implicitBackgroundWidth + leftInset + rightInset , implicitContentWidth + leftPadding + rightPadding ) implicitHeight: Math . max ( implicitBackgroundHeight + topInset + bottomInset , implicitContentHeight + topPadding + bottomPadding ) padding: 6 horizontalPadding: padding + 2 spacing: 6 icon.width: 24 icon.height: 24 icon.color: control . checked || control . highlighted ? control.palette.brightText : control . flat && ! control . down ? ( control . visualFocus ? control.palette.highlight : control . palette . windowText ) : control . palette . buttonText contentItem: IconLabel { spacing: control . spacing mirrored: control . mirrored display: control . display icon: control . icon text: control . text font: control . font color: control . checked || control . highlighted ? control.palette.brightText : control . flat && ! control . down ? ( control . visualFocus ? control.palette.highlight : control . palette . windowText ) : control . palette . buttonText } background: Rectangle { implicitWidth: 100 implicitHeight: 40 visible: ! control . flat || control . down || control . checked || control . highlighted color: Color . blend ( control . checked || control . highlighted ? control.palette.dark : control . palette . button , control . palette . mid , control . down ? 0.5 : 0.0 ) border.color: control . palette . highlight border.width: control . visualFocus ? 2 : 0 } } You're free to change anything at will. This is just a default look & feel implementation. You're free to take it as it is, do some small modifications on top of it or wipe it out and do something completely different. What's important is to try to and obey the exising properties (icon, text, impleicitWidth, etc) as much as it makes sense to in your HMI usage and to put the foreground content of your button (eg, text and icon) in contentItem and its background, if any, in background . It's worth noting the widespread usage of the palette property. If you want to tweak its values in your style, the best place to do so would be in the Control.qml style implementation, as all Qt Quick Controls 2 components inherit from it. But if the categories (button, windowText, highlight, etc) in that palette type don't really suite your needs or your UI design guide you're free to use your own structure to keep your custom color and other values instead. We will come back to it later. For now let's just set a hardcoded background color, make the background rounded, make the button larger when down/pushed and have its text rotating (just because we can :) ). These would be the modifications: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 --- a/foobar/Button.qml +++ b/foobar/Button.qml @@ -15,12 +15,18 @@ T.Button { horizontalPadding: padding + 2 spacing: 6 + scale: control.down ? 1.4 : 1 + Behavior on scale { + NumberAnimation { easing.type: Easing.OutCubic; duration: 200 } + } + icon.width: 24 icon.height: 24 icon.color: control.checked || control.highlighted ? control.palette.brightText : control.flat && !control.down ? (control.visualFocus ? control.palette.highlight : control.palette.windowText) : control.palette.buttonText contentItem: IconLabel { + id: iconLabel spacing: control.spacing mirrored: control.mirrored display: control.display @@ -30,15 +36,29 @@ T.Button { font: control.font color: control.checked || control.highlighted ? control.palette.brightText : control.flat && !control.down ? (control.visualFocus ? control.palette.highlight : control.palette.windowText) : control.palette.buttonText + + RotationAnimator { + target: iconLabel + from: 0; to: 360 + duration: 1500 + running: true + loops: Animation.Infinite + } } background: Rectangle { implicitWidth: 100 implicitHeight: 40 visible: !control.flat || control.down || control.checked || control.highlighted - color: Color.blend(control.checked || control.highlighted ? control.palette.dark : control.palette.button, - control.palette.mid, control.down ? 0.5 : 0.0) + + color: \"seagreen\" + opacity: control.down ? 1 : 0.8 + Behavior on opacity { + NumberAnimation { easing.type: Easing.OutCubic; duration: 200 } + } + border.color: control.palette.highlight border.width: control.visualFocus ? 2 : 0 + radius: width / 2 } } If you run that application again you should see that the buttons are animated and look wildly different from the other styles. This is just to give an idea of how flexible and powerful the Qt Quick Controls 2 styling is. Collecting values in a Style object So far we have been hardcoding color values directly in the component's style implementation. But for better reusability it's prefferable to give them names and collect them all into a single entity. There are a couple of ways of doing it but, again, we will start with the simplest: creating a new qml module containing a singleton QtObject which will hold all the color and other values used throughout the style implementation. In this example we will name that singleton FoobarStyle . Create a subdirectory called imports and inside it yet another subdirectory called FoobarStyle , which will be the name of our qml module. Inside imports/FoobarStyle create a file named qmldir with the following content:: 1 2 module FoobarStyle singleton FoobarStyle 1.0 FoobarStyle . qml Then proceed to create the file FoobarStyle.qml also inside imports/FoobarStyle :: 1 2 3 4 5 6 7 8 9 pragma singleton import QtQuick 2.11 QtObject { property color gradientBackgroundTopColor : \"dodgerblue\" property color gradientBackgroundBottomColor : \"lightsteelblue\" property color buttonBackgroundColor : \"seagreen\" } FoobarStyle collects the colors have been used so far. You can have those names be more specific (eg. button background color) or more generic (eg. secondary control color) according to how they're used throught the implenentation and how your UI Style guide describes them. Now let's get back to Panel.qml and Button.qml replacing the hardcoded values with their corresponding named colors:: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 --- a/foobar/Button.qml +++ b/foobar/Button.qml @@ -3,6 +3,8 @@ import QtQuick.Controls 2.5 import QtQuick.Controls.impl 2.5 import QtQuick.Templates 2.5 as T +import FoobarStyle 1.0 + T.Button { id: control @@ -51,7 +53,7 @@ T.Button { implicitHeight: 40 visible: !control.flat || control.down || control.checked || control.highlighted - color: \"seagreen\" + color: FoobarStyle.buttonBackgroundColor opacity: control.down ? 1 : 0.8 Behavior on opacity { NumberAnimation { easing.type: Easing.OutCubic; duration: 200 } diff --git a/foobar/Pane.qml b/foobar/Pane.qml index f903afa..b82be7f 100644 --- a/foobar/Pane.qml +++ b/foobar/Pane.qml @@ -3,6 +3,8 @@ import QtQuick.Controls 2.5 import QtQuick.Controls.impl 2.5 import QtQuick.Templates 2.5 as T +import FoobarStyle 1.0 + T.Pane { id: control @@ -15,8 +17,8 @@ T.Pane { background: Rectangle { gradient: Gradient { - GradientStop { position: 0.0; color: \"dodgerblue\" } - GradientStop { position: 1.0; color: \"lightsteelblue\" } + GradientStop { position: 0.0; color: FoobarStyle.gradientBackgroundTopColor } + GradientStop { position: 1.0; color: FoobarStyle.gradientBackgroundBottomColor } } } } Now to be able to run our controls.qml application we will also have to tell the qml tool to look into the imports subdirectory for qml modules. Hence:: 1 QT_QUICK_CONTROLS_STYLE_PATH = . QT_QUICK_CONTROLS_FALLBACK_STYLE = Material qml - I imports controls . qml - style foobar Note that having our named colors conveniently collected in a singleton also enables application code import FoobarStyle and use them directly whenever needed. Adding theming support After having our hardcoded values such as named colors collected in a singleton, adding theming support is a simple, straightforward, step. The idea is that a single property in FooBarStyle , which we will name as theme , will define the value of all others. So this is our improved FoobarStyle.qml , now with theme support: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 pragma Singleton import QtQuick 2.11 QtObject { // Available themes readonly property int dayTheme: 0 readonly property int nightTheme: 1 // The chosen theme property int theme: dayTheme // The values that make up a theme readonly property color gradientBackgroundTopColor: theme === dayTheme ? \"dodgerblue\" : \"black\" readonly property color gradientBackgroundBottomColor: theme === dayTheme ? \"lightsteelblue\" : \"darkblue\" readonly property color buttonBackgroundColor: theme === dayTheme ? \"seagreen\" : \"maroon\" } And modifying the application code, controls.qml , so that clicking on the first button switches the theme:: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 --- a/controls.qml +++ b/controls.qml @@ -1,6 +1,8 @@ import QtQuick 2.11 import QtQuick.Controls 2.1 +import FoobarStyle 1.0 + Pane { width: 500 height: 400 @@ -13,7 +15,16 @@ Pane { Row { spacing: 25 - Button { text: \"Button\" } + Button { + text: FoobarStyle.theme === FoobarStyle.dayTheme ? \"Day\" : \"Night\" + onClicked: { + if (FoobarStyle.theme === FoobarStyle.dayTheme) { + FoobarStyle.theme = FoobarStyle.nightTheme; + } else { + FoobarStyle.theme = FoobarStyle.dayTheme; + } + } + } Button { text: \"Button\"; enabled: false } } This is how our controls.qml application should look like after having the theme support added to it: Naming conventions One common mistake when naming colors in particular is naming them after what they look like instead of their function or where they are used. So avoid names such as \"orangeBackgroundColor\" or \"lightTextColor\" and prefer usage, such as \"buttonBackgroundColor\" or a category such as \"primaryColor\" or \"accentColor\". After all, as soon as you have a day/light and a night/dark theme, a color property that used to have a \"yellow\" or \"light\" value will switch to have the opposite, having a \"dark\" or \"brown\" one instead. Naming a color property after the visual caracteristics of its value will void the abstraction level (and hence flexibility) it provides when compared to using hardcoded values directly. Having that said, there might still be value in naming a color in a explicit way in your style object, such as FoobarStyle.red, meaning that whenever your UI uses red, it's not just any red, or the standard 0xFF0000, but a very particular hue of red, which is specified in your style. And that only if the usage of this named red throught the UI is always the same, regardless of the theme. Such as the red that makes up the visual identity of your company or the red that signifies alert or the interruption of a call. Note describe why a sheet is a good concept to display your controls and how should it be built.","title":"Styles"},{"location":"topics/styles/#ui-styling","text":"Info This material is work in progress and will change! A style changes the visual appearance of styled controls. These can be common controls as part of the component library but also application controls or even containers. To be able to style a UI successfully, all controls need to adhere to a common style programming guide which shows the developer how to ensure that newly created components are styleable. In case the application does not use custom controls and all styling is already done by the common controls library and no work is needed here. This chapter is more for people who need to create custom controls or have specific UI requirements deviating from a common set.","title":"UI Styling"},{"location":"topics/styles/#skin-style-theme","text":"There are often different terms used for a similar set of functionality offered to change the appearance of the user interface. Here are the terms used in this book. Skin - A skin is a re-programming of the topmost UI layer. It may re-use or adapt larger parts of the existing UI code but in general, a skin deviates so much from the original UI that it can not be embedded into the original code and often this leads to a fork of the UI layer. Style - A central visual appearance hub to manage the appearance of controls. This can contain geometry, colors, effects, font and font geometry or other output methods. Theme - Themes are variants of a given Style. They change some properties of it, such as the color palette, but still share the same essence and major design features. A classic example is having a \"light\" and a \"dark\" theme for you Style, which you change at runtime depending on the time of day or user preference. A theme is the simplest visual change. A theme requires a style which supports the theming functionality. A skin changes the layout of the user interface. If the information architecture is preserved the work required is to re-write the UI layer based custom style. All appearance changes require they run on top of the same platform.","title":"Skin / Style / Theme"},{"location":"topics/styles/#styling-versus-creating-new-controls","text":"You should strive to have the UI code of your QML application look familiar to any experienced QML UI developer. This means avoiding the introduction of new idioms and concepts unless when actually necessary. Qt Quick Controls 2 comes already with several common controls, such as Button, CheckBox, ComboBox, etc. It's worth making an effort to use those and make them look and behave according to your design specs via styling instead of jumping into the creation new controls such as MySpecialButton, MyProjectNameComboBox, and so on. It's a harder route, but it has multiple benefits, such as: It reduces the learning curve for new members in your team, as there are less new APIs and concepts to be learned. Makes your application easier to maintain. A consequence of the previous point. It's easier to port QML applications made for other platforms into your platform, as there are less APIs and concepts exclusive to your project or platform, which translates into less code changes. Don't reinvent the wheel, or \"stand on the shoulders of giants\". Time and effort was put into making the APIs of Qt Quick Controls 2 components, so it makes sense to try to use them instead of coming up with your own, which could be just duplicating effort.","title":"Styling versus creating new controls"},{"location":"topics/styles/#customizing-an-existing-style","text":"This is the process of modifying one of the built-in styles. It is often the initial step when defining your own style. The API of the controls does not change and for an initial UI, using an existing style and tweaking it for your own purposes is notably simpler than creating a brand new one from scratch. How to customize an existing style is covered :qt5: here <qtquickcontrols2-styles.html> .","title":"Customizing an existing Style"},{"location":"topics/styles/#creating-a-new-style","text":"If your HMI has its own particlar look and feel, its own UI design guide, the :qt5: existing Qt Quick Controls 2 styles <qtquickcontrols2-styles.html> probably won't suite you and you will have to create your own style to implement what the UI/UX designers envisioned. To exemplify how this is achieved let's start with a simple UI, a sort of components gallery showcasing a handful of Qt Quick Controls 2 components in different states. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import QtQuick 2.11 import QtQuick . Controls 2.1 Pane { width: 600 height: 600 Column { anchors.fill: parent padding: 50 spacing: 25 Row { spacing: 25 Button { text: \"Button\" } Button { text: \"Button\" ; enabled: false } } Row { spacing: 25 CheckBox { text: \"Checkbox\" } CheckBox { text: \"Checkbox\" ; checked: true } } Row { spacing: 25 Switch {} Switch { checked: true } } Label { text: \"Label\" } } } Save it as, say, controls.qml. Now run it with the qml tool 1 $ qml controls.qml You should see something like this: Then try it with one of the styles shipped with Qt Quick Controls 2, such as \"material\" 1 $ qml controls.qml -style material Or \"fusion\" (in a desktop environment that's using a dark theme) 1 $ qml controls.qml -style fusion You can see that by using Qt Quick Controls 2 styles you can have the application code independent of the look and feel of its components. So no changes are needed in the components' API exposed to application code. Now we are going to create a new style that implements a different look and feel, which we will call \"foobar\". The first component we will customize in the foobar style is going to be the Pane, as it's the simplest. Create a subdirectory called \"foobar\". Then copy the file QT_INSTALL_DIR/qml/QtQuick/Controls.2/Pane.qml to it, where QT_INSTALL_DIR is the path where your Qt is installed. It should look like the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import QtQuick 2.12 import QtQuick . Controls 2.5 import QtQuick . Controls . impl 2.5 import QtQuick . Templates 2.5 as T T . Pane { id: control implicitWidth: Math . max ( implicitBackgroundWidth + leftInset + rightInset , contentWidth + leftPadding + rightPadding ) implicitHeight: Math . max ( implicitBackgroundHeight + topInset + bottomInset , contentHeight + topPadding + bottomPadding ) padding: 12 background: Rectangle { color: control . palette . window } } The idea is to collect the standard implementation of the component whose look & feel you want to customize in your style from that directory in Qt to your own style directory and then modify it at will. In our foobar style we want the Pane background to be a Gradient instead, hence we will make the following change: 1 2 3 4 5 6 7 8 ... background: Rectangle { gradient: Gradient { GradientStop { position: 0.0 ; color: \"dodgerblue\" } GradientStop { position: 1.0 ; color: \"lightsteelblue\" } } } ... Now let's run our controls.qml app with our brand new style. For that we will have to supply two additional environment variables: QT_QUICK_CONTROLS_STYLE_PATH to tell Qt where in the filesystem to look for more styles and QT_QUICK_CONTROLS_FALLBACK_STYLE to tell Qt which style to fallback on in case the chosen one is missing the implementation of some component (more info :qt5: here <qtquickcontrols2-environment.html> ). Since our foobar style just has the implementation of Pane, all other components will fallback to another implementation. 1 $ QT_QUICK_CONTROLS_STYLE_PATH = . QT_QUICK_CONTROLS_FALLBACK_STYLE = Material qml controls.qml -style foobar Next we want to style the Button component. As with did with Pane, just copy Button.qml over from QT_INSTALL_DIR/qml/QtQuick/Controls.2 into our foobar style directory. If you open that file now you will see that it's quite more involded than the Pane: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import QtQuick 2.12 import QtQuick . Controls 2.5 import QtQuick . Controls . impl 2.5 import QtQuick . Templates 2.5 as T T . Button { id: control implicitWidth: Math . max ( implicitBackgroundWidth + leftInset + rightInset , implicitContentWidth + leftPadding + rightPadding ) implicitHeight: Math . max ( implicitBackgroundHeight + topInset + bottomInset , implicitContentHeight + topPadding + bottomPadding ) padding: 6 horizontalPadding: padding + 2 spacing: 6 icon.width: 24 icon.height: 24 icon.color: control . checked || control . highlighted ? control.palette.brightText : control . flat && ! control . down ? ( control . visualFocus ? control.palette.highlight : control . palette . windowText ) : control . palette . buttonText contentItem: IconLabel { spacing: control . spacing mirrored: control . mirrored display: control . display icon: control . icon text: control . text font: control . font color: control . checked || control . highlighted ? control.palette.brightText : control . flat && ! control . down ? ( control . visualFocus ? control.palette.highlight : control . palette . windowText ) : control . palette . buttonText } background: Rectangle { implicitWidth: 100 implicitHeight: 40 visible: ! control . flat || control . down || control . checked || control . highlighted color: Color . blend ( control . checked || control . highlighted ? control.palette.dark : control . palette . button , control . palette . mid , control . down ? 0.5 : 0.0 ) border.color: control . palette . highlight border.width: control . visualFocus ? 2 : 0 } } You're free to change anything at will. This is just a default look & feel implementation. You're free to take it as it is, do some small modifications on top of it or wipe it out and do something completely different. What's important is to try to and obey the exising properties (icon, text, impleicitWidth, etc) as much as it makes sense to in your HMI usage and to put the foreground content of your button (eg, text and icon) in contentItem and its background, if any, in background . It's worth noting the widespread usage of the palette property. If you want to tweak its values in your style, the best place to do so would be in the Control.qml style implementation, as all Qt Quick Controls 2 components inherit from it. But if the categories (button, windowText, highlight, etc) in that palette type don't really suite your needs or your UI design guide you're free to use your own structure to keep your custom color and other values instead. We will come back to it later. For now let's just set a hardcoded background color, make the background rounded, make the button larger when down/pushed and have its text rotating (just because we can :) ). These would be the modifications: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 --- a/foobar/Button.qml +++ b/foobar/Button.qml @@ -15,12 +15,18 @@ T.Button { horizontalPadding: padding + 2 spacing: 6 + scale: control.down ? 1.4 : 1 + Behavior on scale { + NumberAnimation { easing.type: Easing.OutCubic; duration: 200 } + } + icon.width: 24 icon.height: 24 icon.color: control.checked || control.highlighted ? control.palette.brightText : control.flat && !control.down ? (control.visualFocus ? control.palette.highlight : control.palette.windowText) : control.palette.buttonText contentItem: IconLabel { + id: iconLabel spacing: control.spacing mirrored: control.mirrored display: control.display @@ -30,15 +36,29 @@ T.Button { font: control.font color: control.checked || control.highlighted ? control.palette.brightText : control.flat && !control.down ? (control.visualFocus ? control.palette.highlight : control.palette.windowText) : control.palette.buttonText + + RotationAnimator { + target: iconLabel + from: 0; to: 360 + duration: 1500 + running: true + loops: Animation.Infinite + } } background: Rectangle { implicitWidth: 100 implicitHeight: 40 visible: !control.flat || control.down || control.checked || control.highlighted - color: Color.blend(control.checked || control.highlighted ? control.palette.dark : control.palette.button, - control.palette.mid, control.down ? 0.5 : 0.0) + + color: \"seagreen\" + opacity: control.down ? 1 : 0.8 + Behavior on opacity { + NumberAnimation { easing.type: Easing.OutCubic; duration: 200 } + } + border.color: control.palette.highlight border.width: control.visualFocus ? 2 : 0 + radius: width / 2 } } If you run that application again you should see that the buttons are animated and look wildly different from the other styles. This is just to give an idea of how flexible and powerful the Qt Quick Controls 2 styling is.","title":"Creating a new Style"},{"location":"topics/styles/#collecting-values-in-a-style-object","text":"So far we have been hardcoding color values directly in the component's style implementation. But for better reusability it's prefferable to give them names and collect them all into a single entity. There are a couple of ways of doing it but, again, we will start with the simplest: creating a new qml module containing a singleton QtObject which will hold all the color and other values used throughout the style implementation. In this example we will name that singleton FoobarStyle . Create a subdirectory called imports and inside it yet another subdirectory called FoobarStyle , which will be the name of our qml module. Inside imports/FoobarStyle create a file named qmldir with the following content:: 1 2 module FoobarStyle singleton FoobarStyle 1.0 FoobarStyle . qml Then proceed to create the file FoobarStyle.qml also inside imports/FoobarStyle :: 1 2 3 4 5 6 7 8 9 pragma singleton import QtQuick 2.11 QtObject { property color gradientBackgroundTopColor : \"dodgerblue\" property color gradientBackgroundBottomColor : \"lightsteelblue\" property color buttonBackgroundColor : \"seagreen\" } FoobarStyle collects the colors have been used so far. You can have those names be more specific (eg. button background color) or more generic (eg. secondary control color) according to how they're used throught the implenentation and how your UI Style guide describes them. Now let's get back to Panel.qml and Button.qml replacing the hardcoded values with their corresponding named colors:: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 --- a/foobar/Button.qml +++ b/foobar/Button.qml @@ -3,6 +3,8 @@ import QtQuick.Controls 2.5 import QtQuick.Controls.impl 2.5 import QtQuick.Templates 2.5 as T +import FoobarStyle 1.0 + T.Button { id: control @@ -51,7 +53,7 @@ T.Button { implicitHeight: 40 visible: !control.flat || control.down || control.checked || control.highlighted - color: \"seagreen\" + color: FoobarStyle.buttonBackgroundColor opacity: control.down ? 1 : 0.8 Behavior on opacity { NumberAnimation { easing.type: Easing.OutCubic; duration: 200 } diff --git a/foobar/Pane.qml b/foobar/Pane.qml index f903afa..b82be7f 100644 --- a/foobar/Pane.qml +++ b/foobar/Pane.qml @@ -3,6 +3,8 @@ import QtQuick.Controls 2.5 import QtQuick.Controls.impl 2.5 import QtQuick.Templates 2.5 as T +import FoobarStyle 1.0 + T.Pane { id: control @@ -15,8 +17,8 @@ T.Pane { background: Rectangle { gradient: Gradient { - GradientStop { position: 0.0; color: \"dodgerblue\" } - GradientStop { position: 1.0; color: \"lightsteelblue\" } + GradientStop { position: 0.0; color: FoobarStyle.gradientBackgroundTopColor } + GradientStop { position: 1.0; color: FoobarStyle.gradientBackgroundBottomColor } } } } Now to be able to run our controls.qml application we will also have to tell the qml tool to look into the imports subdirectory for qml modules. Hence:: 1 QT_QUICK_CONTROLS_STYLE_PATH = . QT_QUICK_CONTROLS_FALLBACK_STYLE = Material qml - I imports controls . qml - style foobar Note that having our named colors conveniently collected in a singleton also enables application code import FoobarStyle and use them directly whenever needed.","title":"Collecting values in a Style object"},{"location":"topics/styles/#adding-theming-support","text":"After having our hardcoded values such as named colors collected in a singleton, adding theming support is a simple, straightforward, step. The idea is that a single property in FooBarStyle , which we will name as theme , will define the value of all others. So this is our improved FoobarStyle.qml , now with theme support: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 pragma Singleton import QtQuick 2.11 QtObject { // Available themes readonly property int dayTheme: 0 readonly property int nightTheme: 1 // The chosen theme property int theme: dayTheme // The values that make up a theme readonly property color gradientBackgroundTopColor: theme === dayTheme ? \"dodgerblue\" : \"black\" readonly property color gradientBackgroundBottomColor: theme === dayTheme ? \"lightsteelblue\" : \"darkblue\" readonly property color buttonBackgroundColor: theme === dayTheme ? \"seagreen\" : \"maroon\" } And modifying the application code, controls.qml , so that clicking on the first button switches the theme:: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 --- a/controls.qml +++ b/controls.qml @@ -1,6 +1,8 @@ import QtQuick 2.11 import QtQuick.Controls 2.1 +import FoobarStyle 1.0 + Pane { width: 500 height: 400 @@ -13,7 +15,16 @@ Pane { Row { spacing: 25 - Button { text: \"Button\" } + Button { + text: FoobarStyle.theme === FoobarStyle.dayTheme ? \"Day\" : \"Night\" + onClicked: { + if (FoobarStyle.theme === FoobarStyle.dayTheme) { + FoobarStyle.theme = FoobarStyle.nightTheme; + } else { + FoobarStyle.theme = FoobarStyle.dayTheme; + } + } + } Button { text: \"Button\"; enabled: false } } This is how our controls.qml application should look like after having the theme support added to it:","title":"Adding theming support"},{"location":"topics/styles/#naming-conventions","text":"One common mistake when naming colors in particular is naming them after what they look like instead of their function or where they are used. So avoid names such as \"orangeBackgroundColor\" or \"lightTextColor\" and prefer usage, such as \"buttonBackgroundColor\" or a category such as \"primaryColor\" or \"accentColor\". After all, as soon as you have a day/light and a night/dark theme, a color property that used to have a \"yellow\" or \"light\" value will switch to have the opposite, having a \"dark\" or \"brown\" one instead. Naming a color property after the visual caracteristics of its value will void the abstraction level (and hence flexibility) it provides when compared to using hardcoded values directly. Having that said, there might still be value in naming a color in a explicit way in your style object, such as FoobarStyle.red, meaning that whenever your UI uses red, it's not just any red, or the standard 0xFF0000, but a very particular hue of red, which is specified in your style. And that only if the usage of this named red throught the UI is always the same, regardless of the theme. Such as the red that makes up the visual identity of your company or the red that signifies alert or the interruption of a call. Note describe why a sheet is a good concept to display your controls and how should it be built.","title":"Naming conventions"},{"location":"topics/testing/","text":"Testing Q: How many QA testers does it take to change a lightbulb? A: QA testers don't change anything. They just report that it's dark. There are different test strategies from white-box over black-box testing and system, integration and unit testing. System testing requires a whole system to operate and it will be stimulated from outside and the reaction to the stimulation will be validated. This test effort is not in the scope of this document. This chapter will mostly focus on the integration testing and and unit testing of the user interface layer. From the concept description we know there are control, panel, view, store and service component types in our architecture. These component are distributed on the UI layer (control, panel, view, store) and the middle-ware layer (service). Integration Testing When it comes to integration testing the most important aspect is how to integrate the UI layer with the underlying service layer and sure also the Qt5 components with the platform layer. There needs to be some mechanism to make this effort possible. UI Layer Integration Middle-ware Layer Integration Unit Testing A unit in our terms is a component. Also if this is not always exact it gives a good base to work on. To test a component you need to abstract away it dependencies. Control Testing A control is a UI part which only depends on Qt standard data types, as such it can be easily tested as there is no need to abstract away external extra dependencies. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 TestCase { id: root property Button control Component { id: component Button { } } function init () { // this is run for every test function control = createTemporaryObject ( component , root ); } SignalSpy { id: spy target: control signalName: \"clicked\" } function test_click () { compare ( spy . count , 0 ) control . clicked (); compare ( spy . count , 1 ) } } Panel Testing A panel is a UI container which similar to the control only depends on standard Qt data types. So there is also no need to extract away external dependencies. View Testing A view depends on the store and a store will depend on the services. So it is important to abstract away the store dependencies to allow a better testing if the views. Abstracting the store is the major issue in the testing strategy. A store abstraction is added called IRootStore which will contain the API of the root store. We need to use this IRootStore everywhere in the code to ensure we can switch it later with a root store mock. Here is how such a IRootStore would look like. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // stores/IRootStore.qml import CoreUI 1.0 Store { id: root readonly property int count property var increment: function () { console . error ( \"increment not implemented\" ); } property var decrement: function () { console . error ( \"decrement not implemented\" ); } } The exposed API count, increment(), decrement() is implemented without a real implementation. The js functions are declared as var properties so that they can later be overwritten by an actual implementation. The actual store would have the real implementation using in this example a counter service. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // stores/RootStore.qml IRootStore { id: root count: service . count property CounterService _service : CounterService { } increment: function () { return service . increment (); } decrement: function () { return service . decrement (); } } To create a mock store we can create one directly in the tests folder, called RootStoreMock. It derives from the IRootStore and implements the API in a way which can be tested. This means the results are exposed. It is also possible to add new API to the mocked store. These properties and functions should be prefixed with an _ to show the user this is not an official API of the root store. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // stores/tests/RootStoreMock.qml import \"..\" IRootStore { id: root count: 0 property int _previousCount : count increment: function () { _previousCount = count ; count ++ ; return count ; } decrement: function () { _previousCount = count ; -- count ; return count ; } } Now with the mocked root store we can run the tests. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // stores/tests/tst_welcomeview.qml import QtTest 1.1 import \"..\" import \"../mocked\" TestCase { id: root property WelcomeView view ; Component { id: component WelcomeView { store: RootStoreMock {} } } function init () { // this is run for every test function view = createTemporaryObject ( component , root ); // assert initial state compare ( 0 , view . store . count ); } // testing increment action function test_increment () { compare ( 0 , view . store . _previousCount ); var item = findChield ( view , \"increment\" ); mouseClick ( item ); compare ( 0 , view . store . _previousCount ); compare ( 1 , view . store . count ); mouseClick ( item ); compare ( 1 , view . store . _previousCount ); compare ( 2 , view . store . count ); } // testing decrement action function test_decrement () { var item = findChield ( view , \"decrement\" ); mouseClick ( item ); compare ( 0 , view . store . _previousCount ); compare ( - 1 , view . store . count ); } } This should give the reader an idea how to test an view component which depends on a store with many external dependencies. Store Testing A store depends on the services and as such it depends on the chosen service architecture and their limitations. Ideally a store could be tested using a service simulation back-end which will run inside the test process and which is fully controllable. A normal service implementation would use some kind of IPC and requires a second process to be started. As this way of testing is error prone (start two processes, await both are established, initiate connection, wait until connection ready, ...) it would be better we could create a custom service implementation inside our test and would not have to modify the service client. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 TestCase { id: root CounterService { id: service register: true increment: function () { count ++ ; } decrement: function () { count -- ; } } property IRootStore store ; Component { id: component RootStore { } } function init () { // this is run for every test function store = createTemporaryObject ( component , root ); // assert initial state compare ( 0 , store . count ); } void test_increment () { store . increment (); tryCompare ( store . count , service . count ); } void test_decrement () { store . decrement (); tryCompare ( store . count , service . count ); } } Note Discuss a way when the service can not be embedded into the test case, e.g. sequential testing ... In case the service can not be integrated into the QML test case it is often desirable to let the test case start the service server and reset the particular server. Additional the test should run in sequence. For this we would need to write a small plugin which controls the server (start/stop) ans waits notifies the test case when the server is fully loaded. Also the server control should expose a reset operation to reset the data on the server. Resetting is often faster then shutdown/startup sequence. Finally the test functions should be arranged in sequence. For this we need to ensure the tests are named in a way to they are ordered by name. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 TestCase { when: control . ready ServerControl { id: control services: \"counter\" } ServerSniffer { id: sniffer server: control . server } CounterClient { id: client } function test_001_increment () { sniffer . reset (); client . increment (); tryCompare ( sniffer . received , \"increment\" ) } function test_002_decrement () { sniffer . reset (); client . decrement (); tryCompare ( sniffer . received , \"decrement\" ) } } Service Testing Testing a service is often divided into testing the client, the transport and the service implementation. As the service implementation is not under the control of the UI layer it is out of scope here. A client can be tested if the simulation back-end uses the same client component and the same transport. A transport should always be tested in isolation as this is often an external library. If the simulation back-end uses a different client and only shares the client API then there is a need to ensure the client is also tested. Often this is not done due to a client is often semi-generated and there is no need to test generated code.","title":"Testing"},{"location":"topics/testing/#testing","text":"Q: How many QA testers does it take to change a lightbulb? A: QA testers don't change anything. They just report that it's dark. There are different test strategies from white-box over black-box testing and system, integration and unit testing. System testing requires a whole system to operate and it will be stimulated from outside and the reaction to the stimulation will be validated. This test effort is not in the scope of this document. This chapter will mostly focus on the integration testing and and unit testing of the user interface layer. From the concept description we know there are control, panel, view, store and service component types in our architecture. These component are distributed on the UI layer (control, panel, view, store) and the middle-ware layer (service).","title":"Testing"},{"location":"topics/testing/#integration-testing","text":"When it comes to integration testing the most important aspect is how to integrate the UI layer with the underlying service layer and sure also the Qt5 components with the platform layer. There needs to be some mechanism to make this effort possible.","title":"Integration Testing"},{"location":"topics/testing/#ui-layer-integration","text":"","title":"UI Layer Integration"},{"location":"topics/testing/#middle-ware-layer-integration","text":"","title":"Middle-ware Layer Integration"},{"location":"topics/testing/#unit-testing","text":"A unit in our terms is a component. Also if this is not always exact it gives a good base to work on. To test a component you need to abstract away it dependencies.","title":"Unit Testing"},{"location":"topics/testing/#control-testing","text":"A control is a UI part which only depends on Qt standard data types, as such it can be easily tested as there is no need to abstract away external extra dependencies. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 TestCase { id: root property Button control Component { id: component Button { } } function init () { // this is run for every test function control = createTemporaryObject ( component , root ); } SignalSpy { id: spy target: control signalName: \"clicked\" } function test_click () { compare ( spy . count , 0 ) control . clicked (); compare ( spy . count , 1 ) } }","title":"Control Testing"},{"location":"topics/testing/#panel-testing","text":"A panel is a UI container which similar to the control only depends on standard Qt data types. So there is also no need to extract away external dependencies.","title":"Panel Testing"},{"location":"topics/testing/#view-testing","text":"A view depends on the store and a store will depend on the services. So it is important to abstract away the store dependencies to allow a better testing if the views. Abstracting the store is the major issue in the testing strategy. A store abstraction is added called IRootStore which will contain the API of the root store. We need to use this IRootStore everywhere in the code to ensure we can switch it later with a root store mock. Here is how such a IRootStore would look like. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // stores/IRootStore.qml import CoreUI 1.0 Store { id: root readonly property int count property var increment: function () { console . error ( \"increment not implemented\" ); } property var decrement: function () { console . error ( \"decrement not implemented\" ); } } The exposed API count, increment(), decrement() is implemented without a real implementation. The js functions are declared as var properties so that they can later be overwritten by an actual implementation. The actual store would have the real implementation using in this example a counter service. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // stores/RootStore.qml IRootStore { id: root count: service . count property CounterService _service : CounterService { } increment: function () { return service . increment (); } decrement: function () { return service . decrement (); } } To create a mock store we can create one directly in the tests folder, called RootStoreMock. It derives from the IRootStore and implements the API in a way which can be tested. This means the results are exposed. It is also possible to add new API to the mocked store. These properties and functions should be prefixed with an _ to show the user this is not an official API of the root store. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // stores/tests/RootStoreMock.qml import \"..\" IRootStore { id: root count: 0 property int _previousCount : count increment: function () { _previousCount = count ; count ++ ; return count ; } decrement: function () { _previousCount = count ; -- count ; return count ; } } Now with the mocked root store we can run the tests. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // stores/tests/tst_welcomeview.qml import QtTest 1.1 import \"..\" import \"../mocked\" TestCase { id: root property WelcomeView view ; Component { id: component WelcomeView { store: RootStoreMock {} } } function init () { // this is run for every test function view = createTemporaryObject ( component , root ); // assert initial state compare ( 0 , view . store . count ); } // testing increment action function test_increment () { compare ( 0 , view . store . _previousCount ); var item = findChield ( view , \"increment\" ); mouseClick ( item ); compare ( 0 , view . store . _previousCount ); compare ( 1 , view . store . count ); mouseClick ( item ); compare ( 1 , view . store . _previousCount ); compare ( 2 , view . store . count ); } // testing decrement action function test_decrement () { var item = findChield ( view , \"decrement\" ); mouseClick ( item ); compare ( 0 , view . store . _previousCount ); compare ( - 1 , view . store . count ); } } This should give the reader an idea how to test an view component which depends on a store with many external dependencies.","title":"View Testing"},{"location":"topics/testing/#store-testing","text":"A store depends on the services and as such it depends on the chosen service architecture and their limitations. Ideally a store could be tested using a service simulation back-end which will run inside the test process and which is fully controllable. A normal service implementation would use some kind of IPC and requires a second process to be started. As this way of testing is error prone (start two processes, await both are established, initiate connection, wait until connection ready, ...) it would be better we could create a custom service implementation inside our test and would not have to modify the service client. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 TestCase { id: root CounterService { id: service register: true increment: function () { count ++ ; } decrement: function () { count -- ; } } property IRootStore store ; Component { id: component RootStore { } } function init () { // this is run for every test function store = createTemporaryObject ( component , root ); // assert initial state compare ( 0 , store . count ); } void test_increment () { store . increment (); tryCompare ( store . count , service . count ); } void test_decrement () { store . decrement (); tryCompare ( store . count , service . count ); } } Note Discuss a way when the service can not be embedded into the test case, e.g. sequential testing ... In case the service can not be integrated into the QML test case it is often desirable to let the test case start the service server and reset the particular server. Additional the test should run in sequence. For this we would need to write a small plugin which controls the server (start/stop) ans waits notifies the test case when the server is fully loaded. Also the server control should expose a reset operation to reset the data on the server. Resetting is often faster then shutdown/startup sequence. Finally the test functions should be arranged in sequence. For this we need to ensure the tests are named in a way to they are ordered by name. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 TestCase { when: control . ready ServerControl { id: control services: \"counter\" } ServerSniffer { id: sniffer server: control . server } CounterClient { id: client } function test_001_increment () { sniffer . reset (); client . increment (); tryCompare ( sniffer . received , \"increment\" ) } function test_002_decrement () { sniffer . reset (); client . decrement (); tryCompare ( sniffer . received , \"decrement\" ) } }","title":"Store Testing"},{"location":"topics/testing/#service-testing","text":"Testing a service is often divided into testing the client, the transport and the service implementation. As the service implementation is not under the control of the UI layer it is out of scope here. A client can be tested if the simulation back-end uses the same client component and the same transport. A transport should always be tested in isolation as this is often an external library. If the simulation back-end uses a different client and only shares the client API then there is a need to ensure the client is also tested. Often this is not done due to a client is often semi-generated and there is no need to test generated code.","title":"Service Testing"},{"location":"topics/uilayer/","text":"User Interface Layer \u201cHave no fear of perfection\u2014you\u2019ll never reach it.\u201d \u2013- Salvador Dali Info This material is work in progress and will change! The UI is the topmost layer in our software stack. It presents the user with important information and offers interactions to the user. It communicates vertically with the services. Blocks of the UI Layer The UI layer is divided into the system UI (SysUI) which acts as the bootstrapping UI, the application UIs (AppUI) and the Common Controls library as also the UI style definition as part of the controls library. The service APIs are used to communicate vertically with the underlying middle-ware services. The UI uses the Qt5 UI toolkit to render the user interface but also to use its platform abstraction to allow the user interface layer to run on various supported platforms. The UI layers follow a defined folder structure to be able to grow the UI in a controlled way, across teams. UI Tree We see the user interface as a tree of components. The root component often called Main.qml will import and create other child components and by this form the UI tree. Applications introduce boundaries into the tree. In a multi-process user interface these boundaries are created using processes. In the tree a window handle is used to keep track on the application process window. The window information is mirrored inside the application window surface. Other UI elements will then be childs to the window surface and continue the UI tree. In a single-process UI there are now windows for applications and an application boundary is just created by the physical location of the code. Note Create a diagram for UI tree The UI tree allows us to see the user interface layer not as a monolith it rather allows us to see the UI as a tree of sub-trees. And each sub-tree when it dependencies are satisfied can be run independent. To run a sub-tree in the simplest form your runtime will just load a different QML component then the Main.qml document. Passing the initial root document to the runtime is an important aspect of staying agile. As only this approach allows us to load partially UI trees. Based on the initial document loaded and the to be created sub-tree the UI may have different dependencies. It is important to understand the layers below the user interface to understand the UI layer itself. Beneath the UI Layer The platform, in general, encompasses the OS and the Qt5 UI Toolkit together with any custom Qt5 platform adaptation. Often the platform team is also responsible to deliver the service implementations as also the client side service API in co-operation with the UI developers. The service implementation and client-side service APIs can also be seen as a task for a middle-ware team separated from the platform delivery, as there is much domain-specific knowledge required and adapting the service API towards the system is an effort where specialized knowledge is being required. Eventhough the service blocks look small on the diagram, they can be very large as there are many different services even many different servers required to map a larger feature set for a UI into service APIs. Relocating the UI Layer As the UI layer sits \"only\" on top of Qt5 and the Service APIs, it can be relocated onto another machine running a different OS. This allows the development of a host platform and using the services via an IPC protocol on the target device. This separation allows the UI layer to be developed independently from the HW if simulation services are available. Simulation Services A simulation service is a service which exposes the same client API as the native service but has only a simulated implementation. The implementation can be fairly easy, e.g. using hardcoded data or it can be already rather complete, by providing behavior. Ideally, the simulated service is independent of the HW so that it can also be relocated. Also as a simulated service is often used to test certain conditions, it should be able to load different scenarios and simulate not only data but also behavior in a generic way. A simulated service often uses a simulation framework to allow scripting of behavior and advanced simulation data generation. As a simulated service, it is not necessary to really do the thing, rather just to look from the API user perspective. For example in the case of a music player, it is not required to play back music, but rather change the API values about the current song, album the playtime and other properties. Ideally, to support a flexible setup, there is a central document which lists all services and allows the developer to easily switch from a simulated service to a native service. If all services are not depending on each other, then directly these switchings should happen without a considerable side-effect. In case a service is identified by an URI the listing could be something like this: 1 2 org.example : tcp://localhost:8154/org.example org.phone : simu://localhost/org.example The first entry would use a TCP connection to connect to the service module discoverable on the port 8154. The second entry would for example use the simulation protocol to a central simulation server running on the localhost. These are just examples of a potentially deployment document and shall just display a potential way of encoding the information. The exact way depends on the used IPC technology.","title":"UI Layer"},{"location":"topics/uilayer/#user-interface-layer","text":"\u201cHave no fear of perfection\u2014you\u2019ll never reach it.\u201d \u2013- Salvador Dali Info This material is work in progress and will change! The UI is the topmost layer in our software stack. It presents the user with important information and offers interactions to the user. It communicates vertically with the services.","title":"User Interface Layer"},{"location":"topics/uilayer/#blocks-of-the-ui-layer","text":"The UI layer is divided into the system UI (SysUI) which acts as the bootstrapping UI, the application UIs (AppUI) and the Common Controls library as also the UI style definition as part of the controls library. The service APIs are used to communicate vertically with the underlying middle-ware services. The UI uses the Qt5 UI toolkit to render the user interface but also to use its platform abstraction to allow the user interface layer to run on various supported platforms. The UI layers follow a defined folder structure to be able to grow the UI in a controlled way, across teams.","title":"Blocks of the UI Layer"},{"location":"topics/uilayer/#ui-tree","text":"We see the user interface as a tree of components. The root component often called Main.qml will import and create other child components and by this form the UI tree. Applications introduce boundaries into the tree. In a multi-process user interface these boundaries are created using processes. In the tree a window handle is used to keep track on the application process window. The window information is mirrored inside the application window surface. Other UI elements will then be childs to the window surface and continue the UI tree. In a single-process UI there are now windows for applications and an application boundary is just created by the physical location of the code. Note Create a diagram for UI tree The UI tree allows us to see the user interface layer not as a monolith it rather allows us to see the UI as a tree of sub-trees. And each sub-tree when it dependencies are satisfied can be run independent. To run a sub-tree in the simplest form your runtime will just load a different QML component then the Main.qml document. Passing the initial root document to the runtime is an important aspect of staying agile. As only this approach allows us to load partially UI trees. Based on the initial document loaded and the to be created sub-tree the UI may have different dependencies. It is important to understand the layers below the user interface to understand the UI layer itself.","title":"UI Tree"},{"location":"topics/uilayer/#beneath-the-ui-layer","text":"The platform, in general, encompasses the OS and the Qt5 UI Toolkit together with any custom Qt5 platform adaptation. Often the platform team is also responsible to deliver the service implementations as also the client side service API in co-operation with the UI developers. The service implementation and client-side service APIs can also be seen as a task for a middle-ware team separated from the platform delivery, as there is much domain-specific knowledge required and adapting the service API towards the system is an effort where specialized knowledge is being required. Eventhough the service blocks look small on the diagram, they can be very large as there are many different services even many different servers required to map a larger feature set for a UI into service APIs.","title":"Beneath the UI Layer"},{"location":"topics/uilayer/#relocating-the-ui-layer","text":"As the UI layer sits \"only\" on top of Qt5 and the Service APIs, it can be relocated onto another machine running a different OS. This allows the development of a host platform and using the services via an IPC protocol on the target device. This separation allows the UI layer to be developed independently from the HW if simulation services are available.","title":"Relocating the UI Layer"},{"location":"topics/uilayer/#simulation-services","text":"A simulation service is a service which exposes the same client API as the native service but has only a simulated implementation. The implementation can be fairly easy, e.g. using hardcoded data or it can be already rather complete, by providing behavior. Ideally, the simulated service is independent of the HW so that it can also be relocated. Also as a simulated service is often used to test certain conditions, it should be able to load different scenarios and simulate not only data but also behavior in a generic way. A simulated service often uses a simulation framework to allow scripting of behavior and advanced simulation data generation. As a simulated service, it is not necessary to really do the thing, rather just to look from the API user perspective. For example in the case of a music player, it is not required to play back music, but rather change the API values about the current song, album the playtime and other properties. Ideally, to support a flexible setup, there is a central document which lists all services and allows the developer to easily switch from a simulated service to a native service. If all services are not depending on each other, then directly these switchings should happen without a considerable side-effect. In case a service is identified by an URI the listing could be something like this: 1 2 org.example : tcp://localhost:8154/org.example org.phone : simu://localhost/org.example The first entry would use a TCP connection to connect to the service module discoverable on the port 8154. The second entry would for example use the simulation protocol to a central simulation server running on the localhost. These are just examples of a potentially deployment document and shall just display a potential way of encoding the information. The exact way depends on the used IPC technology.","title":"Simulation Services"},{"location":"topics/workflow/","text":"Design Work Flow \u201cDigital design is like painting, except the paint never dries.\u201d - Neville Brody Agile Scaled Agile Split Teams Asset Pipeline Handover Design/Simu/Product How to get designs into Qt? Modern projects tend to be user experience driven. There is a long phase before the actual development where the navigation and visual concepts are defined. Often when the development phase starts these concepts are not fully defined yet and they will be adapted while the software is created. When a new project is started and the first time visual concepts are defined it is a great opportunity to also attach a small software development team to the design team to create user interface prototypes using the Qt technology. The greatest synergy is created when the technology used in production is also used during prototyping. By this the design team can ensure if the user interface runs on a comparable hardware in a comparable context the user experience is really as envisioned. UX is only accomplished when the user interface uses the correct UI technology on a comparable hardware in a comparable context. Or even better on the real hardware. A design which showcases a great visual concept using PowerPoint, or a UI technology which will not be used in production on hardware which is not comparable to the product always runs the risk to stay a vision and never will reflect the reality of the product. A prototype should stay simple and not get to complex, it should stay lean and be cheap to change, even rapid change. Qt and QML as UI language support these goals on embedded device very neatly. Qt runs on desktop PC as also on most embedded systems, it has great support stunning user interfaces and support a vast variety of animations and graphical effects. It can be used during prototyping as also later during production, by this shortening the time to market and dramatically simplifying the transition from prototyping to production. Designer Types There is more than one type of designer. Same as developers who specialize in the programming areas (frontend, backend, os, network) designers also specialize on different area. The area could be something like this: Concept Designer - New user interface concepts Structure/Navigation - Design the UI flow, screen transitions, user stories, personas Visual Designer - Polished hero screens with beautiful designs and fonts Motion Designer - Animation sequences for design components 3D Content Designer - 3D textures, materials as also animations Production Designer - Adapt designs to production technology This would be a typical list in large companies and projects. In smaller projects there are often only one or a few designers trying to deliver not only the visual design but also the UI flow and motions. Deliverables Often the direct design output is not usable for production or even prototyping. The deliverables could be PhotoShop documents or Adobe Illustrator documents. The issue is, these formats are not meant for digital user interface, they are created for media design. There is a new breed of design tools which are specialized for digital screens, these are Sketch, Figma, AdobeXD, ... These tools produce output which can be easily integrated into software solutions and cut a lot of needless asset conversions. They are more direct and increase the designer developer rhythm to create a better UX. Assuming we mean the same UX, as UX running on a comparable HW using a production technology in a comparable context. A modern user interface is composed of components, which are used and reused across screens. A component library defines the building blocks for the developer. It should be the exception that a developer has to create a new screen specific component. If this happens, often this hints about an inconsistent in the design across screens. To be able to consume deliverable not designed for direct software consumption the role of a production designer was created. This person will be responsible to convert the incoming designs ready for consumption by the software. Often software developers lack the skills to use the highly specialized designer tools or do not have even access to these tools. Production Designer A production designer takes over the role to convert the visual designs into a format consumable by the software. The most common format is PNG for images/icons. But also Fonts as TTF or audio files. For animations these are often described in a textual format but could also be directly coded into QML. A production designer understand the design workflow from his colleagues. He is embedded in to the design team. As an additional feature the designer also understands the software solution and the component model. It is important that the production designer understands both worlds to adapt the design. Note During a project we see the flow starts to change. The borders between design and developers start to blur as designers get exposed to the user interface technology. A designer which crosses these borders is also called a fullstack-designer. These designers will start to be the productivity boost for the product. Full Stack Designer A full stack designer understands that the UI technology and its rendering capabilities has direct impact on the user experience and the envisioned design. Often even an understanding of the UI technology and its limitations and features better help to reach a common goal. Sometimes even a designer discovers that complex things are very simple and on the other hand a simple design aspects can be utterly complex to realise in software. A designer which likes to code in QML/JS to create user interface concepts backed up with designs will realize soon that these UI concepts are much faster to realize than the complex step to create a full user interface specifications. If a flow between design and developers is created the process of discovering user interfaces is so fast that writing a design spec actually hinders the productivity and writing the design spec is then often an after thought to ensure the decisions are documented. We have good experience using shared, transparent documentation tools like Confluence to share design concepts as also user interface specifications. The collaborative aspect allows other stakeholders to asks questions and get knowledge to fulfill their jobs. Sharing concept/specification does not mean attaching documents to pages it means writing these documents inside this collaborative tools. Sample Setup We have great experience with Sketch as a design tool. It is ideally suited for the work. But I would expect also Figma would be a good tool. Sketch as a tool understand the concept of a component and allows effortless to export PNG images in different sizes. These exports have a clear size, meaning with and height which is required for the integration. Doing the same export twice should alway lead to the same asset exports having the same characteristics. Exporting assets by hand is very error prone and very unproductive for the developer later. There is currently no good tooling to validate an asset delivery. Just think about for a moment. Let us assume we get every week a new delivery from the design department. How do we ensure that all assets which where present last week, are also present this week how can we track when an asset was renamed or relocated How to detect that an asset has changed in size or even for the visual center How to know which asset have been added So if there is no good tooling for this, it can be very hard for a developer to integrate the new delivery. It might that some images will not show up at all, as they where removed or renamed or they show up in a weird place, as image was resized. Changing these thing from delivery to delivery will ead to frustration and a not productive result, which is error prone. Evolutionary Prototyping When you use Qt as a prototyping technology as also as a production technology you can apply a evolutionary prototyping strategy. This means the prototype is not thrown away of the concept phase it is continued to evolve into the product. Not every setup will be suited for this. It is important that the design dn development team continues to work on the software when it comes for production. Also it is important that a scalable architecture like the CoreUI architecture was chosen to ensure the fundamentals are stable enough. When the architecture is well established and the software team continues to work on this during production than a evolutionary prototyping can save valuable time and resource. If these conditions are not met, than its better to star over with a new software solution and use the prototype as an inspiration. No developer wants to maintain someone elses hastily written demo code, and a lack of ownership will lead to not motivated developers and a bad productivity. For a developer having ownership over the code a great productivity and responsibility boost. Evolutionary prototyping is a must for all teams which are working on a new UX centered product where time to market is a deciding factor. So better arrange the teams and involve developers early into the loop.","title":"Design Work Flow"},{"location":"topics/workflow/#design-work-flow","text":"\u201cDigital design is like painting, except the paint never dries.\u201d - Neville Brody Agile Scaled Agile Split Teams Asset Pipeline Handover Design/Simu/Product How to get designs into Qt? Modern projects tend to be user experience driven. There is a long phase before the actual development where the navigation and visual concepts are defined. Often when the development phase starts these concepts are not fully defined yet and they will be adapted while the software is created. When a new project is started and the first time visual concepts are defined it is a great opportunity to also attach a small software development team to the design team to create user interface prototypes using the Qt technology. The greatest synergy is created when the technology used in production is also used during prototyping. By this the design team can ensure if the user interface runs on a comparable hardware in a comparable context the user experience is really as envisioned. UX is only accomplished when the user interface uses the correct UI technology on a comparable hardware in a comparable context. Or even better on the real hardware. A design which showcases a great visual concept using PowerPoint, or a UI technology which will not be used in production on hardware which is not comparable to the product always runs the risk to stay a vision and never will reflect the reality of the product. A prototype should stay simple and not get to complex, it should stay lean and be cheap to change, even rapid change. Qt and QML as UI language support these goals on embedded device very neatly. Qt runs on desktop PC as also on most embedded systems, it has great support stunning user interfaces and support a vast variety of animations and graphical effects. It can be used during prototyping as also later during production, by this shortening the time to market and dramatically simplifying the transition from prototyping to production.","title":"Design Work Flow"},{"location":"topics/workflow/#designer-types","text":"There is more than one type of designer. Same as developers who specialize in the programming areas (frontend, backend, os, network) designers also specialize on different area. The area could be something like this: Concept Designer - New user interface concepts Structure/Navigation - Design the UI flow, screen transitions, user stories, personas Visual Designer - Polished hero screens with beautiful designs and fonts Motion Designer - Animation sequences for design components 3D Content Designer - 3D textures, materials as also animations Production Designer - Adapt designs to production technology This would be a typical list in large companies and projects. In smaller projects there are often only one or a few designers trying to deliver not only the visual design but also the UI flow and motions.","title":"Designer Types"},{"location":"topics/workflow/#deliverables","text":"Often the direct design output is not usable for production or even prototyping. The deliverables could be PhotoShop documents or Adobe Illustrator documents. The issue is, these formats are not meant for digital user interface, they are created for media design. There is a new breed of design tools which are specialized for digital screens, these are Sketch, Figma, AdobeXD, ... These tools produce output which can be easily integrated into software solutions and cut a lot of needless asset conversions. They are more direct and increase the designer developer rhythm to create a better UX. Assuming we mean the same UX, as UX running on a comparable HW using a production technology in a comparable context. A modern user interface is composed of components, which are used and reused across screens. A component library defines the building blocks for the developer. It should be the exception that a developer has to create a new screen specific component. If this happens, often this hints about an inconsistent in the design across screens. To be able to consume deliverable not designed for direct software consumption the role of a production designer was created. This person will be responsible to convert the incoming designs ready for consumption by the software. Often software developers lack the skills to use the highly specialized designer tools or do not have even access to these tools.","title":"Deliverables"},{"location":"topics/workflow/#production-designer","text":"A production designer takes over the role to convert the visual designs into a format consumable by the software. The most common format is PNG for images/icons. But also Fonts as TTF or audio files. For animations these are often described in a textual format but could also be directly coded into QML. A production designer understand the design workflow from his colleagues. He is embedded in to the design team. As an additional feature the designer also understands the software solution and the component model. It is important that the production designer understands both worlds to adapt the design. Note During a project we see the flow starts to change. The borders between design and developers start to blur as designers get exposed to the user interface technology. A designer which crosses these borders is also called a fullstack-designer. These designers will start to be the productivity boost for the product.","title":"Production Designer"},{"location":"topics/workflow/#full-stack-designer","text":"A full stack designer understands that the UI technology and its rendering capabilities has direct impact on the user experience and the envisioned design. Often even an understanding of the UI technology and its limitations and features better help to reach a common goal. Sometimes even a designer discovers that complex things are very simple and on the other hand a simple design aspects can be utterly complex to realise in software. A designer which likes to code in QML/JS to create user interface concepts backed up with designs will realize soon that these UI concepts are much faster to realize than the complex step to create a full user interface specifications. If a flow between design and developers is created the process of discovering user interfaces is so fast that writing a design spec actually hinders the productivity and writing the design spec is then often an after thought to ensure the decisions are documented. We have good experience using shared, transparent documentation tools like Confluence to share design concepts as also user interface specifications. The collaborative aspect allows other stakeholders to asks questions and get knowledge to fulfill their jobs. Sharing concept/specification does not mean attaching documents to pages it means writing these documents inside this collaborative tools.","title":"Full Stack Designer"},{"location":"topics/workflow/#sample-setup","text":"We have great experience with Sketch as a design tool. It is ideally suited for the work. But I would expect also Figma would be a good tool. Sketch as a tool understand the concept of a component and allows effortless to export PNG images in different sizes. These exports have a clear size, meaning with and height which is required for the integration. Doing the same export twice should alway lead to the same asset exports having the same characteristics. Exporting assets by hand is very error prone and very unproductive for the developer later. There is currently no good tooling to validate an asset delivery. Just think about for a moment. Let us assume we get every week a new delivery from the design department. How do we ensure that all assets which where present last week, are also present this week how can we track when an asset was renamed or relocated How to detect that an asset has changed in size or even for the visual center How to know which asset have been added So if there is no good tooling for this, it can be very hard for a developer to integrate the new delivery. It might that some images will not show up at all, as they where removed or renamed or they show up in a weird place, as image was resized. Changing these thing from delivery to delivery will ead to frustration and a not productive result, which is error prone.","title":"Sample Setup"},{"location":"topics/workflow/#evolutionary-prototyping","text":"When you use Qt as a prototyping technology as also as a production technology you can apply a evolutionary prototyping strategy. This means the prototype is not thrown away of the concept phase it is continued to evolve into the product. Not every setup will be suited for this. It is important that the design dn development team continues to work on the software when it comes for production. Also it is important that a scalable architecture like the CoreUI architecture was chosen to ensure the fundamentals are stable enough. When the architecture is well established and the software team continues to work on this during production than a evolutionary prototyping can save valuable time and resource. If these conditions are not met, than its better to star over with a new software solution and use the prototype as an inspiration. No developer wants to maintain someone elses hastily written demo code, and a lack of ownership will lead to not motivated developers and a bad productivity. For a developer having ownership over the code a great productivity and responsibility boost. Evolutionary prototyping is a must for all teams which are working on a new UX centered product where time to market is a deciding factor. So better arrange the teams and involve developers early into the loop.","title":"Evolutionary Prototyping"}]}